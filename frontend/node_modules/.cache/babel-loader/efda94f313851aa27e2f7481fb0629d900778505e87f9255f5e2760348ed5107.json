{"ast":null,"code":"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */let $488c6ddbf4ef74c2$var$formatterCache = new Map();\nlet $488c6ddbf4ef74c2$var$supportsSignDisplay = false;\ntry {\n  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat('de-DE', {\n    signDisplay: 'exceptZero'\n  }).resolvedOptions().signDisplay === 'exceptZero';\n  // eslint-disable-next-line no-empty\n} catch {}\nlet $488c6ddbf4ef74c2$var$supportsUnit = false;\ntry {\n  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat('de-DE', {\n    style: 'unit',\n    unit: 'degree'\n  }).resolvedOptions().style === 'unit';\n  // eslint-disable-next-line no-empty\n} catch {}\n// Polyfill for units since Safari doesn't support them yet. See https://bugs.webkit.org/show_bug.cgi?id=215438.\n// Currently only polyfilling the unit degree in narrow format for ColorSlider in our supported locales.\n// Values were determined by switching to each locale manually in Chrome.\nconst $488c6ddbf4ef74c2$var$UNITS = {\n  degree: {\n    narrow: {\n      default: \"\\xb0\",\n      'ja-JP': \" \\u5EA6\",\n      'zh-TW': \"\\u5EA6\",\n      'sl-SI': \" \\xb0\"\n    }\n  }\n};\nclass $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 {\n  /** Formats a number value as a string, according to the locale and options provided to the constructor. */format(value) {\n    let res = '';\n    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);else res = this.numberFormatter.format(value);\n    if (this.options.style === 'unit' && !$488c6ddbf4ef74c2$var$supportsUnit) {\n      var _UNITS_unit;\n      let {\n        unit: unit,\n        unitDisplay = 'short',\n        locale: locale\n      } = this.resolvedOptions();\n      if (!unit) return res;\n      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];\n      res += values[locale] || values.default;\n    }\n    return res;\n  }\n  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */\n  formatToParts(value) {\n    // TODO: implement signDisplay for formatToParts\n    return this.numberFormatter.formatToParts(value);\n  }\n  /** Formats a number range as a string. */\n  formatRange(start, end) {\n    if (typeof this.numberFormatter.formatRange === 'function') return this.numberFormatter.formatRange(start, end);\n    if (end < start) throw new RangeError('End date must be >= start date');\n    // Very basic fallback for old browsers.\n    return `${this.format(start)} \\u{2013} ${this.format(end)}`;\n  }\n  /** Formats a number range as an array of parts. */\n  formatRangeToParts(start, end) {\n    if (typeof this.numberFormatter.formatRangeToParts === 'function') return this.numberFormatter.formatRangeToParts(start, end);\n    if (end < start) throw new RangeError('End date must be >= start date');\n    let startParts = this.numberFormatter.formatToParts(start);\n    let endParts = this.numberFormatter.formatToParts(end);\n    return [...startParts.map(p => ({\n      ...p,\n      source: 'startRange'\n    })), {\n      type: 'literal',\n      value: \" \\u2013 \",\n      source: 'shared'\n    }, ...endParts.map(p => ({\n      ...p,\n      source: 'endRange'\n    }))];\n  }\n  /** Returns the resolved formatting options based on the values passed to the constructor. */\n  resolvedOptions() {\n    let options = this.numberFormatter.resolvedOptions();\n    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {\n      ...options,\n      signDisplay: this.options.signDisplay\n    };\n    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === 'unit') options = {\n      ...options,\n      style: 'unit',\n      unit: this.options.unit,\n      unitDisplay: this.options.unitDisplay\n    };\n    return options;\n  }\n  constructor(locale, options = {}) {\n    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);\n    this.options = options;\n  }\n}\nfunction $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {\n  let {\n    numberingSystem: numberingSystem\n  } = options;\n  if (numberingSystem && locale.includes('-nu-')) {\n    if (!locale.includes('-u-')) locale += '-u-';\n    locale += `-nu-${numberingSystem}`;\n  }\n  if (options.style === 'unit' && !$488c6ddbf4ef74c2$var$supportsUnit) {\n    var _UNITS_unit;\n    let {\n      unit: unit,\n      unitDisplay = 'short'\n    } = options;\n    if (!unit) throw new Error('unit option must be provided with style: \"unit\"');\n    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);\n    options = {\n      ...options,\n      style: 'decimal'\n    };\n  }\n  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : '');\n  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);\n  let numberFormatter = new Intl.NumberFormat(locale, options);\n  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);\n  return numberFormatter;\n}\nfunction $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {\n  if (signDisplay === 'auto') return numberFormat.format(num);else if (signDisplay === 'never') return numberFormat.format(Math.abs(num));else {\n    let needsPositiveSign = false;\n    if (signDisplay === 'always') needsPositiveSign = num > 0 || Object.is(num, 0);else if (signDisplay === 'exceptZero') {\n      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);else needsPositiveSign = num > 0;\n    }\n    if (needsPositiveSign) {\n      let negative = numberFormat.format(-num);\n      let noSign = numberFormat.format(num);\n      // ignore RTL/LTR marker character\n      let minus = negative.replace(noSign, '').replace(/\\u200e|\\u061C/, '');\n      if ([...minus].length !== 1) console.warn('@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case');\n      let positive = negative.replace(noSign, '!!!').replace(minus, '+').replace('!!!', noSign);\n      return positive;\n    } else return numberFormat.format(num);\n  }\n}\nexport { $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 as NumberFormatter, $488c6ddbf4ef74c2$export$711b50b3c525e0f2 as numberFormatSignDisplayPolyfill };\n//# sourceMappingURL=NumberFormatter.module.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
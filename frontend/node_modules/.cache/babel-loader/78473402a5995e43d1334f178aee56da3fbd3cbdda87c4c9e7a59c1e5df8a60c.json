{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { ListCollection } from '@zag-js/collection';\nimport { ref, createMachine, guards } from '@zag-js/core';\nimport { createScope, dataAttr, getEventKey, getByTypeahead, ariaAttr, visuallyHiddenStyle, isSelfTarget, isValidTabEvent, getEventTarget, isEditableElement, trackFormControl, raf, observeAttributes, getInitialFocus, scrollIntoView } from '@zag-js/dom-query';\nimport { getPlacementStyles, getPlacement } from '@zag-js/popper';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { createSplitProps, compact, isEqual, addOrRemove } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/select.anatomy.ts\nvar anatomy = createAnatomy(\"select\").parts(\"label\", \"positioner\", \"trigger\", \"indicator\", \"clearTrigger\", \"item\", \"itemText\", \"itemIndicator\", \"itemGroup\", \"itemGroupLabel\", \"list\", \"content\", \"root\", \"control\", \"valueText\");\nvar parts = anatomy.build();\nvar collection = options => {\n  return ref(new ListCollection(options));\n};\ncollection.empty = () => {\n  return ref(new ListCollection({\n    items: []\n  }));\n};\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `select:${ctx.id}`,\n  getContentId: ctx => ctx.ids?.content ?? `select:${ctx.id}:content`,\n  getTriggerId: ctx => ctx.ids?.trigger ?? `select:${ctx.id}:trigger`,\n  getClearTriggerId: ctx => ctx.ids?.clearTrigger ?? `select:${ctx.id}:clear-trigger`,\n  getLabelId: ctx => ctx.ids?.label ?? `select:${ctx.id}:label`,\n  getControlId: ctx => ctx.ids?.control ?? `select:${ctx.id}:control`,\n  getItemId: (ctx, id) => ctx.ids?.item?.(id) ?? `select:${ctx.id}:option:${id}`,\n  getHiddenSelectId: ctx => ctx.ids?.hiddenSelect ?? `select:${ctx.id}:select`,\n  getPositionerId: ctx => ctx.ids?.positioner ?? `select:${ctx.id}:positioner`,\n  getItemGroupId: (ctx, id) => ctx.ids?.itemGroup?.(id) ?? `select:${ctx.id}:optgroup:${id}`,\n  getItemGroupLabelId: (ctx, id) => ctx.ids?.itemGroupLabel?.(id) ?? `select:${ctx.id}:optgroup-label:${id}`,\n  getHiddenSelectEl: ctx => dom.getById(ctx, dom.getHiddenSelectId(ctx)),\n  getContentEl: ctx => dom.getById(ctx, dom.getContentId(ctx)),\n  getControlEl: ctx => dom.getById(ctx, dom.getControlId(ctx)),\n  getTriggerEl: ctx => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getClearTriggerEl: ctx => dom.getById(ctx, dom.getClearTriggerId(ctx)),\n  getPositionerEl: ctx => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getHighlightedOptionEl(ctx) {\n    if (!ctx.highlightedValue) return null;\n    return dom.getById(ctx, dom.getItemId(ctx, ctx.highlightedValue));\n  }\n});\n\n// src/select.connect.ts\nfunction connect(state, send, normalize) {\n  const disabled = state.context.isDisabled;\n  const invalid = state.context.invalid;\n  const readOnly = state.context.readOnly;\n  const interactive = state.context.isInteractive;\n  const composite = state.context.composite;\n  const open = state.hasTag(\"open\");\n  const focused = state.matches(\"focused\");\n  const highlightedValue = state.context.highlightedValue;\n  const highlightedItem = state.context.highlightedItem;\n  const selectedItems = state.context.selectedItems;\n  const isTypingAhead = state.context.isTypingAhead;\n  const collection2 = state.context.collection;\n  const ariaActiveDescendant = highlightedValue ? dom.getItemId(state.context, highlightedValue) : void 0;\n  function getItemState(props2) {\n    const _disabled = collection2.getItemDisabled(props2.item);\n    const value = collection2.getItemValue(props2.item);\n    return {\n      value,\n      disabled: Boolean(disabled || _disabled),\n      highlighted: highlightedValue === value,\n      selected: state.context.value.includes(value)\n    };\n  }\n  const popperStyles = getPlacementStyles({\n    ...state.context.positioning,\n    placement: state.context.currentPlacement\n  });\n  return {\n    open,\n    focused,\n    empty: state.context.value.length === 0,\n    highlightedItem,\n    highlightedValue,\n    selectedItems,\n    hasSelectedItems: state.context.hasSelectedItems,\n    value: state.context.value,\n    valueAsString: state.context.valueAsString,\n    collection: collection2,\n    multiple: !!state.context.multiple,\n    disabled: !!disabled,\n    setCollection(collection3) {\n      send({\n        type: \"COLLECTION.SET\",\n        value: collection3\n      });\n    },\n    reposition(options = {}) {\n      send({\n        type: \"POSITIONING.SET\",\n        options\n      });\n    },\n    focus() {\n      dom.getTriggerEl(state.context)?.focus({\n        preventScroll: true\n      });\n    },\n    setOpen(nextOpen) {\n      if (nextOpen === open) return;\n      send(nextOpen ? \"OPEN\" : \"CLOSE\");\n    },\n    selectValue(value) {\n      send({\n        type: \"ITEM.SELECT\",\n        value\n      });\n    },\n    setValue(value) {\n      send({\n        type: \"VALUE.SET\",\n        value\n      });\n    },\n    selectAll() {\n      send({\n        type: \"VALUE.SET\",\n        value: collection2.getValues()\n      });\n    },\n    highlightValue(value) {\n      send({\n        type: \"HIGHLIGHTED_VALUE.SET\",\n        value\n      });\n    },\n    clearValue(value) {\n      if (value) {\n        send({\n          type: \"ITEM.CLEAR\",\n          value\n        });\n      } else {\n        send({\n          type: \"VALUE.CLEAR\"\n        });\n      }\n    },\n    getItemState,\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        id: dom.getRootId(state.context),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly)\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        dir: state.context.dir,\n        id: dom.getLabelId(state.context),\n        ...parts.label.attrs,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly),\n        htmlFor: dom.getHiddenSelectId(state.context),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          dom.getTriggerEl(state.context)?.focus({\n            preventScroll: true\n          });\n        }\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        dir: state.context.dir,\n        id: dom.getControlId(state.context),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-focus\": dataAttr(focused),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid)\n      });\n    },\n    getValueTextProps() {\n      return normalize.element({\n        ...parts.valueText.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-focus\": dataAttr(focused)\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        id: dom.getTriggerId(state.context),\n        disabled,\n        dir: state.context.dir,\n        type: \"button\",\n        role: \"combobox\",\n        \"aria-controls\": dom.getContentId(state.context),\n        \"aria-expanded\": open,\n        \"aria-haspopup\": \"listbox\",\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-invalid\": invalid,\n        \"aria-labelledby\": dom.getLabelId(state.context),\n        ...parts.trigger.attrs,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly),\n        \"data-placement\": state.context.currentPlacement,\n        \"data-placeholder-shown\": dataAttr(!state.context.hasSelectedItems),\n        onClick(event) {\n          if (!interactive) return;\n          if (event.defaultPrevented) return;\n          send({\n            type: \"TRIGGER.CLICK\"\n          });\n        },\n        onFocus() {\n          send(\"TRIGGER.FOCUS\");\n        },\n        onBlur() {\n          send(\"TRIGGER.BLUR\");\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          const keyMap = {\n            ArrowUp() {\n              send({\n                type: \"TRIGGER.ARROW_UP\"\n              });\n            },\n            ArrowDown(event2) {\n              send({\n                type: event2.altKey ? \"OPEN\" : \"TRIGGER.ARROW_DOWN\"\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"TRIGGER.ARROW_LEFT\"\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"TRIGGER.ARROW_RIGHT\"\n              });\n            },\n            Home() {\n              send({\n                type: \"TRIGGER.HOME\"\n              });\n            },\n            End() {\n              send({\n                type: \"TRIGGER.END\"\n              });\n            },\n            Enter() {\n              send({\n                type: \"TRIGGER.ENTER\"\n              });\n            },\n            Space(event2) {\n              if (isTypingAhead) {\n                send({\n                  type: \"TRIGGER.TYPEAHEAD\",\n                  key: event2.key\n                });\n              } else {\n                send({\n                  type: \"TRIGGER.ENTER\"\n                });\n              }\n            }\n          };\n          const exec = keyMap[getEventKey(event, state.context)];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n            return;\n          }\n          if (getByTypeahead.isValidEvent(event)) {\n            send({\n              type: \"TRIGGER.TYPEAHEAD\",\n              key: event.key\n            });\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    getIndicatorProps() {\n      return normalize.element({\n        ...parts.indicator.attrs,\n        dir: state.context.dir,\n        \"aria-hidden\": true,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly)\n      });\n    },\n    getItemProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        id: dom.getItemId(state.context, itemState.value),\n        role: \"option\",\n        ...parts.item.attrs,\n        dir: state.context.dir,\n        \"data-value\": itemState.value,\n        \"aria-selected\": itemState.selected,\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"aria-disabled\": ariaAttr(itemState.disabled),\n        onPointerMove(event) {\n          if (itemState.disabled || event.pointerType !== \"mouse\") return;\n          if (itemState.value === state.context.highlightedValue) return;\n          send({\n            type: \"ITEM.POINTER_MOVE\",\n            value: itemState.value\n          });\n        },\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (itemState.disabled) return;\n          send({\n            type: \"ITEM.CLICK\",\n            src: \"pointerup\",\n            value: itemState.value\n          });\n        },\n        onPointerLeave(event) {\n          if (itemState.disabled) return;\n          if (props2.persistFocus) return;\n          if (event.pointerType !== \"mouse\") return;\n          const pointerMoved = state.previousEvent.type.includes(\"POINTER\");\n          if (!pointerMoved) return;\n          send({\n            type: \"ITEM.POINTER_LEAVE\"\n          });\n        }\n      });\n    },\n    getItemTextProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        ...parts.itemText.attrs,\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted)\n      });\n    },\n    getItemIndicatorProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        \"aria-hidden\": true,\n        ...parts.itemIndicator.attrs,\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        hidden: !itemState.selected\n      });\n    },\n    getItemGroupLabelProps(props2) {\n      const {\n        htmlFor\n      } = props2;\n      return normalize.element({\n        ...parts.itemGroupLabel.attrs,\n        id: dom.getItemGroupLabelId(state.context, htmlFor),\n        role: \"group\",\n        dir: state.context.dir\n      });\n    },\n    getItemGroupProps(props2) {\n      const {\n        id\n      } = props2;\n      return normalize.element({\n        ...parts.itemGroup.attrs,\n        \"data-disabled\": dataAttr(disabled),\n        id: dom.getItemGroupId(state.context, id),\n        \"aria-labelledby\": dom.getItemGroupLabelId(state.context, id),\n        dir: state.context.dir\n      });\n    },\n    getClearTriggerProps() {\n      return normalize.button({\n        ...parts.clearTrigger.attrs,\n        id: dom.getClearTriggerId(state.context),\n        type: \"button\",\n        \"aria-label\": \"Clear value\",\n        \"data-invalid\": dataAttr(invalid),\n        disabled,\n        hidden: !state.context.hasSelectedItems,\n        dir: state.context.dir,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send(\"CLEAR.CLICK\");\n        }\n      });\n    },\n    getHiddenSelectProps() {\n      return normalize.select({\n        name: state.context.name,\n        form: state.context.form,\n        disabled,\n        multiple: state.context.multiple,\n        required: state.context.required,\n        \"aria-hidden\": true,\n        id: dom.getHiddenSelectId(state.context),\n        defaultValue: state.context.multiple ? state.context.value : state.context.value[0],\n        style: visuallyHiddenStyle,\n        tabIndex: -1,\n        // Some browser extensions will focus the hidden select.\n        // Let's forward the focus to the trigger.\n        onFocus() {\n          dom.getTriggerEl(state.context)?.focus({\n            preventScroll: true\n          });\n        },\n        \"aria-labelledby\": dom.getLabelId(state.context)\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        ...parts.positioner.attrs,\n        dir: state.context.dir,\n        id: dom.getPositionerId(state.context),\n        style: popperStyles.floating\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        hidden: !open,\n        dir: state.context.dir,\n        id: dom.getContentId(state.context),\n        role: composite ? \"listbox\" : \"dialog\",\n        ...parts.content.attrs,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-placement\": state.context.currentPlacement,\n        \"data-activedescendant\": ariaActiveDescendant,\n        \"aria-activedescendant\": composite ? ariaActiveDescendant : void 0,\n        \"aria-multiselectable\": state.context.multiple && composite ? true : void 0,\n        \"aria-labelledby\": dom.getLabelId(state.context),\n        tabIndex: 0,\n        onKeyDown(event) {\n          if (!interactive) return;\n          if (!isSelfTarget(event)) return;\n          if (event.key === \"Tab\") {\n            const valid = isValidTabEvent(event);\n            if (!valid) {\n              event.preventDefault();\n              return;\n            }\n          }\n          const keyMap = {\n            ArrowUp() {\n              send({\n                type: \"CONTENT.ARROW_UP\"\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"CONTENT.ARROW_DOWN\"\n              });\n            },\n            Home() {\n              send({\n                type: \"CONTENT.HOME\"\n              });\n            },\n            End() {\n              send({\n                type: \"CONTENT.END\"\n              });\n            },\n            Enter() {\n              send({\n                type: \"ITEM.CLICK\",\n                src: \"keydown.enter\"\n              });\n            },\n            Space(event2) {\n              if (isTypingAhead) {\n                send({\n                  type: \"CONTENT.TYPEAHEAD\",\n                  key: event2.key\n                });\n              } else {\n                keyMap.Enter?.(event2);\n              }\n            }\n          };\n          const exec = keyMap[getEventKey(event)];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n            return;\n          }\n          const target = getEventTarget(event);\n          if (isEditableElement(target)) {\n            return;\n          }\n          if (getByTypeahead.isValidEvent(event)) {\n            send({\n              type: \"CONTENT.TYPEAHEAD\",\n              key: event.key\n            });\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    getListProps() {\n      return normalize.element({\n        ...parts.list.attrs,\n        tabIndex: 0,\n        role: !composite ? \"listbox\" : void 0,\n        \"aria-labelledby\": dom.getTriggerId(state.context),\n        \"aria-activedescendant\": !composite ? ariaActiveDescendant : void 0,\n        \"aria-multiselectable\": !composite && state.context.multiple ? true : void 0\n      });\n    }\n  };\n}\nvar {\n  and,\n  not,\n  or\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"select\",\n    context: {\n      value: [],\n      highlightedValue: null,\n      loopFocus: false,\n      closeOnSelect: !ctx.multiple,\n      disabled: false,\n      readOnly: false,\n      composite: true,\n      ...ctx,\n      highlightedItem: null,\n      selectedItems: [],\n      valueAsString: \"\",\n      collection: ctx.collection ?? collection.empty(),\n      typeahead: getByTypeahead.defaultOptions,\n      fieldsetDisabled: false,\n      positioning: {\n        placement: \"bottom-start\",\n        gutter: 8,\n        ...ctx.positioning\n      }\n    },\n    computed: {\n      hasSelectedItems: ctx2 => ctx2.value.length > 0,\n      isTypingAhead: ctx2 => ctx2.typeahead.keysSoFar !== \"\",\n      isDisabled: ctx2 => !!ctx2.disabled || ctx2.fieldsetDisabled,\n      isInteractive: ctx2 => !(ctx2.isDisabled || ctx2.readOnly)\n    },\n    initial: ctx.open ? \"open\" : \"idle\",\n    created: [\"syncCollection\"],\n    entry: [\"syncSelectElement\"],\n    watch: {\n      open: [\"toggleVisibility\"],\n      value: [\"syncSelectedItems\", \"syncSelectElement\"],\n      highlightedValue: [\"syncHighlightedItem\"],\n      collection: [\"syncCollection\"]\n    },\n    on: {\n      \"HIGHLIGHTED_VALUE.SET\": {\n        actions: [\"setHighlightedItem\"]\n      },\n      \"ITEM.SELECT\": {\n        actions: [\"selectItem\"]\n      },\n      \"ITEM.CLEAR\": {\n        actions: [\"clearItem\"]\n      },\n      \"VALUE.SET\": {\n        actions: [\"setSelectedItems\"]\n      },\n      \"VALUE.CLEAR\": {\n        actions: [\"clearSelectedItems\"]\n      },\n      \"CLEAR.CLICK\": {\n        actions: [\"clearSelectedItems\", \"focusTriggerEl\"]\n      },\n      \"COLLECTION.SET\": {\n        actions: [\"setCollection\"]\n      }\n    },\n    activities: [\"trackFormControlState\"],\n    states: {\n      idle: {\n        tags: [\"closed\"],\n        on: {\n          \"CONTROLLED.OPEN\": [{\n            guard: \"isTriggerClickEvent\",\n            target: \"open\",\n            actions: [\"setInitialFocus\", \"highlightFirstSelectedItem\"]\n          }, {\n            target: \"open\",\n            actions: [\"setInitialFocus\"]\n          }],\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\", \"setInitialFocus\", \"highlightFirstSelectedItem\"]\n          }],\n          \"TRIGGER.FOCUS\": {\n            target: \"focused\"\n          },\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"setInitialFocus\", \"invokeOnOpen\"]\n          }]\n        }\n      },\n      focused: {\n        tags: [\"closed\"],\n        on: {\n          \"CONTROLLED.OPEN\": [{\n            guard: \"isTriggerClickEvent\",\n            target: \"open\",\n            actions: [\"setInitialFocus\", \"highlightFirstSelectedItem\"]\n          }, {\n            guard: \"isTriggerArrowUpEvent\",\n            target: \"open\",\n            actions: [\"setInitialFocus\", \"highlightComputedLastItem\"]\n          }, {\n            guard: or(\"isTriggerArrowDownEvent\", \"isTriggerEnterEvent\"),\n            target: \"open\",\n            actions: [\"setInitialFocus\", \"highlightComputedFirstItem\"]\n          }, {\n            target: \"open\",\n            actions: [\"setInitialFocus\"]\n          }],\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"setInitialFocus\", \"invokeOnOpen\"]\n          }],\n          \"TRIGGER.BLUR\": {\n            target: \"idle\"\n          },\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"setInitialFocus\", \"invokeOnOpen\", \"highlightFirstSelectedItem\"]\n          }],\n          \"TRIGGER.ENTER\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"setInitialFocus\", \"invokeOnOpen\", \"highlightComputedFirstItem\"]\n          }],\n          \"TRIGGER.ARROW_UP\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"setInitialFocus\", \"invokeOnOpen\", \"highlightComputedLastItem\"]\n          }],\n          \"TRIGGER.ARROW_DOWN\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"setInitialFocus\", \"invokeOnOpen\", \"highlightComputedFirstItem\"]\n          }],\n          \"TRIGGER.ARROW_LEFT\": [{\n            guard: and(not(\"multiple\"), \"hasSelectedItems\"),\n            actions: [\"selectPreviousItem\"]\n          }, {\n            guard: not(\"multiple\"),\n            actions: [\"selectLastItem\"]\n          }],\n          \"TRIGGER.ARROW_RIGHT\": [{\n            guard: and(not(\"multiple\"), \"hasSelectedItems\"),\n            actions: [\"selectNextItem\"]\n          }, {\n            guard: not(\"multiple\"),\n            actions: [\"selectFirstItem\"]\n          }],\n          \"TRIGGER.HOME\": {\n            guard: not(\"multiple\"),\n            actions: [\"selectFirstItem\"]\n          },\n          \"TRIGGER.END\": {\n            guard: not(\"multiple\"),\n            actions: [\"selectLastItem\"]\n          },\n          \"TRIGGER.TYPEAHEAD\": {\n            guard: not(\"multiple\"),\n            actions: [\"selectMatchingItem\"]\n          }\n        }\n      },\n      open: {\n        tags: [\"open\"],\n        exit: [\"scrollContentToTop\"],\n        activities: [\"trackDismissableElement\", \"computePlacement\", \"scrollToHighlightedItem\"],\n        on: {\n          \"CONTROLLED.CLOSE\": {\n            target: \"focused\",\n            actions: [\"focusTriggerEl\", \"clearHighlightedItem\"]\n          },\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"focused\",\n            actions: [\"invokeOnClose\", \"focusTriggerEl\", \"clearHighlightedItem\"]\n          }],\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"focused\",\n            actions: [\"invokeOnClose\", \"clearHighlightedItem\"]\n          }],\n          \"ITEM.CLICK\": [{\n            guard: and(\"closeOnSelect\", \"isOpenControlled\"),\n            actions: [\"selectHighlightedItem\", \"invokeOnClose\"]\n          }, {\n            guard: \"closeOnSelect\",\n            target: \"focused\",\n            actions: [\"selectHighlightedItem\", \"invokeOnClose\", \"focusTriggerEl\", \"clearHighlightedItem\"]\n          }, {\n            actions: [\"selectHighlightedItem\"]\n          }],\n          \"CONTENT.HOME\": {\n            actions: [\"highlightFirstItem\"]\n          },\n          \"CONTENT.END\": {\n            actions: [\"highlightLastItem\"]\n          },\n          \"CONTENT.ARROW_DOWN\": [{\n            guard: and(\"hasHighlightedItem\", \"loop\", \"isLastItemHighlighted\"),\n            actions: [\"highlightFirstItem\"]\n          }, {\n            guard: \"hasHighlightedItem\",\n            actions: [\"highlightNextItem\"]\n          }, {\n            actions: [\"highlightFirstItem\"]\n          }],\n          \"CONTENT.ARROW_UP\": [{\n            guard: and(\"hasHighlightedItem\", \"loop\", \"isFirstItemHighlighted\"),\n            actions: [\"highlightLastItem\"]\n          }, {\n            guard: \"hasHighlightedItem\",\n            actions: [\"highlightPreviousItem\"]\n          }, {\n            actions: [\"highlightLastItem\"]\n          }],\n          \"CONTENT.TYPEAHEAD\": {\n            actions: [\"highlightMatchingItem\"]\n          },\n          \"ITEM.POINTER_MOVE\": {\n            actions: [\"highlightItem\"]\n          },\n          \"ITEM.POINTER_LEAVE\": {\n            actions: [\"clearHighlightedItem\"]\n          },\n          \"POSITIONING.SET\": {\n            actions: [\"reposition\"]\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      loop: ctx2 => !!ctx2.loopFocus,\n      multiple: ctx2 => !!ctx2.multiple,\n      hasSelectedItems: ctx2 => !!ctx2.hasSelectedItems,\n      hasHighlightedItem: ctx2 => ctx2.highlightedValue != null,\n      isFirstItemHighlighted: ctx2 => ctx2.highlightedValue === ctx2.collection.firstValue,\n      isLastItemHighlighted: ctx2 => ctx2.highlightedValue === ctx2.collection.lastValue,\n      closeOnSelect: (ctx2, evt) => !!(evt.closeOnSelect ?? ctx2.closeOnSelect),\n      // guard assertions (for controlled mode)\n      isOpenControlled: ctx2 => !!ctx2[\"open.controlled\"],\n      isTriggerClickEvent: (_ctx, evt) => evt.previousEvent?.type === \"TRIGGER.CLICK\",\n      isTriggerEnterEvent: (_ctx, evt) => evt.previousEvent?.type === \"TRIGGER.ENTER\",\n      isTriggerArrowUpEvent: (_ctx, evt) => evt.previousEvent?.type === \"TRIGGER.ARROW_UP\",\n      isTriggerArrowDownEvent: (_ctx, evt) => evt.previousEvent?.type === \"TRIGGER.ARROW_DOWN\"\n    },\n    activities: {\n      trackFormControlState(ctx2, _evt, {\n        initialContext\n      }) {\n        return trackFormControl(dom.getHiddenSelectEl(ctx2), {\n          onFieldsetDisabledChange(disabled) {\n            ctx2.fieldsetDisabled = disabled;\n          },\n          onFormReset() {\n            set.selectedItems(ctx2, initialContext.value);\n          }\n        });\n      },\n      trackDismissableElement(ctx2, _evt, {\n        send\n      }) {\n        const contentEl = () => dom.getContentEl(ctx2);\n        let restoreFocus = true;\n        return trackDismissableElement(contentEl, {\n          defer: true,\n          exclude: [dom.getTriggerEl(ctx2), dom.getClearTriggerEl(ctx2)],\n          onFocusOutside: ctx2.onFocusOutside,\n          onPointerDownOutside: ctx2.onPointerDownOutside,\n          onInteractOutside(event) {\n            ctx2.onInteractOutside?.(event);\n            restoreFocus = !(event.detail.focusable || event.detail.contextmenu);\n          },\n          onDismiss() {\n            send({\n              type: \"CLOSE\",\n              src: \"interact-outside\",\n              restoreFocus\n            });\n          }\n        });\n      },\n      computePlacement(ctx2) {\n        ctx2.currentPlacement = ctx2.positioning.placement;\n        const triggerEl = () => dom.getTriggerEl(ctx2);\n        const positionerEl = () => dom.getPositionerEl(ctx2);\n        return getPlacement(triggerEl, positionerEl, {\n          defer: true,\n          ...ctx2.positioning,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      scrollToHighlightedItem(ctx2, _evt, {\n        getState\n      }) {\n        const exec = immediate => {\n          if (ctx2.highlightedValue == null) return;\n          const state = getState();\n          if (state.event.type.includes(\"POINTER\")) return;\n          const optionEl = dom.getHighlightedOptionEl(ctx2);\n          const contentEl2 = dom.getContentEl(ctx2);\n          if (ctx2.scrollToIndexFn) {\n            const highlightedIndex = ctx2.collection.indexOf(ctx2.highlightedValue);\n            ctx2.scrollToIndexFn({\n              index: highlightedIndex,\n              immediate\n            });\n            return;\n          }\n          scrollIntoView(optionEl, {\n            rootEl: contentEl2,\n            block: \"nearest\"\n          });\n        };\n        raf(() => exec(true));\n        const contentEl = () => dom.getContentEl(ctx2);\n        return observeAttributes(contentEl, {\n          defer: true,\n          attributes: [\"data-activedescendant\"],\n          callback() {\n            exec(false);\n          }\n        });\n      }\n    },\n    actions: {\n      reposition(ctx2, evt) {\n        const positionerEl = () => dom.getPositionerEl(ctx2);\n        getPlacement(dom.getTriggerEl(ctx2), positionerEl, {\n          ...ctx2.positioning,\n          ...evt.options,\n          defer: true,\n          listeners: false,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      toggleVisibility(ctx2, evt, {\n        send\n      }) {\n        send({\n          type: ctx2.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: evt\n        });\n      },\n      highlightPreviousItem(ctx2) {\n        if (ctx2.highlightedValue == null) return;\n        const value = ctx2.collection.getPreviousValue(ctx2.highlightedValue);\n        set.highlightedItem(ctx2, value);\n      },\n      highlightNextItem(ctx2) {\n        if (ctx2.highlightedValue == null) return;\n        const value = ctx2.collection.getNextValue(ctx2.highlightedValue);\n        set.highlightedItem(ctx2, value);\n      },\n      highlightFirstItem(ctx2) {\n        const value = ctx2.collection.firstValue;\n        set.highlightedItem(ctx2, value);\n      },\n      highlightLastItem(ctx2) {\n        const value = ctx2.collection.lastValue;\n        set.highlightedItem(ctx2, value);\n      },\n      setInitialFocus(ctx2) {\n        raf(() => {\n          const element = getInitialFocus({\n            root: dom.getContentEl(ctx2)\n          });\n          element?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      focusTriggerEl(ctx2, evt) {\n        const restoreFocus = evt.restoreFocus ?? evt.previousEvent?.restoreFocus;\n        if (restoreFocus != null && !restoreFocus) return;\n        raf(() => {\n          const element = dom.getTriggerEl(ctx2);\n          element?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      selectHighlightedItem(ctx2, evt) {\n        let value = evt.value ?? ctx2.highlightedValue;\n        if (value == null) return;\n        const nullable = ctx2.deselectable && !ctx2.multiple && ctx2.value.includes(value);\n        value = nullable ? null : value;\n        set.selectedItem(ctx2, value, nullable);\n      },\n      highlightComputedFirstItem(ctx2) {\n        const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.firstValue;\n        set.highlightedItem(ctx2, value);\n      },\n      highlightComputedLastItem(ctx2) {\n        const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.lastValue;\n        set.highlightedItem(ctx2, value);\n      },\n      highlightFirstSelectedItem(ctx2) {\n        if (!ctx2.hasSelectedItems) return;\n        const [value] = ctx2.collection.sort(ctx2.value);\n        set.highlightedItem(ctx2, value);\n      },\n      highlightItem(ctx2, evt) {\n        set.highlightedItem(ctx2, evt.value);\n      },\n      highlightMatchingItem(ctx2, evt) {\n        const value = ctx2.collection.search(evt.key, {\n          state: ctx2.typeahead,\n          currentValue: ctx2.highlightedValue\n        });\n        if (value == null) return;\n        set.highlightedItem(ctx2, value);\n      },\n      setHighlightedItem(ctx2, evt) {\n        set.highlightedItem(ctx2, evt.value);\n      },\n      clearHighlightedItem(ctx2) {\n        set.highlightedItem(ctx2, null, true);\n      },\n      selectItem(ctx2, evt) {\n        const nullable = ctx2.deselectable && !ctx2.multiple && ctx2.value.includes(evt.value);\n        const value = nullable ? null : evt.value;\n        set.selectedItem(ctx2, value, nullable);\n      },\n      clearItem(ctx2, evt) {\n        const value = ctx2.value.filter(v => v !== evt.value);\n        set.selectedItems(ctx2, value);\n      },\n      setSelectedItems(ctx2, evt) {\n        set.selectedItems(ctx2, evt.value);\n      },\n      clearSelectedItems(ctx2) {\n        set.selectedItems(ctx2, []);\n      },\n      selectPreviousItem(ctx2) {\n        const value = ctx2.collection.getPreviousValue(ctx2.value[0]);\n        set.selectedItem(ctx2, value);\n      },\n      selectNextItem(ctx2) {\n        const value = ctx2.collection.getNextValue(ctx2.value[0]);\n        set.selectedItem(ctx2, value);\n      },\n      selectFirstItem(ctx2) {\n        const value = ctx2.collection.firstValue;\n        set.selectedItem(ctx2, value);\n      },\n      selectLastItem(ctx2) {\n        const value = ctx2.collection.lastValue;\n        set.selectedItem(ctx2, value);\n      },\n      selectMatchingItem(ctx2, evt) {\n        const value = ctx2.collection.search(evt.key, {\n          state: ctx2.typeahead,\n          currentValue: ctx2.value[0]\n        });\n        if (value == null) return;\n        set.selectedItem(ctx2, value);\n      },\n      scrollContentToTop(ctx2) {\n        if (ctx2.scrollToIndexFn) {\n          ctx2.scrollToIndexFn({\n            index: 0,\n            immediate: true\n          });\n        } else {\n          dom.getContentEl(ctx2)?.scrollTo(0, 0);\n        }\n      },\n      invokeOnOpen(ctx2) {\n        ctx2.onOpenChange?.({\n          open: true\n        });\n      },\n      invokeOnClose(ctx2) {\n        ctx2.onOpenChange?.({\n          open: false\n        });\n      },\n      syncSelectElement(ctx2) {\n        const selectEl = dom.getHiddenSelectEl(ctx2);\n        if (!selectEl) return;\n        if (ctx2.value.length === 0 && !ctx2.multiple) {\n          selectEl.selectedIndex = -1;\n          return;\n        }\n        for (const option of selectEl.options) {\n          option.selected = ctx2.value.includes(option.value);\n        }\n      },\n      setCollection(ctx2, evt) {\n        ctx2.collection = evt.value;\n      },\n      syncCollection(ctx2) {\n        const selectedItems = ctx2.collection.findMany(ctx2.value);\n        const valueAsString = ctx2.collection.stringifyItems(selectedItems);\n        ctx2.highlightedItem = ctx2.collection.find(ctx2.highlightedValue);\n        ctx2.selectedItems = selectedItems;\n        ctx2.valueAsString = valueAsString;\n      },\n      syncSelectedItems(ctx2) {\n        sync.valueChange(ctx2);\n      },\n      syncHighlightedItem(ctx2) {\n        sync.highlightChange(ctx2);\n      }\n    }\n  });\n}\nfunction dispatchChangeEvent(ctx) {\n  raf(() => {\n    const node = dom.getHiddenSelectEl(ctx);\n    if (!node) return;\n    const win = dom.getWin(ctx);\n    const changeEvent = new win.Event(\"change\", {\n      bubbles: true,\n      composed: true\n    });\n    node.dispatchEvent(changeEvent);\n  });\n}\nvar sync = {\n  valueChange: ctx => {\n    const prevSelectedItems = ctx.selectedItems;\n    ctx.selectedItems = ctx.value.map(value => {\n      const foundItem = prevSelectedItems.find(item => ctx.collection.getItemValue(item) === value);\n      if (foundItem) return foundItem;\n      return ctx.collection.find(value);\n    });\n    ctx.valueAsString = ctx.collection.stringifyItems(ctx.selectedItems);\n  },\n  highlightChange: ctx => {\n    ctx.highlightedItem = ctx.collection.find(ctx.highlightedValue);\n  }\n};\nvar invoke = {\n  valueChange: ctx => {\n    sync.valueChange(ctx);\n    ctx.onValueChange?.({\n      value: Array.from(ctx.value),\n      items: Array.from(ctx.selectedItems)\n    });\n    dispatchChangeEvent(ctx);\n  },\n  highlightChange: ctx => {\n    sync.highlightChange(ctx);\n    ctx.onHighlightChange?.({\n      highlightedValue: ctx.highlightedValue,\n      highlightedItem: ctx.highlightedItem,\n      highlightedIndex: ctx.collection.indexOf(ctx.highlightedValue)\n    });\n  }\n};\nvar set = {\n  selectedItem: (ctx, value, force = false) => {\n    if (isEqual(ctx.value, value)) return;\n    if (value == null && !force) return;\n    if (value == null && force) {\n      ctx.value = [];\n      invoke.valueChange(ctx);\n      return;\n    }\n    ctx.value = ctx.multiple ? addOrRemove(ctx.value, value) : [value];\n    invoke.valueChange(ctx);\n  },\n  selectedItems: (ctx, value) => {\n    if (isEqual(ctx.value, value)) return;\n    ctx.value = value;\n    invoke.valueChange(ctx);\n  },\n  highlightedItem: (ctx, value, force = false) => {\n    if (isEqual(ctx.highlightedValue, value)) return;\n    if (value == null && !force) return;\n    ctx.highlightedValue = value ?? null;\n    invoke.highlightChange(ctx);\n  }\n};\nvar props = createProps()([\"closeOnSelect\", \"collection\", \"dir\", \"disabled\", \"deselectable\", \"form\", \"getRootNode\", \"highlightedValue\", \"id\", \"ids\", \"invalid\", \"loopFocus\", \"multiple\", \"name\", \"onFocusOutside\", \"onHighlightChange\", \"onInteractOutside\", \"onOpenChange\", \"onPointerDownOutside\", \"onValueChange\", \"open.controlled\", \"open\", \"composite\", \"positioning\", \"required\", \"readOnly\", \"scrollToIndexFn\", \"value\"]);\nvar splitProps = createSplitProps(props);\nvar itemProps = createProps()([\"item\", \"persistFocus\"]);\nvar splitItemProps = createSplitProps(itemProps);\nvar itemGroupProps = createProps()([\"id\"]);\nvar splitItemGroupProps = createSplitProps(itemGroupProps);\nvar itemGroupLabelProps = createProps()([\"htmlFor\"]);\nvar splitItemGroupLabelProps = createSplitProps(itemGroupLabelProps);\nexport { anatomy, collection, connect, itemGroupLabelProps, itemGroupProps, itemProps, machine, props, splitItemGroupLabelProps, splitItemGroupProps, splitItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
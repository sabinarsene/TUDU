{"ast":null,"code":"import { createMachine, ref } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/presence.connect.ts\nfunction connect(state, send, _normalize) {\n  const present = state.matches(\"mounted\", \"unmountSuspended\");\n  return {\n    skip: !state.context.initial && present,\n    present,\n    setNode(node) {\n      if (!node) return;\n      send({\n        type: \"NODE.SET\",\n        node\n      });\n    },\n    unmount() {\n      send({\n        type: \"UNMOUNT\"\n      });\n    }\n  };\n}\nfunction machine(ctx) {\n  return createMachine({\n    initial: ctx.present ? \"mounted\" : \"unmounted\",\n    context: {\n      node: null,\n      styles: null,\n      unmountAnimationName: null,\n      prevAnimationName: null,\n      present: false,\n      initial: false,\n      ...ctx\n    },\n    exit: [\"clearInitial\", \"cleanupNode\"],\n    watch: {\n      present: [\"setInitial\", \"syncPresence\"]\n    },\n    on: {\n      \"NODE.SET\": {\n        actions: [\"setNode\", \"setStyles\"]\n      }\n    },\n    states: {\n      mounted: {\n        on: {\n          UNMOUNT: {\n            target: \"unmounted\",\n            actions: [\"invokeOnExitComplete\"]\n          },\n          \"UNMOUNT.SUSPEND\": \"unmountSuspended\"\n        }\n      },\n      unmountSuspended: {\n        activities: [\"trackAnimationEvents\"],\n        after: {\n          // Fallback to timeout to ensure we exit this state even if the `animationend` event\n          // did not get trigger\n          ANIMATION_DURATION: {\n            target: \"unmounted\",\n            actions: [\"invokeOnExitComplete\"]\n          }\n        },\n        on: {\n          MOUNT: {\n            target: \"mounted\",\n            actions: [\"setPrevAnimationName\"]\n          },\n          UNMOUNT: {\n            target: \"unmounted\",\n            actions: [\"invokeOnExitComplete\"]\n          }\n        }\n      },\n      unmounted: {\n        entry: [\"clearPrevAnimationName\"],\n        on: {\n          MOUNT: {\n            target: \"mounted\",\n            actions: [\"setPrevAnimationName\"]\n          }\n        }\n      }\n    }\n  }, {\n    delays: {\n      ANIMATION_DURATION(ctx2) {\n        return parseMs(ctx2.styles?.animationDuration) + parseMs(ctx2.styles?.animationDelay) + ANIMATION_TIMEOUT_MARGIN;\n      }\n    },\n    actions: {\n      setInitial(ctx2) {\n        ctx2.initial = true;\n      },\n      clearInitial(ctx2) {\n        ctx2.initial = false;\n      },\n      cleanupNode(ctx2) {\n        ctx2.node = null;\n        ctx2.styles = null;\n      },\n      invokeOnExitComplete(ctx2) {\n        ctx2.onExitComplete?.();\n      },\n      setNode(ctx2, evt) {\n        ctx2.node = ref(evt.node);\n      },\n      setStyles(ctx2, evt) {\n        const win = evt.node.ownerDocument.defaultView || window;\n        ctx2.styles = ref(win.getComputedStyle(evt.node));\n      },\n      syncPresence(ctx2, _evt, {\n        send\n      }) {\n        if (ctx2.present) {\n          send({\n            type: \"MOUNT\",\n            src: \"presence.changed\"\n          });\n          return;\n        }\n        if (!ctx2.present && ctx2.node?.ownerDocument.visibilityState === \"hidden\") {\n          send({\n            type: \"UNMOUNT\",\n            src: \"visibilitychange\"\n          });\n          return;\n        }\n        const animationName = getAnimationName(ctx2.styles);\n        const exec = ctx2.immediate ? queueMicrotask : requestAnimationFrame;\n        exec(() => {\n          ctx2.unmountAnimationName = animationName;\n          if (animationName === \"none\" || animationName === ctx2.prevAnimationName || ctx2.styles?.display === \"none\" || ctx2.styles?.animationDuration === \"0s\") {\n            send({\n              type: \"UNMOUNT\",\n              src: \"presence.changed\"\n            });\n          } else {\n            send({\n              type: \"UNMOUNT.SUSPEND\"\n            });\n          }\n        });\n      },\n      setPrevAnimationName(ctx2) {\n        const exec = ctx2.immediate ? queueMicrotask : requestAnimationFrame;\n        exec(() => {\n          ctx2.prevAnimationName = getAnimationName(ctx2.styles);\n        });\n      },\n      clearPrevAnimationName(ctx2) {\n        ctx2.prevAnimationName = null;\n      }\n    },\n    activities: {\n      trackAnimationEvents(ctx2, _evt, {\n        send\n      }) {\n        const node = ctx2.node;\n        if (!node) return;\n        const onStart = event => {\n          const target = event.composedPath?.()?.[0] ?? event.target;\n          if (target === node) {\n            ctx2.prevAnimationName = getAnimationName(ctx2.styles);\n          }\n        };\n        const onEnd = event => {\n          const animationName = getAnimationName(ctx2.styles);\n          const target = event.composedPath?.()?.[0] ?? event.target;\n          if (target === node && animationName === ctx2.unmountAnimationName) {\n            send({\n              type: \"UNMOUNT\",\n              src: \"animationend\"\n            });\n          }\n        };\n        node.addEventListener(\"animationstart\", onStart);\n        node.addEventListener(\"animationcancel\", onEnd);\n        node.addEventListener(\"animationend\", onEnd);\n        return () => {\n          node.removeEventListener(\"animationstart\", onStart);\n          node.removeEventListener(\"animationcancel\", onEnd);\n          node.removeEventListener(\"animationend\", onEnd);\n        };\n      }\n    }\n  });\n}\nfunction getAnimationName(styles) {\n  return styles?.animationName || \"none\";\n}\nfunction parseMs(value) {\n  return parseFloat(value || \"0\") * 1e3;\n}\nvar ANIMATION_TIMEOUT_MARGIN = 16.667;\nvar props = createProps()([\"onExitComplete\", \"present\", \"immediate\"]);\nexport { connect, machine, props };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
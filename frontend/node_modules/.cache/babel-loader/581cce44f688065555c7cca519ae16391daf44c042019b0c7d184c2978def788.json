{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, queryAll, getTabbables, dataAttr, getEventTarget, isFocusable, ariaAttr, getEventKey, addDomEvent, trackPointerMove, raf } from '@zag-js/dom-query';\nimport { createMachine, ref } from '@zag-js/core';\nimport { findSnapPoint, getScrollSnapPositions } from '@zag-js/scroll-snap';\nimport { createSplitProps, compact, isObject, add, remove, uniq, nextIndex, prevIndex, isEqual } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/carousel.anatomy.ts\nvar anatomy = createAnatomy(\"carousel\").parts(\"root\", \"itemGroup\", \"item\", \"control\", \"nextTrigger\", \"prevTrigger\", \"indicatorGroup\", \"indicator\", \"autoplayTrigger\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `carousel:${ctx.id}`,\n  getItemId: (ctx, index) => ctx.ids?.item?.(index) ?? `carousel:${ctx.id}:item:${index}`,\n  getItemGroupId: ctx => ctx.ids?.itemGroup ?? `carousel:${ctx.id}:item-group`,\n  getNextTriggerId: ctx => ctx.ids?.nextTrigger ?? `carousel:${ctx.id}:next-trigger`,\n  getPrevTriggerId: ctx => ctx.ids?.prevTrigger ?? `carousel:${ctx.id}:prev-trigger`,\n  getIndicatorGroupId: ctx => ctx.ids?.indicatorGroup ?? `carousel:${ctx.id}:indicator-group`,\n  getIndicatorId: (ctx, index) => ctx.ids?.indicator?.(index) ?? `carousel:${ctx.id}:indicator:${index}`,\n  getRootEl: ctx => dom.getById(ctx, dom.getRootId(ctx)),\n  getItemGroupEl: ctx => dom.getById(ctx, dom.getItemGroupId(ctx)),\n  getItemEl: (ctx, index) => dom.getById(ctx, dom.getItemId(ctx, index)),\n  getItemEls: ctx => queryAll(dom.getItemGroupEl(ctx), `[data-part=item]`),\n  getActiveIndicatorEl: ctx => dom.getById(ctx, dom.getIndicatorId(ctx, ctx.page)),\n  syncTabIndex(ctx) {\n    const el = dom.getItemGroupEl(ctx);\n    if (!el) return;\n    const tabbables = getTabbables(el);\n    if (tabbables.length > 0) {\n      el.removeAttribute(\"tabindex\");\n    } else {\n      el.setAttribute(\"tabindex\", \"0\");\n    }\n  }\n});\n\n// src/carousel.connect.ts\nfunction connect(state, send, normalize) {\n  const isPlaying = state.matches(\"autoplay\");\n  const isDragging = state.matches(\"dragging\");\n  const canScrollNext = state.context.canScrollNext;\n  const canScrollPrev = state.context.canScrollPrev;\n  const horizontal = state.context.isHorizontal;\n  const pageSnapPoints = Array.from(state.context.pageSnapPoints);\n  const page = state.context.page;\n  const slidesPerPage = state.context.slidesPerPage;\n  const padding = state.context.padding;\n  const translations = state.context.translations;\n  return {\n    isPlaying,\n    isDragging,\n    page,\n    pageSnapPoints,\n    canScrollNext,\n    canScrollPrev,\n    getProgress() {\n      return page / pageSnapPoints.length;\n    },\n    scrollToIndex(index, instant) {\n      send({\n        type: \"INDEX.SET\",\n        index,\n        instant\n      });\n    },\n    scrollTo(index, instant) {\n      send({\n        type: \"PAGE.SET\",\n        index,\n        instant\n      });\n    },\n    scrollNext(instant) {\n      send({\n        type: \"PAGE.NEXT\",\n        instant\n      });\n    },\n    scrollPrev(instant) {\n      send({\n        type: \"PAGE.PREV\",\n        instant\n      });\n    },\n    play() {\n      send(\"AUTOPLAY.START\");\n    },\n    pause() {\n      send(\"AUTOPLAY.PAUSE\");\n    },\n    isInView(index) {\n      return Array.from(state.context.slidesInView).includes(index);\n    },\n    refresh() {\n      send({\n        type: \"SNAP.REFRESH\"\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: dom.getRootId(state.context),\n        role: \"region\",\n        \"aria-roledescription\": \"carousel\",\n        \"data-orientation\": state.context.orientation,\n        dir: state.context.dir,\n        style: {\n          \"--slides-per-page\": slidesPerPage,\n          \"--slide-spacing\": state.context.spacing,\n          \"--slide-item-size\": \"calc(100% / var(--slides-per-page) - var(--slide-spacing) * (var(--slides-per-page) - 1) / var(--slides-per-page))\"\n        }\n      });\n    },\n    getItemGroupProps() {\n      return normalize.element({\n        ...parts.itemGroup.attrs,\n        id: dom.getItemGroupId(state.context),\n        \"data-orientation\": state.context.orientation,\n        \"data-dragging\": dataAttr(isDragging),\n        dir: state.context.dir,\n        \"aria-live\": isPlaying ? \"off\" : \"polite\",\n        onMouseDown(event) {\n          if (!state.context.allowMouseDrag) return;\n          if (event.button !== 0) return;\n          if (event.defaultPrevented) return;\n          const target = getEventTarget(event);\n          if (isFocusable(target) && target !== event.currentTarget) return;\n          event.preventDefault();\n          send({\n            type: \"DRAGGING.START\"\n          });\n        },\n        style: {\n          display: \"grid\",\n          gap: \"var(--slide-spacing)\",\n          scrollSnapType: [horizontal ? \"x\" : \"y\", state.context.snapType].join(\" \"),\n          gridAutoFlow: horizontal ? \"column\" : \"row\",\n          scrollbarWidth: \"none\",\n          overscrollBehavior: \"contain\",\n          [horizontal ? \"gridAutoColumns\" : \"gridAutoRows\"]: \"var(--slide-item-size)\",\n          [horizontal ? \"scrollPaddingInline\" : \"scrollPaddingBlock\"]: padding,\n          [horizontal ? \"paddingInline\" : \"paddingBlock\"]: padding,\n          [horizontal ? \"overflowX\" : \"overflowY\"]: \"auto\"\n        }\n      });\n    },\n    getItemProps(props2) {\n      const isInView = state.context.slidesInView.includes(props2.index);\n      return normalize.element({\n        ...parts.item.attrs,\n        id: dom.getItemId(state.context, props2.index),\n        dir: state.context.dir,\n        role: \"group\",\n        \"data-index\": props2.index,\n        \"data-inview\": dataAttr(isInView),\n        \"aria-roledescription\": \"slide\",\n        \"data-orientation\": state.context.orientation,\n        \"aria-label\": state.context.slideCount ? translations.item(props2.index, state.context.slideCount) : void 0,\n        \"aria-hidden\": ariaAttr(!isInView),\n        style: {\n          scrollSnapAlign: getSnapAlign(state.context, props2)\n        }\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        \"data-orientation\": state.context.orientation\n      });\n    },\n    getPrevTriggerProps() {\n      return normalize.button({\n        ...parts.prevTrigger.attrs,\n        id: dom.getPrevTriggerId(state.context),\n        type: \"button\",\n        disabled: !canScrollPrev,\n        dir: state.context.dir,\n        \"aria-label\": translations.prevTrigger,\n        \"data-orientation\": state.context.orientation,\n        \"aria-controls\": dom.getItemGroupId(state.context),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"PAGE.PREV\",\n            src: \"trigger\"\n          });\n        }\n      });\n    },\n    getNextTriggerProps() {\n      return normalize.button({\n        ...parts.nextTrigger.attrs,\n        dir: state.context.dir,\n        id: dom.getNextTriggerId(state.context),\n        type: \"button\",\n        \"aria-label\": translations.nextTrigger,\n        \"data-orientation\": state.context.orientation,\n        \"aria-controls\": dom.getItemGroupId(state.context),\n        disabled: !canScrollNext,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"PAGE.NEXT\",\n            src: \"trigger\"\n          });\n        }\n      });\n    },\n    getIndicatorGroupProps() {\n      return normalize.element({\n        ...parts.indicatorGroup.attrs,\n        dir: state.context.dir,\n        id: dom.getIndicatorGroupId(state.context),\n        \"data-orientation\": state.context.orientation,\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          const src = \"indicator\";\n          const keyMap = {\n            ArrowDown(event2) {\n              if (horizontal) return;\n              send({\n                type: \"PAGE.NEXT\",\n                src\n              });\n              event2.preventDefault();\n            },\n            ArrowUp(event2) {\n              if (horizontal) return;\n              send({\n                type: \"PAGE.PREV\",\n                src\n              });\n              event2.preventDefault();\n            },\n            ArrowRight(event2) {\n              if (!horizontal) return;\n              send({\n                type: \"PAGE.NEXT\",\n                src\n              });\n              event2.preventDefault();\n            },\n            ArrowLeft(event2) {\n              if (!horizontal) return;\n              send({\n                type: \"PAGE.PREV\",\n                src\n              });\n              event2.preventDefault();\n            },\n            Home(event2) {\n              send({\n                type: \"PAGE.SET\",\n                index: 0,\n                src\n              });\n              event2.preventDefault();\n            },\n            End(event2) {\n              send({\n                type: \"PAGE.SET\",\n                index: pageSnapPoints.length - 1,\n                src\n              });\n              event2.preventDefault();\n            }\n          };\n          const key = getEventKey(event, {\n            dir: state.context.dir,\n            orientation: state.context.orientation\n          });\n          const exec = keyMap[key];\n          exec?.(event);\n        }\n      });\n    },\n    getIndicatorProps(props2) {\n      return normalize.button({\n        ...parts.indicator.attrs,\n        dir: state.context.dir,\n        id: dom.getIndicatorId(state.context, props2.index),\n        type: \"button\",\n        \"data-orientation\": state.context.orientation,\n        \"data-index\": props2.index,\n        \"data-readonly\": dataAttr(props2.readOnly),\n        \"data-current\": dataAttr(props2.index === state.context.page),\n        \"aria-label\": translations.indicator(props2.index),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (props2.readOnly) return;\n          send({\n            type: \"PAGE.SET\",\n            index: props2.index,\n            src: \"indicator\"\n          });\n        }\n      });\n    },\n    getAutoplayTriggerProps() {\n      return normalize.button({\n        ...parts.autoplayTrigger.attrs,\n        type: \"button\",\n        \"data-orientation\": state.context.orientation,\n        \"data-pressed\": dataAttr(isPlaying),\n        \"aria-label\": isPlaying ? translations.autoplayStop : translations.autoplayStart,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: isPlaying ? \"AUTOPLAY.PAUSE\" : \"AUTOPLAY.START\"\n          });\n        }\n      });\n    }\n  };\n}\nfunction getSnapAlign(ctx, props2) {\n  const {\n    snapAlign = \"start\",\n    index\n  } = props2;\n  const perMove = ctx.slidesPerMove === \"auto\" ? Math.floor(ctx.slidesPerPage) : ctx.slidesPerMove;\n  const shouldSnap = (index + perMove) % perMove === 0;\n  return shouldSnap ? snapAlign : void 0;\n}\nvar DEFAULT_SLIDES_PER_PAGE = 1;\nvar DEFAULT_SLIDES_PER_MOVE = \"auto\";\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"carousel\",\n    initial: ctx.autoplay ? \"autoplay\" : \"idle\",\n    context: {\n      dir: \"ltr\",\n      page: 0,\n      orientation: \"horizontal\",\n      snapType: \"mandatory\",\n      loop: false,\n      slidesPerPage: DEFAULT_SLIDES_PER_PAGE,\n      slidesPerMove: DEFAULT_SLIDES_PER_MOVE,\n      spacing: \"0px\",\n      autoplay: false,\n      allowMouseDrag: false,\n      inViewThreshold: 0.6,\n      ...ctx,\n      timeoutRef: ref({\n        current: void 0\n      }),\n      translations: {\n        nextTrigger: \"Next slide\",\n        prevTrigger: \"Previous slide\",\n        indicator: index => `Go to slide ${index + 1}`,\n        item: (index, count) => `${index + 1} of ${count}`,\n        autoplayStart: \"Start slide rotation\",\n        autoplayStop: \"Stop slide rotation\",\n        ...ctx.translations\n      },\n      pageSnapPoints: getPageSnapPoints(ctx.slideCount, ctx.slidesPerMove ?? DEFAULT_SLIDES_PER_MOVE, ctx.slidesPerPage ?? DEFAULT_SLIDES_PER_PAGE),\n      slidesInView: []\n    },\n    computed: {\n      isRtl: ctx2 => ctx2.dir === \"rtl\",\n      isHorizontal: ctx2 => ctx2.orientation === \"horizontal\",\n      canScrollNext: ctx2 => ctx2.loop || ctx2.page < ctx2.pageSnapPoints.length - 1,\n      canScrollPrev: ctx2 => ctx2.loop || ctx2.page > 0,\n      autoplayInterval: ctx2 => isObject(ctx2.autoplay) ? ctx2.autoplay.delay : 4e3\n    },\n    watch: {\n      slidesPerPage: [\"setSnapPoints\"],\n      slidesPerMove: [\"setSnapPoints\"],\n      page: [\"scrollToPage\", \"focusIndicatorEl\"],\n      orientation: [\"setSnapPoints\", \"scrollToPage\"]\n    },\n    on: {\n      \"PAGE.NEXT\": {\n        target: \"idle\",\n        actions: [\"clearScrollEndTimer\", \"setNextPage\"]\n      },\n      \"PAGE.PREV\": {\n        target: \"idle\",\n        actions: [\"clearScrollEndTimer\", \"setPrevPage\"]\n      },\n      \"PAGE.SET\": {\n        target: \"idle\",\n        actions: [\"clearScrollEndTimer\", \"setPage\"]\n      },\n      \"INDEX.SET\": {\n        target: \"idle\",\n        actions: [\"clearScrollEndTimer\", \"setMatchingPage\"]\n      },\n      \"SNAP.REFRESH\": {\n        actions: [\"setSnapPoints\", \"clampPage\"]\n      }\n    },\n    activities: [\"trackSlideMutation\", \"trackSlideIntersections\", \"trackSlideResize\"],\n    entry: [\"resetScrollPosition\", \"setSnapPoints\", \"setPage\"],\n    exit: [\"clearScrollEndTimer\"],\n    states: {\n      idle: {\n        activities: [\"trackScroll\"],\n        on: {\n          \"DRAGGING.START\": {\n            target: \"dragging\",\n            actions: [\"invokeDragStart\"]\n          },\n          \"AUTOPLAY.START\": {\n            target: \"autoplay\",\n            actions: [\"invokeAutoplayStart\"]\n          }\n        }\n      },\n      dragging: {\n        activities: [\"trackPointerMove\"],\n        entry: [\"disableScrollSnap\"],\n        on: {\n          DRAGGING: {\n            actions: [\"scrollSlides\", \"invokeDragging\"]\n          },\n          \"DRAGGING.END\": {\n            target: \"idle\",\n            actions: [\"endDragging\", \"invokeDraggingEnd\"]\n          }\n        }\n      },\n      autoplay: {\n        activities: [\"trackDocumentVisibility\", \"trackScroll\"],\n        exit: [\"invokeAutoplayEnd\"],\n        every: {\n          AUTOPLAY_INTERVAL: [\"setNextPage\", \"invokeAutoplay\"]\n        },\n        on: {\n          \"DRAGGING.START\": {\n            target: \"dragging\",\n            actions: [\"invokeDragStart\"]\n          },\n          \"AUTOPLAY.PAUSE\": \"idle\"\n        }\n      }\n    }\n  }, {\n    activities: {\n      trackSlideMutation(ctx2, _evt, {\n        send\n      }) {\n        const el = dom.getItemGroupEl(ctx2);\n        if (!el) return;\n        const win = dom.getWin(ctx2);\n        const observer = new win.MutationObserver(() => {\n          send({\n            type: \"SNAP.REFRESH\",\n            src: \"slide.mutation\"\n          });\n          dom.syncTabIndex(ctx2);\n        });\n        dom.syncTabIndex(ctx2);\n        observer.observe(el, {\n          childList: true,\n          subtree: true\n        });\n        return () => observer.disconnect();\n      },\n      trackSlideResize(ctx2, _evt, {\n        send\n      }) {\n        const el = dom.getItemGroupEl(ctx2);\n        if (!el) return;\n        const win = dom.getWin(ctx2);\n        const observer = new win.ResizeObserver(() => {\n          send({\n            type: \"SNAP.REFRESH\",\n            src: \"slide.resize\"\n          });\n        });\n        dom.getItemEls(ctx2).forEach(slide => observer.observe(slide));\n        return () => observer.disconnect();\n      },\n      trackSlideIntersections(ctx2) {\n        const el = dom.getItemGroupEl(ctx2);\n        const win = dom.getWin(ctx2);\n        const observer = new win.IntersectionObserver(entries => {\n          const slidesInView = entries.reduce((acc, entry) => {\n            const target = entry.target;\n            const index = Number(target.dataset.index ?? \"-1\");\n            if (index == null || Number.isNaN(index) || index === -1) return acc;\n            return entry.isIntersecting ? add(acc, index) : remove(acc, index);\n          }, ctx2.slidesInView);\n          ctx2.slidesInView = uniq(slidesInView);\n        }, {\n          root: el,\n          threshold: ctx2.inViewThreshold\n        });\n        dom.getItemEls(ctx2).forEach(slide => observer.observe(slide));\n        return () => observer.disconnect();\n      },\n      trackScroll(ctx2) {\n        const el = dom.getItemGroupEl(ctx2);\n        if (!el) return;\n        const onScrollEnd = () => {\n          if (ctx2.slidesInView.length === 0) return;\n          const scrollPosition = ctx2.isHorizontal ? el.scrollLeft : el.scrollTop;\n          const page = ctx2.pageSnapPoints.findIndex(point => Math.abs(point - scrollPosition) < 1);\n          if (page === -1) return;\n          set.page(ctx2, page);\n        };\n        const onScroll = () => {\n          clearTimeout(ctx2.timeoutRef.current);\n          ctx2.timeoutRef.current = setTimeout(() => {\n            onScrollEnd?.();\n          }, 150);\n        };\n        return addDomEvent(el, \"scroll\", onScroll, {\n          passive: true\n        });\n      },\n      trackDocumentVisibility(ctx2, _evt, {\n        send\n      }) {\n        const doc = dom.getDoc(ctx2);\n        const onVisibilityChange = () => {\n          if (doc.visibilityState === \"visible\") return;\n          send({\n            type: \"AUTOPLAY.PAUSE\",\n            src: \"doc.hidden\"\n          });\n        };\n        return addDomEvent(doc, \"visibilitychange\", onVisibilityChange);\n      },\n      trackPointerMove(ctx2, _evt, {\n        send\n      }) {\n        const doc = dom.getDoc(ctx2);\n        return trackPointerMove(doc, {\n          onPointerMove({\n            event\n          }) {\n            send({\n              type: \"DRAGGING\",\n              left: -event.movementX,\n              top: -event.movementY\n            });\n          },\n          onPointerUp() {\n            send({\n              type: \"DRAGGING.END\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      resetScrollPosition(ctx2) {\n        const el = dom.getItemGroupEl(ctx2);\n        el.scrollTo(0, 0);\n      },\n      clearScrollEndTimer(ctx2) {\n        if (ctx2.timeoutRef.current == null) return;\n        clearTimeout(ctx2.timeoutRef.current);\n        ctx2.timeoutRef.current = void 0;\n      },\n      scrollToPage(ctx2, evt) {\n        const behavior = evt.instant ? \"instant\" : \"smooth\";\n        const index = clamp(evt.index ?? ctx2.page, 0, ctx2.pageSnapPoints.length - 1);\n        const el = dom.getItemGroupEl(ctx2);\n        const axis = ctx2.isHorizontal ? \"left\" : \"top\";\n        el.scrollTo({\n          [axis]: ctx2.pageSnapPoints[index],\n          behavior\n        });\n      },\n      setNextPage(ctx2) {\n        const page = nextIndex(ctx2.pageSnapPoints, ctx2.page, {\n          loop: ctx2.loop\n        });\n        set.page(ctx2, page);\n      },\n      setPrevPage(ctx2) {\n        const page = prevIndex(ctx2.pageSnapPoints, ctx2.page, {\n          loop: ctx2.loop\n        });\n        set.page(ctx2, page);\n      },\n      setMatchingPage(ctx2, evt) {\n        const snapPoint = findSnapPoint(dom.getItemGroupEl(ctx2), ctx2.isHorizontal ? \"x\" : \"y\", node => node.dataset.index === evt.index.toString());\n        if (snapPoint == null) return;\n        const page = ctx2.pageSnapPoints.indexOf(snapPoint);\n        set.page(ctx2, page);\n      },\n      setPage(ctx2, evt) {\n        set.page(ctx2, evt.index ?? ctx2.page);\n      },\n      clampPage(ctx2) {\n        const index = clamp(ctx2.page, 0, ctx2.pageSnapPoints.length - 1);\n        set.page(ctx2, index);\n      },\n      setSnapPoints(ctx2) {\n        queueMicrotask(() => {\n          const el = dom.getItemGroupEl(ctx2);\n          const scrollSnapPoints = getScrollSnapPositions(el);\n          ctx2.pageSnapPoints = ctx2.isHorizontal ? scrollSnapPoints.x : scrollSnapPoints.y;\n        });\n      },\n      disableScrollSnap(ctx2) {\n        const el = dom.getItemGroupEl(ctx2);\n        const styles = getComputedStyle(el);\n        el.dataset.scrollSnapType = styles.getPropertyValue(\"scroll-snap-type\");\n        el.style.setProperty(\"scroll-snap-type\", \"none\");\n      },\n      scrollSlides(ctx2, evt) {\n        const el = dom.getItemGroupEl(ctx2);\n        el.scrollBy({\n          left: evt.left,\n          top: evt.top,\n          behavior: \"instant\"\n        });\n      },\n      endDragging(ctx2) {\n        const el = dom.getItemGroupEl(ctx2);\n        const startX = el.scrollLeft;\n        const startY = el.scrollTop;\n        const snapPositions = getScrollSnapPositions(el);\n        const closestX = snapPositions.x.reduce((closest, curr) => {\n          return Math.abs(curr - startX) < Math.abs(closest - startX) ? curr : closest;\n        }, snapPositions.x[0]);\n        const closestY = snapPositions.y.reduce((closest, curr) => {\n          return Math.abs(curr - startY) < Math.abs(closest - startY) ? curr : closest;\n        }, snapPositions.y[0]);\n        raf(() => {\n          el.scrollTo({\n            left: closestX,\n            top: closestY,\n            behavior: \"smooth\"\n          });\n          const scrollSnapType = el.dataset.scrollSnapType;\n          if (scrollSnapType) {\n            el.style.removeProperty(\"scroll-snap-type\");\n            delete el.dataset.scrollSnapType;\n          }\n        });\n      },\n      focusIndicatorEl(ctx2, evt) {\n        if (evt.src !== \"indicator\") return;\n        const el = dom.getActiveIndicatorEl(ctx2);\n        raf(() => el.focus({\n          preventScroll: true\n        }));\n      },\n      invokeDragStart(ctx2) {\n        ctx2.onDragStatusChange?.({\n          type: \"dragging.start\",\n          isDragging: true,\n          page: ctx2.page\n        });\n      },\n      invokeDragging(ctx2) {\n        ctx2.onDragStatusChange?.({\n          type: \"dragging\",\n          isDragging: true,\n          page: ctx2.page\n        });\n      },\n      invokeDraggingEnd(ctx2) {\n        ctx2.onDragStatusChange?.({\n          type: \"dragging.end\",\n          isDragging: false,\n          page: ctx2.page\n        });\n      },\n      invokeAutoplay(ctx2) {\n        ctx2.onAutoplayStatusChange?.({\n          type: \"autoplay\",\n          isPlaying: true,\n          page: ctx2.page\n        });\n      },\n      invokeAutoplayStart(ctx2) {\n        ctx2.onAutoplayStatusChange?.({\n          type: \"autoplay.start\",\n          isPlaying: true,\n          page: ctx2.page\n        });\n      },\n      invokeAutoplayEnd(ctx2) {\n        ctx2.onAutoplayStatusChange?.({\n          type: \"autoplay.stop\",\n          isPlaying: false,\n          page: ctx2.page\n        });\n      }\n    },\n    delays: {\n      AUTOPLAY_INTERVAL: ctx2 => ctx2.autoplayInterval\n    }\n  });\n}\nvar invoke = {\n  pageChange: ctx => {\n    ctx.onPageChange?.({\n      page: ctx.page,\n      pageSnapPoint: ctx.pageSnapPoints[ctx.page]\n    });\n  }\n};\nvar set = {\n  page: (ctx, value) => {\n    const page = clamp(value, 0, ctx.pageSnapPoints.length - 1);\n    if (isEqual(ctx.page, page)) return;\n    ctx.page = page;\n    invoke.pageChange(ctx);\n  }\n};\nfunction clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\nfunction getPageSnapPoints(totalSlides, slidesPerMove, slidesPerPage) {\n  if (totalSlides == null) return [];\n  const snapPoints = [];\n  const perMove = slidesPerMove === \"auto\" ? Math.floor(slidesPerPage) : slidesPerMove;\n  for (let i = 0; i < totalSlides - 1; i += perMove) snapPoints.push(i);\n  return snapPoints;\n}\nvar props = createProps()([\"dir\", \"getRootNode\", \"id\", \"ids\", \"loop\", \"page\", \"onPageChange\", \"orientation\", \"slideCount\", \"slidesPerPage\", \"slidesPerMove\", \"spacing\", \"padding\", \"autoplay\", \"allowMouseDrag\", \"inViewThreshold\", \"translations\", \"snapType\", \"onDragStatusChange\", \"onAutoplayStatusChange\"]);\nvar splitProps = createSplitProps(props);\nvar indicatorProps = createProps()([\"index\", \"readOnly\"]);\nvar splitIndicatorProps = createSplitProps(indicatorProps);\nvar itemProps = createProps()([\"index\", \"snapAlign\"]);\nvar splitItemProps = createSplitProps(itemProps);\nexport { anatomy, connect, indicatorProps, itemProps, machine, props, splitIndicatorProps, splitItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
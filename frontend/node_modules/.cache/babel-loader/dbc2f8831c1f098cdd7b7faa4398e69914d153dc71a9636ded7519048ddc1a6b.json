{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope } from '@zag-js/dom-query';\nimport { createMachine } from '@zag-js/core';\nimport { createSplitProps, compact, isNumber, isEqual } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/progress.anatomy.ts\nvar anatomy = createAnatomy(\"progress\").parts(\"root\", \"label\", \"track\", \"range\", \"valueText\", \"view\", \"circle\", \"circleTrack\", \"circleRange\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `progress-${ctx.id}`,\n  getTrackId: ctx => ctx.ids?.track ?? `progress-${ctx.id}-track`,\n  getLabelId: ctx => ctx.ids?.label ?? `progress-${ctx.id}-label`,\n  getCircleId: ctx => ctx.ids?.circle ?? `progress-${ctx.id}-circle`\n});\n\n// src/progress.connect.ts\nfunction connect(state, send, normalize) {\n  const percent = state.context.percent;\n  const percentAsString = state.context.isIndeterminate ? \"\" : `${percent}%`;\n  const max = state.context.max;\n  const min = state.context.min;\n  const orientation = state.context.orientation;\n  const translations = state.context.translations;\n  const indeterminate = state.context.isIndeterminate;\n  const value = state.context.value;\n  const valueAsString = translations.value({\n    value,\n    max,\n    percent,\n    min\n  });\n  const progressState = getProgressState(value, max);\n  const progressbarProps = {\n    role: \"progressbar\",\n    \"aria-label\": valueAsString,\n    \"data-max\": max,\n    \"aria-valuemin\": min,\n    \"aria-valuemax\": max,\n    \"aria-valuenow\": value ?? void 0,\n    \"data-orientation\": orientation,\n    \"data-state\": progressState\n  };\n  const circleProps = getCircleProps(state.context);\n  return {\n    value,\n    valueAsString,\n    min,\n    max,\n    percent,\n    percentAsString,\n    indeterminate,\n    setValue(value2) {\n      send({\n        type: \"VALUE.SET\",\n        value: value2\n      });\n    },\n    setToMax() {\n      send({\n        type: \"VALUE.SET\",\n        value: max\n      });\n    },\n    setToMin() {\n      send({\n        type: \"VALUE.SET\",\n        value: min\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        dir: state.context.dir,\n        ...parts.root.attrs,\n        id: dom.getRootId(state.context),\n        \"data-max\": max,\n        \"data-value\": value ?? void 0,\n        \"data-state\": progressState,\n        \"data-orientation\": orientation,\n        style: {\n          \"--percent\": indeterminate ? void 0 : percent\n        }\n      });\n    },\n    getLabelProps() {\n      return normalize.element({\n        dir: state.context.dir,\n        id: dom.getLabelId(state.context),\n        ...parts.label.attrs,\n        \"data-orientation\": orientation\n      });\n    },\n    getValueTextProps() {\n      return normalize.element({\n        dir: state.context.dir,\n        \"aria-live\": \"polite\",\n        ...parts.valueText.attrs\n      });\n    },\n    getTrackProps() {\n      return normalize.element({\n        dir: state.context.dir,\n        id: dom.getTrackId(state.context),\n        ...parts.track.attrs,\n        ...progressbarProps\n      });\n    },\n    getRangeProps() {\n      return normalize.element({\n        dir: state.context.dir,\n        ...parts.range.attrs,\n        \"data-orientation\": orientation,\n        \"data-state\": progressState,\n        style: {\n          [state.context.isHorizontal ? \"width\" : \"height\"]: indeterminate ? void 0 : `${percent}%`\n        }\n      });\n    },\n    getCircleProps() {\n      return normalize.element({\n        dir: state.context.dir,\n        id: dom.getCircleId(state.context),\n        ...parts.circle.attrs,\n        ...progressbarProps,\n        ...circleProps.root\n      });\n    },\n    getCircleTrackProps() {\n      return normalize.element({\n        dir: state.context.dir,\n        \"data-orientation\": orientation,\n        ...parts.circleTrack.attrs,\n        ...circleProps.track\n      });\n    },\n    getCircleRangeProps() {\n      return normalize.element({\n        dir: state.context.dir,\n        ...parts.circleRange.attrs,\n        ...circleProps.range,\n        \"data-state\": progressState\n      });\n    },\n    getViewProps(props2) {\n      return normalize.element({\n        dir: state.context.dir,\n        ...parts.view.attrs,\n        \"data-state\": props2.state,\n        hidden: props2.state !== progressState\n      });\n    }\n  };\n}\nfunction getProgressState(value, maxValue) {\n  return value == null ? \"indeterminate\" : value === maxValue ? \"complete\" : \"loading\";\n}\nfunction getCircleProps(ctx) {\n  const circleProps = {\n    style: {\n      \"--radius\": \"calc(var(--size) / 2 - var(--thickness) / 2)\",\n      cx: \"calc(var(--size) / 2)\",\n      cy: \"calc(var(--size) / 2)\",\n      r: \"var(--radius)\",\n      fill: \"transparent\",\n      strokeWidth: \"var(--thickness)\"\n    }\n  };\n  return {\n    root: {\n      style: {\n        width: \"var(--size)\",\n        height: \"var(--size)\"\n      }\n    },\n    track: circleProps,\n    range: {\n      opacity: ctx.value === 0 ? 0 : void 0,\n      style: {\n        ...circleProps.style,\n        \"--percent\": ctx.percent,\n        \"--circumference\": `calc(2 * 3.14159 * var(--radius))`,\n        \"--offset\": `calc(var(--circumference) * (100 - var(--percent)) / 100)`,\n        strokeDashoffset: `calc(var(--circumference) * ((100 - var(--percent)) / 100))`,\n        strokeDasharray: ctx.isIndeterminate ? void 0 : `var(--circumference)`,\n        transformOrigin: \"center\",\n        transform: \"rotate(-90deg)\"\n      }\n    }\n  };\n}\nfunction midValue(min, max) {\n  return min + (max - min) / 2;\n}\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"progress\",\n    initial: \"idle\",\n    context: {\n      max: ctx.max ?? 100,\n      min: ctx.min ?? 0,\n      value: midValue(ctx.min ?? 0, ctx.max ?? 100),\n      orientation: \"horizontal\",\n      translations: {\n        value: ({\n          percent\n        }) => percent === -1 ? \"loading...\" : `${percent} percent`,\n        ...ctx.translations\n      },\n      ...ctx\n    },\n    created: [\"validateContext\"],\n    computed: {\n      isIndeterminate: ctx2 => ctx2.value === null,\n      percent(ctx2) {\n        if (!isNumber(ctx2.value)) return -1;\n        return Math.round((ctx2.value - ctx2.min) / (ctx2.max - ctx2.min) * 100);\n      },\n      isAtMax: ctx2 => ctx2.value === ctx2.max,\n      isHorizontal: ctx2 => ctx2.orientation === \"horizontal\",\n      isRtl: ctx2 => ctx2.dir === \"rtl\"\n    },\n    states: {\n      idle: {\n        on: {\n          \"VALUE.SET\": {\n            actions: [\"setValue\"]\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      setValue: (ctx2, evt) => {\n        set.value(ctx2, evt.value);\n      },\n      validateContext: ctx2 => {\n        if (ctx2.value == null) return;\n        if (!isValidNumber(ctx2.max)) {\n          throw new Error(`[progress] The max value passed \\`${ctx2.max}\\` is not a valid number`);\n        }\n        if (!isValidMax(ctx2.value, ctx2.max)) {\n          throw new Error(`[progress] The value passed \\`${ctx2.value}\\` exceeds the max value \\`${ctx2.max}\\``);\n        }\n        if (!isValidMin(ctx2.value, ctx2.min)) {\n          throw new Error(`[progress] The value passed \\`${ctx2.value}\\` exceeds the min value \\`${ctx2.min}\\``);\n        }\n      }\n    }\n  });\n}\nfunction isValidNumber(max) {\n  return isNumber(max) && !isNaN(max);\n}\nfunction isValidMax(value, max) {\n  return isValidNumber(value) && value <= max;\n}\nfunction isValidMin(value, min) {\n  return isValidNumber(value) && value >= min;\n}\nvar set = {\n  value(ctx, value) {\n    if (isEqual(ctx.value, value)) return;\n    ctx.value = value === null ? null : Math.max(0, Math.min(value, ctx.max));\n    ctx.onValueChange?.({\n      value\n    });\n  }\n};\nvar props = createProps()([\"dir\", \"getRootNode\", \"id\", \"ids\", \"max\", \"min\", \"orientation\", \"translations\", \"value\", \"onValueChange\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
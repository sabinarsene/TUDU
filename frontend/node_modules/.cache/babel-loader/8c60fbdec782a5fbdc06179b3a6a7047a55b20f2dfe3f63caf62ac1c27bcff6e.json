{"ast":null,"code":"import { isGenerator, createGeneratorEasing } from 'motion-dom';\nimport { progress, secondsToMilliseconds, invariant } from 'motion-utils';\nimport { getEasingForSegment } from '../../easing/utils/get-easing-for-segment.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { resolveSubjects } from '../animate/resolve-subjects.mjs';\nimport { calculateRepeatDuration } from './utils/calc-repeat-duration.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { normalizeTimes } from './utils/normalize-times.mjs';\nimport { compareByTime } from './utils/sort.mjs';\nconst defaultSegmentEasing = \"easeInOut\";\nconst MAX_REPEAT = 20;\nfunction createAnimationsFromSequence(sequence, {\n  defaultTransition = {},\n  ...sequenceTransition\n} = {}, scope, generators) {\n  const defaultDuration = defaultTransition.duration || 0.3;\n  const animationDefinitions = new Map();\n  const sequences = new Map();\n  const elementCache = {};\n  const timeLabels = new Map();\n  let prevTime = 0;\n  let currentTime = 0;\n  let totalDuration = 0;\n  /**\r\n   * Build the timeline by mapping over the sequence array and converting\r\n   * the definitions into keyframes and offsets with absolute time values.\r\n   * These will later get converted into relative offsets in a second pass.\r\n   */\n  for (let i = 0; i < sequence.length; i++) {\n    const segment = sequence[i];\n    /**\r\n     * If this is a timeline label, mark it and skip the rest of this iteration.\r\n     */\n    if (typeof segment === \"string\") {\n      timeLabels.set(segment, currentTime);\n      continue;\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      continue;\n    }\n    let [subject, keyframes, transition = {}] = segment;\n    /**\r\n     * If a relative or absolute time value has been specified we need to resolve\r\n     * it in relation to the currentTime.\r\n     */\n    if (transition.at !== undefined) {\n      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n    }\n    /**\r\n     * Keep track of the maximum duration in this definition. This will be\r\n     * applied to currentTime once the definition has been parsed.\r\n     */\n    let maxDuration = 0;\n    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {\n      const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n      const {\n        delay = 0,\n        times = defaultOffset(valueKeyframesAsList),\n        type = \"keyframes\",\n        repeat,\n        repeatType,\n        repeatDelay = 0,\n        ...remainingTransition\n      } = valueTransition;\n      let {\n        ease = defaultTransition.ease || \"easeOut\",\n        duration\n      } = valueTransition;\n      /**\r\n       * Resolve stagger() if defined.\r\n       */\n      const calculatedDelay = typeof delay === \"function\" ? delay(elementIndex, numSubjects) : delay;\n      /**\r\n       * If this animation should and can use a spring, generate a spring easing function.\r\n       */\n      const numKeyframes = valueKeyframesAsList.length;\n      const createGenerator = isGenerator(type) ? type : generators === null || generators === void 0 ? void 0 : generators[type];\n      if (numKeyframes <= 2 && createGenerator) {\n        /**\r\n         * As we're creating an easing function from a spring,\r\n         * ideally we want to generate it using the real distance\r\n         * between the two keyframes. However this isn't always\r\n         * possible - in these situations we use 0-100.\r\n         */\n        let absoluteDelta = 100;\n        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {\n          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n          absoluteDelta = Math.abs(delta);\n        }\n        const springTransition = {\n          ...remainingTransition\n        };\n        if (duration !== undefined) {\n          springTransition.duration = secondsToMilliseconds(duration);\n        }\n        const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\n        ease = springEasing.ease;\n        duration = springEasing.duration;\n      }\n      duration !== null && duration !== void 0 ? duration : duration = defaultDuration;\n      const startTime = currentTime + calculatedDelay;\n      /**\r\n       * If there's only one time offset of 0, fill in a second with length 1\r\n       */\n      if (times.length === 1 && times[0] === 0) {\n        times[1] = 1;\n      }\n      /**\r\n       * Fill out if offset if fewer offsets than keyframes\r\n       */\n      const remainder = times.length - valueKeyframesAsList.length;\n      remainder > 0 && fillOffset(times, remainder);\n      /**\r\n       * If only one value has been set, ie [1], push a null to the start of\r\n       * the keyframe array. This will let us mark a keyframe at this point\r\n       * that will later be hydrated with the previous value.\r\n       */\n      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);\n      /**\r\n       * Handle repeat options\r\n       */\n      if (repeat) {\n        invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\");\n        duration = calculateRepeatDuration(duration, repeat);\n        const originalKeyframes = [...valueKeyframesAsList];\n        const originalTimes = [...times];\n        ease = Array.isArray(ease) ? [...ease] : [ease];\n        const originalEase = [...ease];\n        for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n          valueKeyframesAsList.push(...originalKeyframes);\n          for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {\n            times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\n            ease.push(keyframeIndex === 0 ? \"linear\" : getEasingForSegment(originalEase, keyframeIndex - 1));\n          }\n        }\n        normalizeTimes(times, repeat);\n      }\n      const targetTime = startTime + duration;\n      /**\r\n       * Add keyframes, mapping offsets to absolute time.\r\n       */\n      addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n      maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n      totalDuration = Math.max(targetTime, totalDuration);\n    };\n    if (isMotionValue(subject)) {\n      const subjectSequence = getSubjectSequence(subject, sequences);\n      resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n    } else {\n      const subjects = resolveSubjects(subject, keyframes, scope, elementCache);\n      const numSubjects = subjects.length;\n      /**\r\n       * For every element in this segment, process the defined values.\r\n       */\n      for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {\n        /**\r\n         * Cast necessary, but we know these are of this type\r\n         */\n        keyframes = keyframes;\n        transition = transition;\n        const thisSubject = subjects[subjectIndex];\n        const subjectSequence = getSubjectSequence(thisSubject, sequences);\n        for (const key in keyframes) {\n          resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);\n        }\n      }\n    }\n    prevTime = currentTime;\n    currentTime += maxDuration;\n  }\n  /**\r\n   * For every element and value combination create a new animation.\r\n   */\n  sequences.forEach((valueSequences, element) => {\n    for (const key in valueSequences) {\n      const valueSequence = valueSequences[key];\n      /**\r\n       * Arrange all the keyframes in ascending time order.\r\n       */\n      valueSequence.sort(compareByTime);\n      const keyframes = [];\n      const valueOffset = [];\n      const valueEasing = [];\n      /**\r\n       * For each keyframe, translate absolute times into\r\n       * relative offsets based on the total duration of the timeline.\r\n       */\n      for (let i = 0; i < valueSequence.length; i++) {\n        const {\n          at,\n          value,\n          easing\n        } = valueSequence[i];\n        keyframes.push(value);\n        valueOffset.push(progress(0, totalDuration, at));\n        valueEasing.push(easing || \"easeOut\");\n      }\n      /**\r\n       * If the first keyframe doesn't land on offset: 0\r\n       * provide one by duplicating the initial keyframe. This ensures\r\n       * it snaps to the first keyframe when the animation starts.\r\n       */\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n        keyframes.unshift(keyframes[0]);\n        valueEasing.unshift(defaultSegmentEasing);\n      }\n      /**\r\n       * If the last keyframe doesn't land on offset: 1\r\n       * provide one with a null wildcard value. This will ensure it\r\n       * stays static until the end of the animation.\r\n       */\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n        keyframes.push(null);\n      }\n      if (!animationDefinitions.has(element)) {\n        animationDefinitions.set(element, {\n          keyframes: {},\n          transition: {}\n        });\n      }\n      const definition = animationDefinitions.get(element);\n      definition.keyframes[key] = keyframes;\n      definition.transition[key] = {\n        ...defaultTransition,\n        duration: totalDuration,\n        ease: valueEasing,\n        times: valueOffset,\n        ...sequenceTransition\n      };\n    }\n  });\n  return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n  !sequences.has(subject) && sequences.set(subject, {});\n  return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n  return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n  return transition && transition[key] ? {\n    ...transition,\n    ...transition[key]\n  } : {\n    ...transition\n  };\n}\nconst isNumber = keyframe => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = keyframes => keyframes.every(isNumber);\nexport { createAnimationsFromSequence, getValueTransition };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
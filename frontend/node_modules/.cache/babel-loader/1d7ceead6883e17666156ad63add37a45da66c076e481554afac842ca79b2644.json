{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, dataAttr, isSelfTarget, contains, visuallyHiddenStyle, addDomEvent, raf, getEventTarget } from '@zag-js/dom-query';\nimport { formatBytes } from '@zag-js/i18n-utils';\nimport { createProps } from '@zag-js/types';\nimport { getAcceptAttrString, isFileEqual, isValidFileType, isValidFileSize } from '@zag-js/file-utils';\nimport { createMachine, ref } from '@zag-js/core';\nimport { createSplitProps, compact, callAll } from '@zag-js/utils';\n\n// src/file-upload.anatomy.ts\nvar anatomy = createAnatomy(\"file-upload\").parts(\"root\", \"dropzone\", \"item\", \"itemDeleteTrigger\", \"itemGroup\", \"itemName\", \"itemPreview\", \"itemPreviewImage\", \"itemSizeText\", \"label\", \"trigger\", \"clearTrigger\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `file:${ctx.id}`,\n  getDropzoneId: ctx => ctx.ids?.dropzone ?? `file:${ctx.id}:dropzone`,\n  getHiddenInputId: ctx => ctx.ids?.hiddenInput ?? `file:${ctx.id}:input`,\n  getTriggerId: ctx => ctx.ids?.trigger ?? `file:${ctx.id}:trigger`,\n  getLabelId: ctx => ctx.ids?.label ?? `file:${ctx.id}:label`,\n  getItemId: (ctx, id) => ctx.ids?.item?.(id) ?? `file:${ctx.id}:item:${id}`,\n  getItemNameId: (ctx, id) => ctx.ids?.itemName?.(id) ?? `file:${ctx.id}:item-name:${id}`,\n  getItemSizeTextId: (ctx, id) => ctx.ids?.itemSizeText?.(id) ?? `file:${ctx.id}:item-size:${id}`,\n  getItemPreviewId: (ctx, id) => ctx.ids?.itemPreview?.(id) ?? `file:${ctx.id}:item-preview:${id}`,\n  getRootEl: ctx => dom.getById(ctx, dom.getRootId(ctx)),\n  getHiddenInputEl: ctx => dom.getById(ctx, dom.getHiddenInputId(ctx)),\n  getDropzoneEl: ctx => dom.getById(ctx, dom.getDropzoneId(ctx))\n});\nfunction isEventWithFiles(event) {\n  const target = getEventTarget(event);\n  if (!event.dataTransfer) return !!target && \"files\" in target;\n  return event.dataTransfer.types.some(type => {\n    return type === \"Files\" || type === \"application/x-moz-file\";\n  });\n}\nfunction isFilesWithinRange(ctx, incomingCount) {\n  if (!ctx.multiple && incomingCount > 1) return false;\n  if (!ctx.multiple && incomingCount + ctx.acceptedFiles.length === 2) return true;\n  if (incomingCount + ctx.acceptedFiles.length > ctx.maxFiles) return false;\n  return true;\n}\nfunction getFilesFromEvent(ctx, files) {\n  const acceptedFiles = [];\n  const rejectedFiles = [];\n  files.forEach(file => {\n    const [accepted, acceptError] = isValidFileType(file, ctx.acceptAttr);\n    const [sizeMatch, sizeError] = isValidFileSize(file, ctx.minFileSize, ctx.maxFileSize);\n    const validateErrors = ctx.validate?.(file, {\n      acceptedFiles: ctx.acceptedFiles,\n      rejectedFiles: ctx.rejectedFiles\n    });\n    const valid = validateErrors ? validateErrors.length === 0 : true;\n    if (accepted && sizeMatch && valid) {\n      acceptedFiles.push(file);\n    } else {\n      const errors = [acceptError, sizeError];\n      if (!valid) errors.push(...(validateErrors ?? []));\n      rejectedFiles.push({\n        file,\n        errors: errors.filter(Boolean)\n      });\n    }\n  });\n  if (!isFilesWithinRange(ctx, acceptedFiles.length)) {\n    acceptedFiles.forEach(file => {\n      rejectedFiles.push({\n        file,\n        errors: [\"TOO_MANY_FILES\"]\n      });\n    });\n    acceptedFiles.splice(0);\n  }\n  return {\n    acceptedFiles,\n    rejectedFiles\n  };\n}\n\n// src/file-upload.connect.ts\nfunction connect(state, send, normalize) {\n  const disabled = state.context.disabled;\n  const allowDrop = state.context.allowDrop;\n  const translations = state.context.translations;\n  const dragging = state.matches(\"dragging\");\n  const focused = state.matches(\"focused\") && !disabled;\n  return {\n    dragging,\n    focused,\n    disabled: !!disabled,\n    openFilePicker() {\n      if (disabled) return;\n      send(\"OPEN\");\n    },\n    deleteFile(file) {\n      send({\n        type: \"FILE.DELETE\",\n        file\n      });\n    },\n    acceptedFiles: state.context.acceptedFiles,\n    rejectedFiles: state.context.rejectedFiles,\n    setFiles(files) {\n      const count = files.length;\n      send({\n        type: \"FILES.SET\",\n        files,\n        count\n      });\n    },\n    clearRejectedFiles() {\n      send({\n        type: \"REJECTED_FILES.CLEAR\"\n      });\n    },\n    clearFiles() {\n      send({\n        type: \"FILES.CLEAR\"\n      });\n    },\n    getFileSize(file) {\n      return formatBytes(file.size, state.context.locale);\n    },\n    createFileUrl(file, cb) {\n      const win = dom.getWin(state.context);\n      const url = win.URL.createObjectURL(file);\n      cb(url);\n      return () => win.URL.revokeObjectURL(url);\n    },\n    setClipboardFiles(dt) {\n      if (disabled) return false;\n      const items = Array.from(dt?.items ?? []);\n      const files = items.reduce((acc, item) => {\n        if (item.kind !== \"file\") return acc;\n        const file = item.getAsFile();\n        if (!file) return acc;\n        return [...acc, file];\n      }, []);\n      if (!files.length) return false;\n      send({\n        type: \"FILES.SET\",\n        files\n      });\n      return true;\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        id: dom.getRootId(state.context),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-dragging\": dataAttr(dragging)\n      });\n    },\n    getDropzoneProps(props2 = {}) {\n      return normalize.element({\n        ...parts.dropzone.attrs,\n        dir: state.context.dir,\n        id: dom.getDropzoneId(state.context),\n        tabIndex: disabled || props2.disableClick ? void 0 : 0,\n        role: props2.disableClick ? \"application\" : \"button\",\n        \"aria-label\": translations.dropzone,\n        \"aria-disabled\": disabled,\n        \"data-invalid\": dataAttr(state.context.invalid),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-dragging\": dataAttr(dragging),\n        onKeyDown(event) {\n          if (disabled) return;\n          if (event.defaultPrevented) return;\n          if (!isSelfTarget(event)) return;\n          if (props2.disableClick) return;\n          if (event.key !== \"Enter\" && event.key !== \" \") return;\n          send({\n            type: \"DROPZONE.CLICK\",\n            src: \"keydown\"\n          });\n        },\n        onClick(event) {\n          if (disabled) return;\n          if (event.defaultPrevented) return;\n          if (props2.disableClick) return;\n          if (!isSelfTarget(event)) return;\n          if (event.currentTarget.localName === \"label\") {\n            event.preventDefault();\n          }\n          send(\"DROPZONE.CLICK\");\n        },\n        onDragOver(event) {\n          if (disabled) return;\n          if (!allowDrop) return;\n          event.preventDefault();\n          event.stopPropagation();\n          try {\n            event.dataTransfer.dropEffect = \"copy\";\n          } catch {}\n          const hasFiles = isEventWithFiles(event);\n          if (!hasFiles) return;\n          const count = event.dataTransfer.items.length;\n          send({\n            type: \"DROPZONE.DRAG_OVER\",\n            count\n          });\n        },\n        onDragLeave(event) {\n          if (disabled) return;\n          if (!allowDrop) return;\n          if (contains(event.currentTarget, event.relatedTarget)) return;\n          send({\n            type: \"DROPZONE.DRAG_LEAVE\"\n          });\n        },\n        onDrop(event) {\n          if (disabled) return;\n          if (allowDrop) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n          const hasFiles = isEventWithFiles(event);\n          if (disabled || !hasFiles) return;\n          send({\n            type: \"DROPZONE.DROP\",\n            files: Array.from(event.dataTransfer.files)\n          });\n        },\n        onFocus() {\n          if (disabled) return;\n          send(\"DROPZONE.FOCUS\");\n        },\n        onBlur() {\n          if (disabled) return;\n          send(\"DROPZONE.BLUR\");\n        }\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        dir: state.context.dir,\n        id: dom.getTriggerId(state.context),\n        disabled,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(state.context.invalid),\n        type: \"button\",\n        onClick(event) {\n          if (disabled) return;\n          if (contains(dom.getDropzoneEl(state.context), event.currentTarget)) {\n            event.stopPropagation();\n          }\n          send(\"OPEN\");\n        }\n      });\n    },\n    getHiddenInputProps() {\n      return normalize.input({\n        id: dom.getHiddenInputId(state.context),\n        tabIndex: -1,\n        disabled,\n        type: \"file\",\n        required: state.context.required,\n        capture: state.context.capture,\n        name: state.context.name,\n        accept: state.context.acceptAttr,\n        webkitdirectory: state.context.directory ? \"\" : void 0,\n        multiple: state.context.multiple || state.context.maxFiles > 1,\n        onClick(event) {\n          event.stopPropagation();\n          event.currentTarget.value = \"\";\n        },\n        onInput(event) {\n          if (disabled) return;\n          const {\n            files\n          } = event.currentTarget;\n          send({\n            type: \"FILES.SET\",\n            files: files ? Array.from(files) : []\n          });\n        },\n        style: visuallyHiddenStyle\n      });\n    },\n    getItemGroupProps() {\n      return normalize.element({\n        ...parts.itemGroup.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getItemProps(props2) {\n      const {\n        file\n      } = props2;\n      return normalize.element({\n        ...parts.item.attrs,\n        dir: state.context.dir,\n        id: dom.getItemId(state.context, file.name),\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getItemNameProps(props2) {\n      const {\n        file\n      } = props2;\n      return normalize.element({\n        ...parts.itemName.attrs,\n        dir: state.context.dir,\n        id: dom.getItemNameId(state.context, file.name),\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getItemSizeTextProps(props2) {\n      const {\n        file\n      } = props2;\n      return normalize.element({\n        ...parts.itemSizeText.attrs,\n        dir: state.context.dir,\n        id: dom.getItemSizeTextId(state.context, file.name),\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getItemPreviewProps(props2) {\n      const {\n        file\n      } = props2;\n      return normalize.element({\n        ...parts.itemPreview.attrs,\n        dir: state.context.dir,\n        id: dom.getItemPreviewId(state.context, file.name),\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getItemPreviewImageProps(props2) {\n      const {\n        file,\n        url\n      } = props2;\n      const isImage = file.type.startsWith(\"image/\");\n      if (!isImage) {\n        throw new Error(\"Preview Image is only supported for image files\");\n      }\n      return normalize.img({\n        ...parts.itemPreviewImage.attrs,\n        alt: translations.itemPreview?.(file),\n        src: url,\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getItemDeleteTriggerProps(props2) {\n      const {\n        file\n      } = props2;\n      return normalize.button({\n        ...parts.itemDeleteTrigger.attrs,\n        dir: state.context.dir,\n        type: \"button\",\n        disabled,\n        \"data-disabled\": dataAttr(disabled),\n        \"aria-label\": translations.deleteFile?.(file),\n        onClick() {\n          if (disabled) return;\n          send({\n            type: \"FILE.DELETE\",\n            file\n          });\n        }\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        dir: state.context.dir,\n        id: dom.getLabelId(state.context),\n        htmlFor: dom.getHiddenInputId(state.context),\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getClearTriggerProps() {\n      return normalize.button({\n        ...parts.clearTrigger.attrs,\n        dir: state.context.dir,\n        type: \"button\",\n        disabled,\n        hidden: state.context.acceptedFiles.length === 0,\n        \"data-disabled\": dataAttr(disabled),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          send({\n            type: \"FILES.CLEAR\"\n          });\n        }\n      });\n    }\n  };\n}\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"fileupload\",\n    initial: \"idle\",\n    context: {\n      minFileSize: 0,\n      maxFileSize: Number.POSITIVE_INFINITY,\n      maxFiles: 1,\n      allowDrop: true,\n      accept: ctx.accept,\n      preventDocumentDrop: true,\n      ...ctx,\n      acceptedFiles: ref([]),\n      rejectedFiles: ref([]),\n      translations: {\n        dropzone: \"dropzone\",\n        itemPreview: file => `preview of ${file.name}`,\n        deleteFile: file => `delete file ${file.name}`,\n        ...ctx.translations\n      }\n    },\n    computed: {\n      acceptAttr: ctx2 => getAcceptAttrString(ctx2.accept),\n      multiple: ctx2 => ctx2.maxFiles > 1\n    },\n    watch: {\n      acceptedFiles: [\"syncInputElement\"]\n    },\n    on: {\n      \"FILES.SET\": {\n        actions: [\"setFilesFromEvent\"]\n      },\n      \"FILE.DELETE\": {\n        actions: [\"removeFile\"]\n      },\n      \"FILES.CLEAR\": {\n        actions: [\"clearFiles\"]\n      },\n      \"REJECTED_FILES.CLEAR\": {\n        actions: [\"clearRejectedFiles\"]\n      }\n    },\n    activities: [\"preventDocumentDrop\"],\n    states: {\n      idle: {\n        on: {\n          OPEN: {\n            actions: [\"openFilePicker\"]\n          },\n          \"DROPZONE.CLICK\": {\n            actions: [\"openFilePicker\"]\n          },\n          \"DROPZONE.FOCUS\": \"focused\",\n          \"DROPZONE.DRAG_OVER\": \"dragging\"\n        }\n      },\n      focused: {\n        on: {\n          \"DROPZONE.BLUR\": \"idle\",\n          OPEN: {\n            actions: [\"openFilePicker\"]\n          },\n          \"DROPZONE.CLICK\": {\n            actions: [\"openFilePicker\"]\n          },\n          \"DROPZONE.DRAG_OVER\": \"dragging\"\n        }\n      },\n      dragging: {\n        on: {\n          \"DROPZONE.DROP\": {\n            target: \"idle\",\n            actions: [\"setFilesFromEvent\"]\n          },\n          \"DROPZONE.DRAG_LEAVE\": \"idle\"\n        }\n      }\n    }\n  }, {\n    activities: {\n      preventDocumentDrop(ctx2) {\n        if (!ctx2.preventDocumentDrop) return;\n        if (!ctx2.allowDrop) return;\n        if (ctx2.disabled) return;\n        const doc = dom.getDoc(ctx2);\n        const onDragOver = event => {\n          event?.preventDefault();\n        };\n        const onDrop = event => {\n          if (contains(dom.getRootEl(ctx2), getEventTarget(event))) return;\n          event.preventDefault();\n        };\n        return callAll(addDomEvent(doc, \"dragover\", onDragOver, false), addDomEvent(doc, \"drop\", onDrop, false));\n      }\n    },\n    actions: {\n      syncInputElement(ctx2) {\n        queueMicrotask(() => {\n          const inputEl = dom.getHiddenInputEl(ctx2);\n          if (!inputEl) return;\n          const win = dom.getWin(ctx2);\n          const dataTransfer = new win.DataTransfer();\n          ctx2.acceptedFiles.forEach(v => {\n            dataTransfer.items.add(v);\n          });\n          inputEl.files = dataTransfer.files;\n          inputEl.dispatchEvent(new win.Event(\"change\", {\n            bubbles: true\n          }));\n        });\n      },\n      openFilePicker(ctx2) {\n        raf(() => {\n          dom.getHiddenInputEl(ctx2)?.click();\n        });\n      },\n      setFilesFromEvent(ctx2, evt) {\n        const result = getFilesFromEvent(ctx2, evt.files);\n        const {\n          acceptedFiles,\n          rejectedFiles\n        } = result;\n        if (ctx2.multiple) {\n          const files = ref([...ctx2.acceptedFiles, ...acceptedFiles]);\n          set.files(ctx2, files, rejectedFiles);\n          return;\n        }\n        if (acceptedFiles.length) {\n          const files = ref([acceptedFiles[0]]);\n          set.files(ctx2, files, rejectedFiles);\n        } else if (rejectedFiles.length) {\n          set.files(ctx2, ctx2.acceptedFiles, rejectedFiles);\n        }\n      },\n      removeFile(ctx2, evt) {\n        const files = Array.from(ctx2.acceptedFiles.filter(file => file !== evt.file));\n        const rejectedFiles = Array.from(ctx2.rejectedFiles.filter(item => item.file !== evt.file));\n        ctx2.acceptedFiles = ref(files);\n        ctx2.rejectedFiles = ref(rejectedFiles);\n        invoke.change(ctx2);\n      },\n      clearRejectedFiles(ctx2) {\n        ctx2.rejectedFiles = ref([]);\n        invoke.change(ctx2);\n      },\n      clearFiles(ctx2) {\n        ctx2.acceptedFiles = ref([]);\n        ctx2.rejectedFiles = ref([]);\n        invoke.change(ctx2);\n      }\n    },\n    compareFns: {\n      acceptedFiles: (a, b) => a.length === b.length && a.every((file, i) => isFileEqual(file, b[i]))\n    }\n  });\n}\nvar invoke = {\n  change: ctx => {\n    ctx.onFileChange?.({\n      acceptedFiles: ctx.acceptedFiles,\n      rejectedFiles: ctx.rejectedFiles\n    });\n  },\n  accept: ctx => {\n    ctx.onFileAccept?.({\n      files: ctx.acceptedFiles\n    });\n  },\n  reject: ctx => {\n    ctx.onFileReject?.({\n      files: ctx.rejectedFiles\n    });\n  }\n};\nvar set = {\n  files: (ctx, acceptedFiles, rejectedFiles) => {\n    ctx.acceptedFiles = ref(acceptedFiles);\n    invoke.accept(ctx);\n    if (rejectedFiles) {\n      ctx.rejectedFiles = ref(rejectedFiles);\n      invoke.reject(ctx);\n    }\n    invoke.change(ctx);\n  }\n};\nvar props = createProps()([\"accept\", \"allowDrop\", \"capture\", \"dir\", \"directory\", \"disabled\", \"getRootNode\", \"id\", \"ids\", \"locale\", \"maxFiles\", \"maxFileSize\", \"minFileSize\", \"name\", \"invalid\", \"onFileAccept\", \"onFileReject\", \"onFileChange\", \"preventDocumentDrop\", \"required\", \"translations\", \"validate\"]);\nvar splitProps = createSplitProps(props);\nvar itemProps = createProps()([\"file\"]);\nvar splitItemProps = createSplitProps(itemProps);\nexport { anatomy, connect, itemProps, machine, props, splitItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
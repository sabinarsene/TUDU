{"ast":null,"code":"'use client';\n\nimport { cssVars, toTransformOrigin, getBoxShadow } from './utils.mjs';\nconst matchWidth = {\n  name: \"matchWidth\",\n  enabled: true,\n  phase: \"beforeWrite\",\n  requires: [\"computeStyles\"],\n  fn: ({\n    state\n  }) => {\n    state.styles.popper.width = `${state.rects.reference.width}px`;\n  },\n  effect: ({\n    state\n  }) => () => {\n    const reference = state.elements.reference;\n    state.elements.popper.style.width = `${reference.offsetWidth}px`;\n  }\n};\nconst transformOrigin = {\n  name: \"transformOrigin\",\n  enabled: true,\n  phase: \"write\",\n  fn: ({\n    state\n  }) => {\n    setTransformOrigin(state);\n  },\n  effect: ({\n    state\n  }) => () => {\n    setTransformOrigin(state);\n  }\n};\nconst setTransformOrigin = state => {\n  state.elements.popper.style.setProperty(cssVars.transformOrigin.var, toTransformOrigin(state.placement));\n};\nconst positionArrow = {\n  name: \"positionArrow\",\n  enabled: true,\n  phase: \"afterWrite\",\n  fn: ({\n    state\n  }) => {\n    setArrowStyles(state);\n  }\n};\nconst setArrowStyles = state => {\n  if (!state.placement) return;\n  const overrides = getArrowStyle(state.placement);\n  if (state.elements?.arrow && overrides) {\n    Object.assign(state.elements.arrow.style, {\n      [overrides.property]: overrides.value,\n      width: cssVars.arrowSize.varRef,\n      height: cssVars.arrowSize.varRef,\n      zIndex: -1\n    });\n    const vars = {\n      [cssVars.arrowSizeHalf.var]: `calc(${cssVars.arrowSize.varRef} / 2 - 1px)`,\n      [cssVars.arrowOffset.var]: `calc(${cssVars.arrowSizeHalf.varRef} * -1)`\n    };\n    for (const property in vars) {\n      state.elements.arrow.style.setProperty(property, vars[property]);\n    }\n  }\n};\nconst getArrowStyle = placement => {\n  if (placement.startsWith(\"top\")) {\n    return {\n      property: \"bottom\",\n      value: cssVars.arrowOffset.varRef\n    };\n  }\n  if (placement.startsWith(\"bottom\")) {\n    return {\n      property: \"top\",\n      value: cssVars.arrowOffset.varRef\n    };\n  }\n  if (placement.startsWith(\"left\")) {\n    return {\n      property: \"right\",\n      value: cssVars.arrowOffset.varRef\n    };\n  }\n  if (placement.startsWith(\"right\")) {\n    return {\n      property: \"left\",\n      value: cssVars.arrowOffset.varRef\n    };\n  }\n};\nconst innerArrow = {\n  name: \"innerArrow\",\n  enabled: true,\n  phase: \"main\",\n  requires: [\"arrow\"],\n  fn: ({\n    state\n  }) => {\n    setInnerArrowStyles(state);\n  },\n  effect: ({\n    state\n  }) => () => {\n    setInnerArrowStyles(state);\n  }\n};\nconst setInnerArrowStyles = state => {\n  if (!state.elements.arrow) return;\n  const inner = state.elements.arrow.querySelector(\"[data-popper-arrow-inner]\");\n  if (!inner) return;\n  const boxShadow = getBoxShadow(state.placement);\n  if (boxShadow) {\n    inner.style.setProperty(\"--popper-arrow-default-shadow\", boxShadow);\n  }\n  Object.assign(inner.style, {\n    transform: \"rotate(45deg)\",\n    background: cssVars.arrowBg.varRef,\n    top: 0,\n    left: 0,\n    width: \"100%\",\n    height: \"100%\",\n    position: \"absolute\",\n    zIndex: \"inherit\",\n    boxShadow: `var(--popper-arrow-shadow, var(--popper-arrow-default-shadow))`\n  });\n};\nexport { innerArrow, matchWidth, positionArrow, transformOrigin };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
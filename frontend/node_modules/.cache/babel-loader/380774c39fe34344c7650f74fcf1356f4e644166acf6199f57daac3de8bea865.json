{"ast":null,"code":"\"use strict\";\n\"use client\";\n\nimport { jsx } from 'react/jsx-runtime';\nimport { useMemo, forwardRef } from 'react';\nimport { createContext } from '../create-context.js';\nimport { mergeProps } from '../merge-props.js';\nimport { cx } from '../utils/cx.js';\nimport { EMPTY_SLOT_STYLES } from './empty.js';\nimport { chakra } from './factory.js';\nimport { useSlotRecipe } from './use-slot-recipe.js';\nconst upperFirst = str => str.charAt(0).toUpperCase() + str.slice(1);\nconst createSlotRecipeContext = options => {\n  const {\n    key: recipeKey,\n    recipe: recipeConfig\n  } = options;\n  const contextName = upperFirst(recipeKey || recipeConfig.className || \"Component\");\n  const [StylesProvider, useStyles] = createContext({\n    name: `${contextName}StylesContext`,\n    errorMessage: `use${contextName}Styles returned is 'undefined'. Seems you forgot to wrap the components in \"<${contextName}.Root />\" `\n  });\n  const [ClassNamesProvider, useClassNames] = createContext({\n    name: `${contextName}ClassNameContext`,\n    errorMessage: `use${contextName}ClassNames returned is 'undefined'. Seems you forgot to wrap the components in \"<${contextName}.Root />\" `,\n    strict: false\n  });\n  const [PropsProvider, usePropsContext] = createContext({\n    strict: false,\n    name: `${contextName}PropsContext`,\n    providerName: `${contextName}PropsContext`,\n    defaultValue: {}\n  });\n  function useRecipeResult(props) {\n    const {\n      unstyled,\n      ...restProps\n    } = props;\n    const slotRecipe = useSlotRecipe({\n      key: recipeKey,\n      recipe: restProps.recipe || recipeConfig\n    });\n    const [variantProps, otherProps] = useMemo(() => slotRecipe.splitVariantProps(restProps), [restProps, slotRecipe]);\n    const styles = useMemo(() => unstyled ? EMPTY_SLOT_STYLES : slotRecipe(variantProps), [unstyled, variantProps, slotRecipe]);\n    return {\n      styles,\n      classNames: slotRecipe.classNameMap,\n      props: otherProps\n    };\n  }\n  function withRootProvider(Component, options2 = {}) {\n    const {\n      defaultProps\n    } = options2;\n    const StyledComponent = inProps => {\n      const propsContext = usePropsContext();\n      const props = useMemo(() => mergeProps(defaultProps, propsContext, inProps), [propsContext, inProps]);\n      const {\n        styles,\n        classNames,\n        props: rootProps\n      } = useRecipeResult(props);\n      return /* @__PURE__ */jsx(StylesProvider, {\n        value: styles,\n        children: /* @__PURE__ */jsx(ClassNamesProvider, {\n          value: classNames,\n          children: /* @__PURE__ */jsx(Component, {\n            ...rootProps\n          })\n        })\n      });\n    };\n    StyledComponent.displayName = Component.displayName || Component.name;\n    return StyledComponent;\n  }\n  const withProvider = (Component, slot, options2) => {\n    const {\n      defaultProps,\n      ...restOptions\n    } = options2 ?? {};\n    const SuperComponent = chakra(Component, {}, restOptions);\n    const StyledComponent = forwardRef((inProps, ref) => {\n      const propsContext = usePropsContext();\n      const props = useMemo(() => mergeProps(defaultProps ?? {}, propsContext, inProps), [propsContext, inProps]);\n      const {\n        styles,\n        props: rootProps,\n        classNames\n      } = useRecipeResult(props);\n      const className = classNames[slot];\n      const element = /* @__PURE__ */jsx(StylesProvider, {\n        value: styles,\n        children: /* @__PURE__ */jsx(ClassNamesProvider, {\n          value: classNames,\n          children: /* @__PURE__ */jsx(SuperComponent, {\n            ref,\n            ...rootProps,\n            css: [styles[slot], props.css],\n            className: cx(props.className, className)\n          })\n        })\n      });\n      return options2?.wrapElement?.(element, props) ?? element;\n    });\n    StyledComponent.displayName = Component.displayName || Component.name;\n    return StyledComponent;\n  };\n  const withContext = (Component, slot, options2) => {\n    const SuperComponent = chakra(Component, {}, options2);\n    const StyledComponent = forwardRef((props, ref) => {\n      const styles = useStyles();\n      const classNames = useClassNames();\n      const className = classNames?.[slot];\n      return /* @__PURE__ */jsx(SuperComponent, {\n        ...props,\n        css: [slot ? styles[slot] : void 0, props.css],\n        ref,\n        className: cx(props.className, className)\n      });\n    });\n    StyledComponent.displayName = Component.displayName || Component.name;\n    return StyledComponent;\n  };\n  return {\n    StylesProvider,\n    ClassNamesProvider,\n    PropsProvider,\n    usePropsContext,\n    useRecipeResult,\n    withProvider,\n    withContext,\n    withRootProvider,\n    useStyles,\n    useClassNames\n  };\n};\nexport { createSlotRecipeContext };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { mergeProps, createMachine, ref, guards } from '@zag-js/core';\nimport { createScope, queryAll, nextById, prevById, getByTypeahead, isHTMLElement, getEventPoint, isContextMenuEvent, getEventKey, isSelfTarget, getEventTarget, isValidTabEvent, isPrintableKey, isModifierKey, isEditableElement, isDownloadingEvent, isOpeningInNewTab, dataAttr, clickIfLink, addDomEvent, raf, observeAttributes, getInitialFocus, contains, scrollIntoView, isAnchorElement } from '@zag-js/dom-query';\nimport { getPlacementStyles, getPlacement, getPlacementSide } from '@zag-js/popper';\nimport { first, last, createSplitProps, compact, cast, isEqual } from '@zag-js/utils';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { isPointInPolygon, getElementPolygon } from '@zag-js/rect-utils';\nimport { createProps } from '@zag-js/types';\n\n// src/menu.anatomy.ts\nvar anatomy = createAnatomy(\"menu\").parts(\"arrow\", \"arrowTip\", \"content\", \"contextTrigger\", \"indicator\", \"item\", \"itemGroup\", \"itemGroupLabel\", \"itemIndicator\", \"itemText\", \"positioner\", \"separator\", \"trigger\", \"triggerItem\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getTriggerId: ctx => ctx.ids?.trigger ?? `menu:${ctx.id}:trigger`,\n  getContextTriggerId: ctx => ctx.ids?.contextTrigger ?? `menu:${ctx.id}:ctx-trigger`,\n  getContentId: ctx => ctx.ids?.content ?? `menu:${ctx.id}:content`,\n  getArrowId: ctx => ctx.ids?.arrow ?? `menu:${ctx.id}:arrow`,\n  getPositionerId: ctx => ctx.ids?.positioner ?? `menu:${ctx.id}:popper`,\n  getGroupId: (ctx, id) => ctx.ids?.group?.(id) ?? `menu:${ctx.id}:group:${id}`,\n  getGroupLabelId: (ctx, id) => ctx.ids?.groupLabel?.(id) ?? `menu:${ctx.id}:group-label:${id}`,\n  getContentEl: ctx => dom.getById(ctx, dom.getContentId(ctx)),\n  getPositionerEl: ctx => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getTriggerEl: ctx => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getHighlightedItemEl: ctx => ctx.highlightedValue ? dom.getById(ctx, ctx.highlightedValue) : null,\n  getArrowEl: ctx => dom.getById(ctx, dom.getArrowId(ctx)),\n  getElements: ctx => {\n    const ownerId = CSS.escape(dom.getContentId(ctx));\n    const selector = `[role^=\"menuitem\"][data-ownedby=${ownerId}]:not([data-disabled])`;\n    return queryAll(dom.getContentEl(ctx), selector);\n  },\n  getFirstEl: ctx => first(dom.getElements(ctx)),\n  getLastEl: ctx => last(dom.getElements(ctx)),\n  getNextEl: (ctx, loop) => nextById(dom.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),\n  getPrevEl: (ctx, loop) => prevById(dom.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),\n  getElemByKey: (ctx, key) => getByTypeahead(dom.getElements(ctx), {\n    state: ctx.typeaheadState,\n    key,\n    activeId: ctx.highlightedValue\n  }),\n  isTargetDisabled: v => {\n    return isHTMLElement(v) && (v.dataset.disabled === \"\" || v.hasAttribute(\"disabled\"));\n  },\n  isTriggerItem: el => {\n    return !!el?.getAttribute(\"role\")?.startsWith(\"menuitem\") && !!el?.hasAttribute(\"aria-controls\");\n  },\n  getOptionFromItemEl(el) {\n    return {\n      id: el.id,\n      name: el.dataset.name,\n      value: el.dataset.value,\n      valueText: el.dataset.valueText,\n      type: el.dataset.type\n    };\n  }\n});\n\n// src/menu.connect.ts\nfunction connect(state, send, normalize) {\n  const isSubmenu = state.context.isSubmenu;\n  const isTypingAhead = state.context.isTypingAhead;\n  const composite = state.context.composite;\n  const open = state.hasTag(\"open\");\n  const popperStyles = getPlacementStyles({\n    ...state.context.positioning,\n    placement: state.context.anchorPoint ? \"bottom\" : state.context.currentPlacement\n  });\n  function getItemState(props2) {\n    return {\n      disabled: !!props2.disabled,\n      highlighted: state.context.highlightedValue === props2.value\n    };\n  }\n  function getOptionItemProps(props2) {\n    const valueText = props2.valueText ?? props2.value;\n    return {\n      ...props2,\n      id: props2.value,\n      valueText\n    };\n  }\n  function getOptionItemState(props2) {\n    const itemState = getItemState(getOptionItemProps(props2));\n    return {\n      ...itemState,\n      checked: !!props2.checked\n    };\n  }\n  function getItemProps(props2) {\n    const {\n      value: id,\n      closeOnSelect,\n      valueText\n    } = props2;\n    const itemState = getItemState(props2);\n    return normalize.element({\n      ...parts.item.attrs,\n      id,\n      role: \"menuitem\",\n      \"aria-disabled\": itemState.disabled,\n      \"data-disabled\": dataAttr(itemState.disabled),\n      \"data-ownedby\": dom.getContentId(state.context),\n      \"data-highlighted\": dataAttr(itemState.highlighted),\n      \"data-valuetext\": valueText,\n      onDragStart(event) {\n        const isLink = event.currentTarget.matches(\"a[href]\");\n        if (isLink) event.preventDefault();\n      },\n      onPointerMove(event) {\n        if (itemState.disabled) return;\n        if (event.pointerType !== \"mouse\") return;\n        const target = event.currentTarget;\n        if (itemState.highlighted) return;\n        send({\n          type: \"ITEM_POINTERMOVE\",\n          id,\n          target,\n          closeOnSelect\n        });\n      },\n      onPointerLeave(event) {\n        if (itemState.disabled) return;\n        if (event.pointerType !== \"mouse\") return;\n        const pointerMoved = state.previousEvent.type.includes(\"POINTER\");\n        if (!pointerMoved) return;\n        const target = event.currentTarget;\n        send({\n          type: \"ITEM_POINTERLEAVE\",\n          id,\n          target,\n          closeOnSelect\n        });\n      },\n      onPointerDown(event) {\n        if (itemState.disabled) return;\n        const target = event.currentTarget;\n        send({\n          type: \"ITEM_POINTERDOWN\",\n          target,\n          id,\n          closeOnSelect\n        });\n      },\n      onClick(event) {\n        if (isDownloadingEvent(event)) return;\n        if (isOpeningInNewTab(event)) return;\n        if (itemState.disabled) return;\n        const target = event.currentTarget;\n        send({\n          type: \"ITEM_CLICK\",\n          target,\n          id,\n          closeOnSelect\n        });\n      }\n    });\n  }\n  return {\n    highlightedValue: state.context.highlightedValue,\n    open,\n    setOpen(nextOpen) {\n      if (nextOpen === open) return;\n      send(nextOpen ? \"OPEN\" : \"CLOSE\");\n    },\n    setHighlightedValue(value) {\n      send({\n        type: \"HIGHLIGHTED.SET\",\n        id: value\n      });\n    },\n    setParent(parent) {\n      send({\n        type: \"PARENT.SET\",\n        value: parent,\n        id: parent.state.context.id\n      });\n    },\n    setChild(child) {\n      send({\n        type: \"CHILD.SET\",\n        value: child,\n        id: child.state.context.id\n      });\n    },\n    reposition(options = {}) {\n      send({\n        type: \"POSITIONING.SET\",\n        options\n      });\n    },\n    getContextTriggerProps() {\n      return normalize.element({\n        ...parts.contextTrigger.attrs,\n        dir: state.context.dir,\n        id: dom.getContextTriggerId(state.context),\n        onPointerDown(event) {\n          if (event.pointerType === \"mouse\") return;\n          const point = getEventPoint(event);\n          send({\n            type: \"CONTEXT_MENU_START\",\n            point\n          });\n        },\n        onPointerCancel(event) {\n          if (event.pointerType === \"mouse\") return;\n          send(\"CONTEXT_MENU_CANCEL\");\n        },\n        onPointerMove(event) {\n          if (event.pointerType === \"mouse\") return;\n          send(\"CONTEXT_MENU_CANCEL\");\n        },\n        onPointerUp(event) {\n          if (event.pointerType === \"mouse\") return;\n          send(\"CONTEXT_MENU_CANCEL\");\n        },\n        onContextMenu(event) {\n          const point = getEventPoint(event);\n          send({\n            type: \"CONTEXT_MENU\",\n            point\n          });\n          event.preventDefault();\n        },\n        style: {\n          WebkitTouchCallout: \"none\",\n          WebkitUserSelect: \"none\",\n          userSelect: \"none\"\n        }\n      });\n    },\n    getTriggerItemProps(childApi) {\n      return mergeProps(getItemProps({\n        value: childApi.getTriggerProps().id\n      }), childApi.getTriggerProps());\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...(isSubmenu ? parts.triggerItem.attrs : parts.trigger.attrs),\n        \"data-placement\": state.context.currentPlacement,\n        type: \"button\",\n        dir: state.context.dir,\n        id: dom.getTriggerId(state.context),\n        \"data-uid\": state.context.id,\n        \"aria-haspopup\": composite ? \"menu\" : \"dialog\",\n        \"aria-controls\": dom.getContentId(state.context),\n        \"aria-expanded\": open || void 0,\n        \"data-state\": open ? \"open\" : \"closed\",\n        onPointerMove(event) {\n          if (event.pointerType !== \"mouse\") return;\n          const disabled = dom.isTargetDisabled(event.currentTarget);\n          if (disabled || !isSubmenu) return;\n          send({\n            type: \"TRIGGER_POINTERMOVE\",\n            target: event.currentTarget\n          });\n        },\n        onPointerLeave(event) {\n          if (dom.isTargetDisabled(event.currentTarget)) return;\n          if (event.pointerType !== \"mouse\") return;\n          if (!isSubmenu) return;\n          const point = getEventPoint(event);\n          send({\n            type: \"TRIGGER_POINTERLEAVE\",\n            target: event.currentTarget,\n            point\n          });\n        },\n        onPointerDown(event) {\n          if (dom.isTargetDisabled(event.currentTarget)) return;\n          if (isContextMenuEvent(event)) return;\n          event.preventDefault();\n        },\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (dom.isTargetDisabled(event.currentTarget)) return;\n          send({\n            type: \"TRIGGER_CLICK\",\n            target: event.currentTarget\n          });\n        },\n        onBlur() {\n          send(\"TRIGGER_BLUR\");\n        },\n        onFocus() {\n          send(\"TRIGGER_FOCUS\");\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          const keyMap = {\n            ArrowDown() {\n              send(\"ARROW_DOWN\");\n            },\n            ArrowUp() {\n              send(\"ARROW_UP\");\n            },\n            Enter() {\n              send({\n                type: \"ARROW_DOWN\",\n                src: \"enter\"\n              });\n            },\n            Space() {\n              send({\n                type: \"ARROW_DOWN\",\n                src: \"space\"\n              });\n            }\n          };\n          const key = getEventKey(event, state.context);\n          const exec = keyMap[key];\n          if (exec) {\n            event.preventDefault();\n            exec(event);\n          }\n        }\n      });\n    },\n    getIndicatorProps() {\n      return normalize.element({\n        ...parts.indicator.attrs,\n        dir: state.context.dir,\n        \"data-state\": open ? \"open\" : \"closed\"\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        ...parts.positioner.attrs,\n        dir: state.context.dir,\n        id: dom.getPositionerId(state.context),\n        style: popperStyles.floating\n      });\n    },\n    getArrowProps() {\n      return normalize.element({\n        id: dom.getArrowId(state.context),\n        ...parts.arrow.attrs,\n        dir: state.context.dir,\n        style: popperStyles.arrow\n      });\n    },\n    getArrowTipProps() {\n      return normalize.element({\n        ...parts.arrowTip.attrs,\n        dir: state.context.dir,\n        style: popperStyles.arrowTip\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        id: dom.getContentId(state.context),\n        \"aria-label\": state.context[\"aria-label\"],\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        role: composite ? \"menu\" : \"dialog\",\n        tabIndex: 0,\n        dir: state.context.dir,\n        \"aria-activedescendant\": state.context.highlightedValue ?? void 0,\n        \"aria-labelledby\": dom.getTriggerId(state.context),\n        \"data-placement\": state.context.currentPlacement,\n        onPointerEnter(event) {\n          if (event.pointerType !== \"mouse\") return;\n          send(\"MENU_POINTERENTER\");\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!isSelfTarget(event)) return;\n          const target = getEventTarget(event);\n          const sameMenu = target?.closest(\"[role=menu]\") === event.currentTarget || target === event.currentTarget;\n          if (!sameMenu) return;\n          if (event.key === \"Tab\") {\n            const valid = isValidTabEvent(event);\n            if (!valid) {\n              event.preventDefault();\n              return;\n            }\n          }\n          const item = dom.getHighlightedItemEl(state.context);\n          const keyMap = {\n            ArrowDown() {\n              send(\"ARROW_DOWN\");\n            },\n            ArrowUp() {\n              send(\"ARROW_UP\");\n            },\n            ArrowLeft() {\n              send(\"ARROW_LEFT\");\n            },\n            ArrowRight() {\n              send(\"ARROW_RIGHT\");\n            },\n            Enter() {\n              send(\"ENTER\");\n              if (isAnchorElement(item)) {\n                state.context.navigate({\n                  value: state.context.highlightedValue,\n                  node: item\n                });\n              }\n            },\n            Space(event2) {\n              if (isTypingAhead) {\n                send({\n                  type: \"TYPEAHEAD\",\n                  key: event2.key\n                });\n              } else {\n                keyMap.Enter?.(event2);\n              }\n            },\n            Home() {\n              send(\"HOME\");\n            },\n            End() {\n              send(\"END\");\n            }\n          };\n          const key = getEventKey(event, {\n            dir: state.context.dir\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.stopPropagation();\n            event.preventDefault();\n            return;\n          }\n          if (!state.context.typeahead) return;\n          if (!isPrintableKey(event)) return;\n          if (isModifierKey(event)) return;\n          if (isEditableElement(target)) return;\n          send({\n            type: \"TYPEAHEAD\",\n            key: event.key\n          });\n          event.preventDefault();\n        }\n      });\n    },\n    getSeparatorProps() {\n      return normalize.element({\n        ...parts.separator.attrs,\n        role: \"separator\",\n        dir: state.context.dir,\n        \"aria-orientation\": \"horizontal\"\n      });\n    },\n    getItemState,\n    getItemProps,\n    getOptionItemState,\n    getOptionItemProps(props2) {\n      const {\n        type,\n        disabled,\n        onCheckedChange,\n        closeOnSelect\n      } = props2;\n      const option = getOptionItemProps(props2);\n      const itemState = getOptionItemState(props2);\n      return {\n        ...getItemProps(option),\n        ...normalize.element({\n          \"data-type\": type,\n          ...parts.item.attrs,\n          dir: state.context.dir,\n          \"data-value\": option.value,\n          role: `menuitem${type}`,\n          \"aria-checked\": !!itemState.checked,\n          \"data-state\": itemState.checked ? \"checked\" : \"unchecked\",\n          onClick(event) {\n            if (disabled) return;\n            if (isDownloadingEvent(event)) return;\n            if (isOpeningInNewTab(event)) return;\n            const target = event.currentTarget;\n            send({\n              type: \"ITEM_CLICK\",\n              target,\n              option,\n              closeOnSelect\n            });\n            onCheckedChange?.(!itemState.checked);\n          }\n        })\n      };\n    },\n    getItemIndicatorProps(props2) {\n      const itemState = getOptionItemState(props2);\n      return normalize.element({\n        ...parts.itemIndicator.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        \"data-state\": itemState.checked ? \"checked\" : \"unchecked\",\n        hidden: !itemState.checked\n      });\n    },\n    getItemTextProps(props2) {\n      const itemState = getOptionItemState(props2);\n      return normalize.element({\n        ...parts.itemText.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        \"data-state\": itemState.checked ? \"checked\" : \"unchecked\"\n      });\n    },\n    getItemGroupLabelProps(props2) {\n      return normalize.element({\n        id: dom.getGroupLabelId(state.context, props2.htmlFor),\n        dir: state.context.dir,\n        ...parts.itemGroupLabel.attrs\n      });\n    },\n    getItemGroupProps(props2) {\n      return normalize.element({\n        id: dom.getGroupId(state.context, props2.id),\n        ...parts.itemGroup.attrs,\n        dir: state.context.dir,\n        \"aria-labelledby\": dom.getGroupLabelId(state.context, props2.id),\n        role: \"group\"\n      });\n    }\n  };\n}\nvar {\n  not,\n  and,\n  or\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"menu\",\n    initial: ctx.open ? \"open\" : \"idle\",\n    context: {\n      highlightedValue: null,\n      loopFocus: false,\n      anchorPoint: null,\n      closeOnSelect: true,\n      typeahead: true,\n      composite: true,\n      navigate(details) {\n        clickIfLink(details.node);\n      },\n      ...ctx,\n      positioning: {\n        placement: \"bottom-start\",\n        gutter: 8,\n        ...ctx.positioning\n      },\n      intentPolygon: null,\n      parent: null,\n      lastHighlightedValue: null,\n      children: cast(ref({})),\n      suspendPointer: false,\n      typeaheadState: getByTypeahead.defaultOptions\n    },\n    computed: {\n      isSubmenu: ctx2 => ctx2.parent !== null,\n      isRtl: ctx2 => ctx2.dir === \"rtl\",\n      isTypingAhead: ctx2 => ctx2.typeaheadState.keysSoFar !== \"\"\n    },\n    watch: {\n      isSubmenu: \"setSubmenuPlacement\",\n      anchorPoint: \"reposition\",\n      open: \"toggleVisibility\"\n    },\n    on: {\n      \"PARENT.SET\": {\n        actions: \"setParentMenu\"\n      },\n      \"CHILD.SET\": {\n        actions: \"setChildMenu\"\n      },\n      OPEN: [{\n        guard: \"isOpenControlled\",\n        actions: \"invokeOnOpen\"\n      }, {\n        target: \"open\",\n        actions: \"invokeOnOpen\"\n      }],\n      OPEN_AUTOFOCUS: [{\n        guard: \"isOpenControlled\",\n        actions: [\"invokeOnOpen\"]\n      }, {\n        internal: true,\n        target: \"open\",\n        actions: [\"highlightFirstItem\", \"invokeOnOpen\"]\n      }],\n      CLOSE: [{\n        guard: \"isOpenControlled\",\n        actions: \"invokeOnClose\"\n      }, {\n        target: \"closed\",\n        actions: \"invokeOnClose\"\n      }],\n      \"HIGHLIGHTED.RESTORE\": {\n        actions: \"restoreHighlightedItem\"\n      },\n      \"HIGHLIGHTED.SET\": {\n        actions: \"setHighlightedItem\"\n      }\n    },\n    states: {\n      idle: {\n        tags: [\"closed\"],\n        on: {\n          \"CONTROLLED.OPEN\": \"open\",\n          \"CONTROLLED.CLOSE\": \"closed\",\n          CONTEXT_MENU_START: {\n            target: \"opening:contextmenu\",\n            actions: \"setAnchorPoint\"\n          },\n          CONTEXT_MENU: [{\n            guard: \"isOpenControlled\",\n            actions: [\"setAnchorPoint\", \"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"setAnchorPoint\", \"invokeOnOpen\"]\n          }],\n          TRIGGER_CLICK: [{\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnOpen\"\n          }, {\n            target: \"open\",\n            actions: \"invokeOnOpen\"\n          }],\n          TRIGGER_FOCUS: {\n            guard: not(\"isSubmenu\"),\n            target: \"closed\"\n          },\n          TRIGGER_POINTERMOVE: {\n            guard: \"isSubmenu\",\n            target: \"opening\"\n          }\n        }\n      },\n      \"opening:contextmenu\": {\n        tags: [\"closed\"],\n        after: {\n          LONG_PRESS_DELAY: [{\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnOpen\"\n          }, {\n            target: \"open\",\n            actions: \"invokeOnOpen\"\n          }]\n        },\n        on: {\n          \"CONTROLLED.OPEN\": \"open\",\n          \"CONTROLLED.CLOSE\": \"closed\",\n          CONTEXT_MENU_CANCEL: [{\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnClose\"\n          }, {\n            target: \"closed\",\n            actions: \"invokeOnClose\"\n          }]\n        }\n      },\n      opening: {\n        tags: [\"closed\"],\n        after: {\n          SUBMENU_OPEN_DELAY: [{\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnOpen\"\n          }, {\n            target: \"open\",\n            actions: \"invokeOnOpen\"\n          }]\n        },\n        on: {\n          \"CONTROLLED.OPEN\": \"open\",\n          \"CONTROLLED.CLOSE\": \"closed\",\n          BLUR: [{\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnClose\"\n          }, {\n            target: \"closed\",\n            actions: \"invokeOnClose\"\n          }],\n          TRIGGER_POINTERLEAVE: [{\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnClose\"\n          }, {\n            target: \"closed\",\n            actions: \"invokeOnClose\"\n          }]\n        }\n      },\n      closing: {\n        tags: [\"open\"],\n        activities: [\"trackPointerMove\", \"trackInteractOutside\"],\n        after: {\n          SUBMENU_CLOSE_DELAY: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"closed\",\n            actions: [\"focusParentMenu\", \"restoreParentHighlightedItem\", \"invokeOnClose\"]\n          }]\n        },\n        on: {\n          \"CONTROLLED.OPEN\": \"open\",\n          \"CONTROLLED.CLOSE\": {\n            target: \"closed\",\n            actions: [\"focusParentMenu\", \"restoreParentHighlightedItem\"]\n          },\n          // don't invoke on open here since the menu is still open (we're only keeping it open)\n          MENU_POINTERENTER: {\n            target: \"open\",\n            actions: \"clearIntentPolygon\"\n          },\n          POINTER_MOVED_AWAY_FROM_SUBMENU: [{\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnClose\"\n          }, {\n            target: \"closed\",\n            actions: [\"focusParentMenu\", \"restoreParentHighlightedItem\"]\n          }]\n        }\n      },\n      closed: {\n        tags: [\"closed\"],\n        entry: [\"clearHighlightedItem\", \"focusTrigger\", \"resumePointer\"],\n        on: {\n          \"CONTROLLED.OPEN\": [{\n            guard: or(\"isOpenAutoFocusEvent\", \"isArrowDownEvent\"),\n            target: \"open\",\n            actions: \"highlightFirstItem\"\n          }, {\n            guard: \"isArrowUpEvent\",\n            target: \"open\",\n            actions: \"highlightLastItem\"\n          }, {\n            target: \"open\"\n          }],\n          CONTEXT_MENU_START: {\n            target: \"opening:contextmenu\",\n            actions: \"setAnchorPoint\"\n          },\n          CONTEXT_MENU: [{\n            guard: \"isOpenControlled\",\n            actions: [\"setAnchorPoint\", \"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"setAnchorPoint\", \"invokeOnOpen\"]\n          }],\n          TRIGGER_CLICK: [{\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnOpen\"\n          }, {\n            target: \"open\",\n            actions: \"invokeOnOpen\"\n          }],\n          TRIGGER_POINTERMOVE: {\n            guard: \"isTriggerItem\",\n            target: \"opening\"\n          },\n          TRIGGER_BLUR: \"idle\",\n          ARROW_DOWN: [{\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnOpen\"\n          }, {\n            target: \"open\",\n            actions: [\"highlightFirstItem\", \"invokeOnOpen\"]\n          }],\n          ARROW_UP: [{\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnOpen\"\n          }, {\n            target: \"open\",\n            actions: [\"highlightLastItem\", \"invokeOnOpen\"]\n          }]\n        }\n      },\n      open: {\n        tags: [\"open\"],\n        activities: [\"trackInteractOutside\", \"trackPositioning\", \"scrollToHighlightedItem\"],\n        entry: [\"focusMenu\", \"resumePointer\"],\n        on: {\n          \"CONTROLLED.CLOSE\": [{\n            target: \"closed\",\n            guard: \"isArrowLeftEvent\",\n            actions: [\"focusParentMenu\"]\n          }, {\n            target: \"closed\"\n          }],\n          TRIGGER_CLICK: [{\n            guard: and(not(\"isTriggerItem\"), \"isOpenControlled\"),\n            actions: \"invokeOnClose\"\n          }, {\n            guard: not(\"isTriggerItem\"),\n            target: \"closed\",\n            actions: \"invokeOnClose\"\n          }],\n          ARROW_UP: {\n            actions: [\"highlightPrevItem\", \"focusMenu\"]\n          },\n          ARROW_DOWN: {\n            actions: [\"highlightNextItem\", \"focusMenu\"]\n          },\n          ARROW_LEFT: [{\n            guard: and(\"isSubmenu\", \"isOpenControlled\"),\n            actions: \"invokeOnClose\"\n          }, {\n            guard: \"isSubmenu\",\n            target: \"closed\",\n            actions: [\"focusParentMenu\", \"invokeOnClose\"]\n          }],\n          HOME: {\n            actions: [\"highlightFirstItem\", \"focusMenu\"]\n          },\n          END: {\n            actions: [\"highlightLastItem\", \"focusMenu\"]\n          },\n          ARROW_RIGHT: {\n            guard: \"isTriggerItemHighlighted\",\n            actions: \"openSubmenu\"\n          },\n          ENTER: [{\n            guard: \"isTriggerItemHighlighted\",\n            actions: \"openSubmenu\"\n          }, {\n            actions: \"clickHighlightedItem\"\n          }],\n          ITEM_POINTERMOVE: [{\n            guard: not(\"suspendPointer\"),\n            actions: [\"setHighlightedItem\", \"focusMenu\"]\n          }, {\n            actions: \"setLastHighlightedItem\"\n          }],\n          ITEM_POINTERLEAVE: {\n            guard: and(not(\"suspendPointer\"), not(\"isTriggerItem\")),\n            actions: \"clearHighlightedItem\"\n          },\n          ITEM_CLICK: [\n          // == grouped ==\n          {\n            guard: and(not(\"isTriggerItemHighlighted\"), not(\"isHighlightedItemEditable\"), \"closeOnSelect\", \"isOpenControlled\"),\n            actions: [\"invokeOnSelect\", \"setOptionState\", \"closeRootMenu\", \"invokeOnClose\"]\n          }, {\n            guard: and(not(\"isTriggerItemHighlighted\"), not(\"isHighlightedItemEditable\"), \"closeOnSelect\"),\n            target: \"closed\",\n            actions: [\"invokeOnSelect\", \"setOptionState\", \"closeRootMenu\", \"invokeOnClose\"]\n          },\n          //\n          {\n            guard: and(not(\"isTriggerItemHighlighted\"), not(\"isHighlightedItemEditable\")),\n            actions: [\"invokeOnSelect\", \"setOptionState\"]\n          }, {\n            actions: \"setHighlightedItem\"\n          }],\n          TRIGGER_POINTERLEAVE: {\n            target: \"closing\",\n            actions: \"setIntentPolygon\"\n          },\n          ITEM_POINTERDOWN: {\n            actions: \"setHighlightedItem\"\n          },\n          TYPEAHEAD: {\n            actions: \"highlightMatchedItem\"\n          },\n          FOCUS_MENU: {\n            actions: \"focusMenu\"\n          },\n          \"POSITIONING.SET\": {\n            actions: \"reposition\"\n          }\n        }\n      }\n    }\n  }, {\n    delays: {\n      LONG_PRESS_DELAY: 700,\n      SUBMENU_OPEN_DELAY: 100,\n      SUBMENU_CLOSE_DELAY: 100\n    },\n    guards: {\n      closeOnSelect: (ctx2, evt) => !!(evt?.closeOnSelect ?? ctx2.closeOnSelect),\n      // whether the trigger is also a menu item\n      isTriggerItem: (_ctx, evt) => dom.isTriggerItem(evt.target),\n      // whether the trigger item is the active item\n      isTriggerItemHighlighted: (ctx2, evt) => {\n        const target = evt.target ?? dom.getHighlightedItemEl(ctx2);\n        return !!target?.hasAttribute(\"aria-controls\");\n      },\n      isSubmenu: ctx2 => ctx2.isSubmenu,\n      suspendPointer: ctx2 => ctx2.suspendPointer,\n      isHighlightedItemEditable: ctx2 => isEditableElement(dom.getHighlightedItemEl(ctx2)),\n      isWithinPolygon: (ctx2, evt) => {\n        if (!ctx2.intentPolygon) return false;\n        return isPointInPolygon(ctx2.intentPolygon, evt.point);\n      },\n      // guard assertions (for controlled mode)\n      isOpenControlled: ctx2 => !!ctx2[\"open.controlled\"],\n      isArrowLeftEvent: (_ctx, evt) => evt.previousEvent?.type === \"ARROW_LEFT\",\n      isArrowUpEvent: (_ctx, evt) => evt.previousEvent?.type === \"ARROW_UP\",\n      isArrowDownEvent: (_ctx, evt) => evt.previousEvent?.type === \"ARROW_DOWN\",\n      isOpenAutoFocusEvent: (_ctx, evt) => evt.previousEvent?.type === \"OPEN_AUTOFOCUS\"\n    },\n    activities: {\n      trackPositioning(ctx2) {\n        if (ctx2.anchorPoint) return;\n        ctx2.currentPlacement = ctx2.positioning.placement;\n        const getPositionerEl = () => dom.getPositionerEl(ctx2);\n        return getPlacement(dom.getTriggerEl(ctx2), getPositionerEl, {\n          ...ctx2.positioning,\n          defer: true,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      trackInteractOutside(ctx2, _evt, {\n        send\n      }) {\n        const getContentEl = () => dom.getContentEl(ctx2);\n        let restoreFocus = true;\n        return trackDismissableElement(getContentEl, {\n          defer: true,\n          exclude: [dom.getTriggerEl(ctx2)],\n          onInteractOutside: ctx2.onInteractOutside,\n          onFocusOutside: ctx2.onFocusOutside,\n          onEscapeKeyDown(event) {\n            ctx2.onEscapeKeyDown?.(event);\n            if (ctx2.isSubmenu) event.preventDefault();\n            closeRootMenu(ctx2);\n          },\n          onPointerDownOutside(event) {\n            restoreFocus = !event.detail.focusable;\n            ctx2.onPointerDownOutside?.(event);\n          },\n          onDismiss() {\n            send({\n              type: \"CLOSE\",\n              src: \"interact-outside\",\n              restoreFocus\n            });\n          }\n        });\n      },\n      trackPointerMove(ctx2, _evt, {\n        guards: guards2,\n        send\n      }) {\n        const {\n          isWithinPolygon\n        } = guards2;\n        ctx2.parent.state.context.suspendPointer = true;\n        const doc = dom.getDoc(ctx2);\n        return addDomEvent(doc, \"pointermove\", e => {\n          const point = {\n            x: e.clientX,\n            y: e.clientY\n          };\n          const isMovingToSubmenu = isWithinPolygon(ctx2, {\n            point\n          });\n          if (!isMovingToSubmenu) {\n            send(\"POINTER_MOVED_AWAY_FROM_SUBMENU\");\n            ctx2.parent.state.context.suspendPointer = false;\n          }\n        });\n      },\n      scrollToHighlightedItem(ctx2, _evt, {\n        getState\n      }) {\n        const exec = () => {\n          const state = getState();\n          if (state.event.type.startsWith(\"ITEM_POINTER\")) return;\n          const itemEl = dom.getHighlightedItemEl(ctx2);\n          const contentEl2 = dom.getContentEl(ctx2);\n          scrollIntoView(itemEl, {\n            rootEl: contentEl2,\n            block: \"nearest\"\n          });\n        };\n        raf(() => exec());\n        const contentEl = () => dom.getContentEl(ctx2);\n        return observeAttributes(contentEl, {\n          defer: true,\n          attributes: [\"aria-activedescendant\"],\n          callback: exec\n        });\n      }\n    },\n    actions: {\n      setAnchorPoint(ctx2, evt) {\n        ctx2.anchorPoint = evt.point;\n      },\n      setSubmenuPlacement(ctx2) {\n        if (!ctx2.isSubmenu) return;\n        ctx2.positioning.placement = ctx2.isRtl ? \"left-start\" : \"right-start\";\n        ctx2.positioning.gutter = 0;\n      },\n      reposition(ctx2, evt) {\n        const getPositionerEl = () => dom.getPositionerEl(ctx2);\n        const getAnchorRect = ctx2.anchorPoint ? () => ({\n          width: 0,\n          height: 0,\n          ...ctx2.anchorPoint\n        }) : void 0;\n        getPlacement(dom.getTriggerEl(ctx2), getPositionerEl, {\n          ...ctx2.positioning,\n          defer: true,\n          getAnchorRect,\n          ...(evt.options ?? {}),\n          listeners: false,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      setOptionState(_ctx, evt) {\n        if (!evt.option) return;\n        const {\n          checked,\n          onCheckedChange,\n          type\n        } = evt.option;\n        if (type === \"radio\") {\n          onCheckedChange?.(true);\n        } else if (type === \"checkbox\") {\n          onCheckedChange?.(!checked);\n        }\n      },\n      clickHighlightedItem(ctx2, _evt) {\n        const itemEl = dom.getHighlightedItemEl(ctx2);\n        if (!itemEl || itemEl.dataset.disabled) return;\n        queueMicrotask(() => itemEl.click());\n      },\n      setIntentPolygon(ctx2, evt) {\n        const menu = dom.getContentEl(ctx2);\n        const placement = ctx2.currentPlacement;\n        if (!menu || !placement) return;\n        const rect = menu.getBoundingClientRect();\n        const polygon = getElementPolygon(rect, placement);\n        if (!polygon) return;\n        const rightSide = getPlacementSide(placement) === \"right\";\n        const bleed = rightSide ? -5 : 5;\n        ctx2.intentPolygon = [{\n          ...evt.point,\n          x: evt.point.x + bleed\n        }, ...polygon];\n      },\n      clearIntentPolygon(ctx2) {\n        ctx2.intentPolygon = null;\n      },\n      resumePointer(ctx2) {\n        if (!ctx2.parent) return;\n        ctx2.parent.state.context.suspendPointer = false;\n      },\n      setHighlightedItem(ctx2, evt) {\n        set.highlighted(ctx2, evt.id);\n      },\n      clearHighlightedItem(ctx2) {\n        set.highlighted(ctx2, null);\n      },\n      focusMenu(ctx2) {\n        raf(() => {\n          const contentEl = dom.getContentEl(ctx2);\n          const initialFocusEl = getInitialFocus({\n            root: contentEl,\n            enabled: !contains(contentEl, dom.getActiveElement(ctx2)),\n            filter(node) {\n              return !node.role?.startsWith(\"menuitem\");\n            }\n          });\n          initialFocusEl?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      highlightFirstItem(ctx2) {\n        const fn = !!dom.getContentEl(ctx2) ? queueMicrotask : raf;\n        fn(() => {\n          const first2 = dom.getFirstEl(ctx2);\n          if (!first2) return;\n          set.highlighted(ctx2, first2.id);\n        });\n      },\n      highlightLastItem(ctx2) {\n        const fn = !!dom.getContentEl(ctx2) ? queueMicrotask : raf;\n        fn(() => {\n          const last2 = dom.getLastEl(ctx2);\n          if (!last2) return;\n          set.highlighted(ctx2, last2.id);\n        });\n      },\n      highlightNextItem(ctx2, evt) {\n        const next = dom.getNextEl(ctx2, evt.loop);\n        set.highlighted(ctx2, next?.id ?? null);\n      },\n      highlightPrevItem(ctx2, evt) {\n        const prev = dom.getPrevEl(ctx2, evt.loop);\n        set.highlighted(ctx2, prev?.id ?? null);\n      },\n      invokeOnSelect(ctx2) {\n        if (!ctx2.highlightedValue) return;\n        ctx2.onSelect?.({\n          value: ctx2.highlightedValue\n        });\n      },\n      focusTrigger(ctx2, evt) {\n        if (ctx2.isSubmenu || ctx2.anchorPoint || evt.restoreFocus === false) return;\n        queueMicrotask(() => dom.getTriggerEl(ctx2)?.focus({\n          preventScroll: true\n        }));\n      },\n      highlightMatchedItem(ctx2, evt) {\n        const node = dom.getElemByKey(ctx2, evt.key);\n        if (!node) return;\n        set.highlighted(ctx2, node.id);\n      },\n      setParentMenu(ctx2, evt) {\n        ctx2.parent = ref(evt.value);\n      },\n      setChildMenu(ctx2, evt) {\n        ctx2.children[evt.id] = ref(evt.value);\n      },\n      closeRootMenu(ctx2) {\n        closeRootMenu(ctx2);\n      },\n      openSubmenu(ctx2) {\n        const item = dom.getHighlightedItemEl(ctx2);\n        const id = item?.getAttribute(\"data-uid\");\n        const child = id ? ctx2.children[id] : null;\n        child?.send(\"OPEN_AUTOFOCUS\");\n      },\n      focusParentMenu(ctx2) {\n        ctx2.parent?.send(\"FOCUS_MENU\");\n      },\n      setLastHighlightedItem(ctx2, evt) {\n        ctx2.lastHighlightedValue = evt.id;\n      },\n      restoreHighlightedItem(ctx2) {\n        if (!ctx2.lastHighlightedValue) return;\n        set.highlighted(ctx2, ctx2.lastHighlightedValue);\n        ctx2.lastHighlightedValue = null;\n      },\n      restoreParentHighlightedItem(ctx2) {\n        ctx2.parent?.send(\"HIGHLIGHTED.RESTORE\");\n      },\n      invokeOnOpen(ctx2) {\n        ctx2.onOpenChange?.({\n          open: true\n        });\n      },\n      invokeOnClose(ctx2) {\n        ctx2.onOpenChange?.({\n          open: false\n        });\n      },\n      toggleVisibility(ctx2, evt, {\n        send\n      }) {\n        send({\n          type: ctx2.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: evt\n        });\n      }\n    }\n  });\n}\nfunction closeRootMenu(ctx) {\n  let parent = ctx.parent;\n  while (parent && parent.state.context.isSubmenu) {\n    parent = parent.state.context.parent;\n  }\n  parent?.send(\"CLOSE\");\n}\nvar set = {\n  highlighted(ctx, value) {\n    if (isEqual(ctx.highlightedValue, value)) return;\n    ctx.highlightedValue = value;\n    ctx.onHighlightChange?.({\n      highlightedValue: value\n    });\n  }\n};\nvar props = createProps()([\"anchorPoint\", \"aria-label\", \"closeOnSelect\", \"composite\", \"dir\", \"getRootNode\", \"highlightedValue\", \"id\", \"ids\", \"loopFocus\", \"navigate\", \"onEscapeKeyDown\", \"onFocusOutside\", \"onHighlightChange\", \"onInteractOutside\", \"onOpenChange\", \"onPointerDownOutside\", \"onSelect\", \"open.controlled\", \"open\", \"positioning\", \"typeahead\"]);\nvar splitProps = createSplitProps(props);\nvar itemProps = createProps()([\"closeOnSelect\", \"disabled\", \"value\", \"valueText\"]);\nvar splitItemProps = createSplitProps(itemProps);\nvar itemGroupLabelProps = createProps()([\"htmlFor\"]);\nvar splitItemGroupLabelProps = createSplitProps(itemGroupLabelProps);\nvar itemGroupProps = createProps()([\"id\"]);\nvar splitItemGroupProps = createSplitProps(itemGroupProps);\nvar optionItemProps = createProps()([\"disabled\", \"valueText\", \"closeOnSelect\", \"type\", \"value\", \"checked\", \"onCheckedChange\"]);\nvar splitOptionItemProps = createSplitProps(optionItemProps);\nexport { anatomy, connect, itemGroupLabelProps, itemGroupProps, itemProps, machine, optionItemProps, props, splitItemGroupLabelProps, splitItemGroupProps, splitItemProps, splitOptionItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
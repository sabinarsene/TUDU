{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { DateFormatter, isEqualDay, CalendarDate, parseDate, isToday, isWeekend } from '@internationalized/date';\nimport { getDateRangePreset, getDaysInWeek, getWeekDays, getTodayDate, constrainValue, getDecadeRange, getEndDate, isPreviousVisibleRangeInvalid, isNextVisibleRangeInvalid, formatSelectedDate, isDateEqual, getNextPage, getPreviousPage, getNextSection, getPreviousSection, isDateOutsideVisibleRange, alignDate, getAdjustedDateFn, getMonthDays, getMonthNames, getYearsRange, isDateUnavailable, getMonthFormatter, isDateInvalid, getDayFormatter, getUnitDuration, isDateDisabled, parseDateString } from '@zag-js/date-utils';\nimport { createScope, query, queryAll, dataAttr, ariaAttr, getEventKey, getNativeEvent, disableTextSelection, restoreTextSelection, raf, isComposingEvent } from '@zag-js/dom-query';\nimport { getPlacementStyles, getPlacement } from '@zag-js/popper';\nimport { createSplitProps, chunk, compact, isEqual, match, isValueWithinRange, clampValue } from '@zag-js/utils';\nimport { createMachine, guards } from '@zag-js/core';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { createLiveRegion } from '@zag-js/live-region';\nimport { createProps } from '@zag-js/types';\n\n// src/date-picker.anatomy.ts\nvar anatomy = createAnatomy(\"date-picker\").parts(\"root\", \"label\", \"clearTrigger\", \"content\", \"control\", \"input\", \"monthSelect\", \"nextTrigger\", \"positioner\", \"prevTrigger\", \"rangeText\", \"table\", \"tableBody\", \"tableCell\", \"tableCellTrigger\", \"tableHead\", \"tableHeader\", \"tableRow\", \"trigger\", \"viewTrigger\", \"viewControl\", \"yearSelect\", \"presetTrigger\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getLabelId: (ctx, index) => ctx.ids?.label?.(index) ?? `datepicker:${ctx.id}:label:${index}`,\n  getRootId: ctx => ctx.ids?.root ?? `datepicker:${ctx.id}`,\n  getTableId: (ctx, id) => ctx.ids?.table?.(id) ?? `datepicker:${ctx.id}:table:${id}`,\n  getTableHeaderId: (ctx, id) => ctx.ids?.tableHeader?.(id) ?? `datepicker:${ctx.id}:thead`,\n  getTableBodyId: (ctx, id) => ctx.ids?.tableBody?.(id) ?? `datepicker:${ctx.id}:tbody`,\n  getTableRowId: (ctx, id) => ctx.ids?.tableRow?.(id) ?? `datepicker:${ctx.id}:tr:${id}`,\n  getContentId: ctx => ctx.ids?.content ?? `datepicker:${ctx.id}:content`,\n  getCellTriggerId: (ctx, id) => ctx.ids?.cellTrigger?.(id) ?? `datepicker:${ctx.id}:cell-trigger:${id}`,\n  getPrevTriggerId: (ctx, view) => ctx.ids?.prevTrigger?.(view) ?? `datepicker:${ctx.id}:prev:${view}`,\n  getNextTriggerId: (ctx, view) => ctx.ids?.nextTrigger?.(view) ?? `datepicker:${ctx.id}:next:${view}`,\n  getViewTriggerId: (ctx, view) => ctx.ids?.viewTrigger?.(view) ?? `datepicker:${ctx.id}:view:${view}`,\n  getClearTriggerId: ctx => ctx.ids?.clearTrigger ?? `datepicker:${ctx.id}:clear`,\n  getControlId: ctx => ctx.ids?.control ?? `datepicker:${ctx.id}:control`,\n  getInputId: (ctx, index) => ctx.ids?.input?.(index) ?? `datepicker:${ctx.id}:input:${index}`,\n  getTriggerId: ctx => ctx.ids?.trigger ?? `datepicker:${ctx.id}:trigger`,\n  getPositionerId: ctx => ctx.ids?.positioner ?? `datepicker:${ctx.id}:positioner`,\n  getMonthSelectId: ctx => ctx.ids?.monthSelect ?? `datepicker:${ctx.id}:month-select`,\n  getYearSelectId: ctx => ctx.ids?.yearSelect ?? `datepicker:${ctx.id}:year-select`,\n  getFocusedCell: (ctx, view = ctx.view) => query(dom.getContentEl(ctx), `[data-part=table-cell-trigger][data-view=${view}][data-focus]:not([data-outside-range])`),\n  getTriggerEl: ctx => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getContentEl: ctx => dom.getById(ctx, dom.getContentId(ctx)),\n  getInputEls: ctx => queryAll(dom.getControlEl(ctx), `[data-part=input]`),\n  getYearSelectEl: ctx => dom.getById(ctx, dom.getYearSelectId(ctx)),\n  getMonthSelectEl: ctx => dom.getById(ctx, dom.getMonthSelectId(ctx)),\n  getClearTriggerEl: ctx => dom.getById(ctx, dom.getClearTriggerId(ctx)),\n  getPositionerEl: ctx => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getControlEl: ctx => dom.getById(ctx, dom.getControlId(ctx))\n});\nfunction adjustStartAndEndDate(value) {\n  const [startDate, endDate] = value;\n  if (!startDate || !endDate) return value;\n  return startDate.compare(endDate) <= 0 ? value : [endDate, startDate];\n}\nfunction isDateWithinRange(date, value) {\n  const [startDate, endDate] = value;\n  if (!startDate || !endDate) return false;\n  return startDate.compare(date) <= 0 && endDate.compare(date) >= 0;\n}\nfunction sortDates(values) {\n  return values.sort((a, b) => a.compare(b));\n}\nfunction getRoleDescription(view) {\n  return match(view, {\n    year: \"calendar decade\",\n    month: \"calendar year\",\n    day: \"calendar month\"\n  });\n}\nvar PLACEHOLDERS = {\n  day: \"dd\",\n  month: \"mm\",\n  year: \"yyyy\"\n};\nfunction getInputPlaceholder(locale) {\n  return new DateFormatter(locale).formatToParts(/* @__PURE__ */new Date()).map(item => PLACEHOLDERS[item.type] ?? item.value).join(\"\");\n}\nvar isValidCharacter = (char, separator) => {\n  if (!char) return true;\n  return /\\d/.test(char) || char === separator || char.length !== 1;\n};\nvar isValidDate = value => {\n  return !Number.isNaN(value.day) && !Number.isNaN(value.month) && !Number.isNaN(value.year);\n};\nvar ensureValidCharacters = (value, separator) => {\n  return value.split(\"\").filter(char => isValidCharacter(char, separator)).join(\"\");\n};\nfunction getLocaleSeparator(locale) {\n  const dateFormatter = new Intl.DateTimeFormat(locale);\n  const parts2 = dateFormatter.formatToParts(/* @__PURE__ */new Date());\n  const literalPart = parts2.find(part => part.type === \"literal\");\n  return literalPart ? literalPart.value : \"/\";\n}\nvar defaultTranslations = {\n  dayCell(state) {\n    if (state.unavailable) return `Not available. ${state.formattedDate}`;\n    if (state.selected) return `Selected date. ${state.formattedDate}`;\n    return `Choose ${state.formattedDate}`;\n  },\n  trigger(open) {\n    return open ? \"Close calendar\" : \"Open calendar\";\n  },\n  viewTrigger(view) {\n    return match(view, {\n      year: \"Switch to month view\",\n      month: \"Switch to day view\",\n      day: \"Switch to year view\"\n    });\n  },\n  presetTrigger(value) {\n    return Array.isArray(value) ? `select ${value[0].toString()} to ${value[1].toString()}` : `select ${value}`;\n  },\n  prevTrigger(view) {\n    return match(view, {\n      year: \"Switch to previous decade\",\n      month: \"Switch to previous year\",\n      day: \"Switch to previous month\"\n    });\n  },\n  nextTrigger(view) {\n    return match(view, {\n      year: \"Switch to next decade\",\n      month: \"Switch to next year\",\n      day: \"Switch to next month\"\n    });\n  },\n  // TODO: Revisit this\n  placeholder() {\n    return {\n      day: \"dd\",\n      month: \"mm\",\n      year: \"yyyy\"\n    };\n  },\n  content: \"calendar\",\n  monthSelect: \"Select month\",\n  yearSelect: \"Select year\",\n  clearTrigger: \"Clear selected dates\"\n};\nfunction viewToNumber(view, fallback) {\n  if (!view) return fallback || 0;\n  return view === \"day\" ? 0 : view === \"month\" ? 1 : 2;\n}\nfunction viewNumberToView(viewNumber) {\n  return viewNumber === 0 ? \"day\" : viewNumber === 1 ? \"month\" : \"year\";\n}\nfunction clampView(view, minView, maxView) {\n  return viewNumberToView(clampValue(viewToNumber(view, 0), viewToNumber(minView, 0), viewToNumber(maxView, 2)));\n}\nfunction isAboveMinView(view, minView) {\n  return viewToNumber(view, 0) > viewToNumber(minView, 0);\n}\nfunction isBelowMinView(view, minView) {\n  return viewToNumber(view, 0) < viewToNumber(minView, 0);\n}\nfunction getNextView(view, minView, maxView) {\n  const nextViewNumber = viewToNumber(view, 0) + 1;\n  return clampView(viewNumberToView(nextViewNumber), minView, maxView);\n}\nfunction getPreviousView(view, minView, maxView) {\n  const prevViewNumber = viewToNumber(view, 0) - 1;\n  return clampView(viewNumberToView(prevViewNumber), minView, maxView);\n}\nvar views = [\"day\", \"month\", \"year\"];\nfunction eachView(cb) {\n  views.forEach(view => cb(view));\n}\n\n// src/date-picker.connect.ts\nfunction connect(state, send, normalize) {\n  const startValue = state.context.startValue;\n  const endValue = state.context.endValue;\n  const selectedValue = state.context.value;\n  const focusedValue = state.context.focusedValue;\n  const hoveredValue = state.context.hoveredValue;\n  const hoveredRangeValue = hoveredValue ? adjustStartAndEndDate([selectedValue[0], hoveredValue]) : [];\n  const disabled = state.context.disabled;\n  const readOnly = state.context.readOnly;\n  const interactive = state.context.isInteractive;\n  const min = state.context.min;\n  const max = state.context.max;\n  const locale = state.context.locale;\n  const timeZone = state.context.timeZone;\n  const startOfWeek = state.context.startOfWeek;\n  const focused = state.matches(\"focused\");\n  const open = state.matches(\"open\");\n  const isRangePicker = state.context.selectionMode === \"range\";\n  const isDateUnavailableFn = state.context.isDateUnavailable;\n  const currentPlacement = state.context.currentPlacement;\n  const popperStyles = getPlacementStyles({\n    ...state.context.positioning,\n    placement: currentPlacement\n  });\n  const separator = getLocaleSeparator(locale);\n  function getMonthWeeks(from = startValue) {\n    const numOfWeeks = state.context.fixedWeeks ? 6 : void 0;\n    return getMonthDays(from, locale, numOfWeeks, startOfWeek);\n  }\n  function getMonths(props2 = {}) {\n    const {\n      format\n    } = props2;\n    return getMonthNames(locale, format).map((label, index) => ({\n      label,\n      value: index + 1\n    }));\n  }\n  function getYears() {\n    const range = getYearsRange({\n      from: min?.year ?? 1900,\n      to: max?.year ?? 2100\n    });\n    return range.map(year => ({\n      label: year.toString(),\n      value: year\n    }));\n  }\n  function getDecadeYears(year) {\n    const range = getDecadeRange(focusedValue.year);\n    return range.map(year2 => ({\n      label: year2.toString(),\n      value: year2\n    }));\n  }\n  function isUnavailable(date) {\n    return isDateUnavailable(date, isDateUnavailableFn, locale, min, max);\n  }\n  function focusMonth(month) {\n    const date = startValue ?? getTodayDate(timeZone);\n    send({\n      type: \"FOCUS.SET\",\n      value: date.set({\n        month\n      })\n    });\n  }\n  function focusYear(year) {\n    const date = startValue ?? getTodayDate(timeZone);\n    send({\n      type: \"FOCUS.SET\",\n      value: date.set({\n        year\n      })\n    });\n  }\n  function getYearTableCellState(props2) {\n    const {\n      value,\n      disabled: disabled2\n    } = props2;\n    const cellState = {\n      focused: focusedValue.year === props2.value,\n      selectable: isValueWithinRange(value, min?.year ?? 0, max?.year ?? 9999),\n      selected: !!selectedValue.find(date => date.year === value),\n      valueText: value.toString(),\n      get disabled() {\n        return disabled2 || !cellState.selectable;\n      }\n    };\n    return cellState;\n  }\n  function getMonthTableCellState(props2) {\n    const {\n      value,\n      disabled: disabled2\n    } = props2;\n    const normalized = focusedValue.set({\n      month: value\n    });\n    const formatter = getMonthFormatter(locale, timeZone);\n    const cellState = {\n      focused: focusedValue.month === props2.value,\n      selectable: !isDateInvalid(normalized, min, max),\n      selected: !!selectedValue.find(date => date.month === value && date.year === focusedValue.year),\n      valueText: formatter.format(normalized.toDate(timeZone)),\n      get disabled() {\n        return disabled2 || !cellState.selectable;\n      }\n    };\n    return cellState;\n  }\n  const translations = state.context.translations || defaultTranslations;\n  function getDayTableCellState(props2) {\n    const {\n      value,\n      disabled: disabled2,\n      visibleRange = state.context.visibleRange\n    } = props2;\n    const formatter = getDayFormatter(locale, timeZone);\n    const unitDuration = getUnitDuration(state.context.visibleDuration);\n    const end = visibleRange.start.add(unitDuration).subtract({\n      days: 1\n    });\n    const cellState = {\n      invalid: isDateInvalid(value, min, max),\n      disabled: disabled2 || isDateDisabled(value, visibleRange.start, end, min, max),\n      selected: selectedValue.some(date => isDateEqual(value, date)),\n      unavailable: isDateUnavailable(value, isDateUnavailableFn, locale, min, max) && !disabled2,\n      outsideRange: isDateOutsideVisibleRange(value, visibleRange.start, end),\n      inRange: isRangePicker && (isDateWithinRange(value, selectedValue) || isDateWithinRange(value, hoveredRangeValue)),\n      firstInRange: isRangePicker && isDateEqual(value, selectedValue[0]),\n      lastInRange: isRangePicker && isDateEqual(value, selectedValue[1]),\n      today: isToday(value, timeZone),\n      weekend: isWeekend(value, locale),\n      formattedDate: formatter.format(value.toDate(timeZone)),\n      get focused() {\n        return isDateEqual(value, focusedValue) && !cellState.outsideRange;\n      },\n      get ariaLabel() {\n        return translations.dayCell(cellState);\n      },\n      get selectable() {\n        return !cellState.disabled && !cellState.unavailable;\n      }\n    };\n    return cellState;\n  }\n  function getTableId(props2) {\n    const {\n      view = \"day\",\n      id\n    } = props2;\n    return [view, id].filter(Boolean).join(\" \");\n  }\n  return {\n    focused,\n    open,\n    view: state.context.view,\n    getRangePresetValue(preset) {\n      return getDateRangePreset(preset, locale, timeZone);\n    },\n    getDaysInWeek(week, from = startValue) {\n      return getDaysInWeek(week, from, locale, startOfWeek);\n    },\n    getOffset(duration) {\n      const from = startValue.add(duration);\n      return {\n        visibleRange: {\n          start: from,\n          end: endValue.add(duration)\n        },\n        weeks: getMonthWeeks(from)\n      };\n    },\n    getMonthWeeks,\n    isUnavailable,\n    weeks: getMonthWeeks(),\n    weekDays: getWeekDays(getTodayDate(timeZone), startOfWeek, timeZone, locale),\n    visibleRangeText: state.context.visibleRangeText,\n    value: selectedValue,\n    valueAsDate: selectedValue.map(date => date.toDate(timeZone)),\n    valueAsString: state.context.valueAsString,\n    focusedValue,\n    focusedValueAsDate: focusedValue?.toDate(timeZone),\n    focusedValueAsString: state.context.format(focusedValue, {\n      locale,\n      timeZone\n    }),\n    visibleRange: state.context.visibleRange,\n    selectToday() {\n      const value = constrainValue(getTodayDate(timeZone), min, max);\n      send({\n        type: \"VALUE.SET\",\n        value\n      });\n    },\n    setValue(values) {\n      const computedValue = values.map(date => constrainValue(date, min, max));\n      send({\n        type: \"VALUE.SET\",\n        value: computedValue\n      });\n    },\n    clearValue() {\n      send(\"VALUE.CLEAR\");\n    },\n    setFocusedValue(value) {\n      send({\n        type: \"FOCUS.SET\",\n        value\n      });\n    },\n    setOpen(nextOpen) {\n      if (nextOpen === open) return;\n      send(nextOpen ? \"OPEN\" : \"CLOSE\");\n    },\n    focusMonth,\n    focusYear,\n    getYears,\n    getMonths,\n    getYearsGrid(props2 = {}) {\n      const {\n        columns = 1\n      } = props2;\n      return chunk(getDecadeYears(), columns);\n    },\n    getDecade() {\n      const years = getDecadeRange(focusedValue.year);\n      return {\n        start: years.at(0),\n        end: years.at(-1)\n      };\n    },\n    getMonthsGrid(props2 = {}) {\n      const {\n        columns = 1,\n        format\n      } = props2;\n      return chunk(getMonths({\n        format\n      }), columns);\n    },\n    format(value, opts = {\n      month: \"long\",\n      year: \"numeric\"\n    }) {\n      return new DateFormatter(locale, opts).format(value.toDate(timeZone));\n    },\n    setView(view) {\n      send({\n        type: \"VIEW.SET\",\n        view\n      });\n    },\n    goToNext() {\n      send({\n        type: \"GOTO.NEXT\",\n        view: state.context.view\n      });\n    },\n    goToPrev() {\n      send({\n        type: \"GOTO.PREV\",\n        view: state.context.view\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        id: dom.getRootId(state.context),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(readOnly)\n      });\n    },\n    getLabelProps(props2 = {}) {\n      const {\n        index = 0\n      } = props2;\n      return normalize.label({\n        ...parts.label.attrs,\n        id: dom.getLabelId(state.context, index),\n        dir: state.context.dir,\n        htmlFor: dom.getInputId(state.context, index),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-index\": index,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(readOnly)\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        dir: state.context.dir,\n        id: dom.getControlId(state.context),\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getRangeTextProps() {\n      return normalize.element({\n        ...parts.rangeText.attrs,\n        dir: state.context.dir\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        hidden: !open,\n        dir: state.context.dir,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-placement\": currentPlacement,\n        id: dom.getContentId(state.context),\n        tabIndex: -1,\n        role: \"application\",\n        \"aria-roledescription\": \"datepicker\",\n        \"aria-label\": translations.content\n      });\n    },\n    getTableProps(props2 = {}) {\n      const {\n        view = \"day\",\n        columns = view === \"day\" ? 7 : 4\n      } = props2;\n      const uid = getTableId(props2);\n      return normalize.element({\n        ...parts.table.attrs,\n        role: \"grid\",\n        \"data-columns\": columns,\n        \"aria-roledescription\": getRoleDescription(view),\n        id: dom.getTableId(state.context, uid),\n        \"aria-readonly\": ariaAttr(readOnly),\n        \"aria-disabled\": ariaAttr(disabled),\n        \"aria-multiselectable\": ariaAttr(state.context.selectionMode !== \"single\"),\n        \"data-view\": view,\n        dir: state.context.dir,\n        tabIndex: -1,\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          const keyMap = {\n            Enter() {\n              if (isUnavailable(focusedValue)) return;\n              send({\n                type: \"TABLE.ENTER\",\n                view,\n                columns,\n                focus: true\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"TABLE.ARROW_LEFT\",\n                view,\n                columns,\n                focus: true\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"TABLE.ARROW_RIGHT\",\n                view,\n                columns,\n                focus: true\n              });\n            },\n            ArrowUp() {\n              send({\n                type: \"TABLE.ARROW_UP\",\n                view,\n                columns,\n                focus: true\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"TABLE.ARROW_DOWN\",\n                view,\n                columns,\n                focus: true\n              });\n            },\n            PageUp(event2) {\n              send({\n                type: \"TABLE.PAGE_UP\",\n                larger: event2.shiftKey,\n                view,\n                columns,\n                focus: true\n              });\n            },\n            PageDown(event2) {\n              send({\n                type: \"TABLE.PAGE_DOWN\",\n                larger: event2.shiftKey,\n                view,\n                columns,\n                focus: true\n              });\n            },\n            Home() {\n              send({\n                type: \"TABLE.HOME\",\n                view,\n                columns,\n                focus: true\n              });\n            },\n            End() {\n              send({\n                type: \"TABLE.END\",\n                view,\n                columns,\n                focus: true\n              });\n            }\n          };\n          const exec = keyMap[getEventKey(event, state.context)];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        },\n        onPointerLeave() {\n          send({\n            type: \"TABLE.POINTER_LEAVE\"\n          });\n        },\n        onPointerDown() {\n          send({\n            type: \"TABLE.POINTER_DOWN\",\n            view\n          });\n        },\n        onPointerUp() {\n          send({\n            type: \"TABLE.POINTER_UP\",\n            view\n          });\n        }\n      });\n    },\n    getTableHeadProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      return normalize.element({\n        ...parts.tableHead.attrs,\n        \"aria-hidden\": true,\n        dir: state.context.dir,\n        \"data-view\": view,\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getTableHeaderProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      return normalize.element({\n        ...parts.tableHeader.attrs,\n        dir: state.context.dir,\n        \"data-view\": view,\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getTableBodyProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      return normalize.element({\n        ...parts.tableBody.attrs,\n        \"data-view\": view,\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getTableRowProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      return normalize.element({\n        ...parts.tableRow.attrs,\n        \"aria-disabled\": ariaAttr(disabled),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-view\": view\n      });\n    },\n    getDayTableCellState,\n    getDayTableCellProps(props2) {\n      const {\n        value\n      } = props2;\n      const cellState = getDayTableCellState(props2);\n      return normalize.element({\n        ...parts.tableCell.attrs,\n        role: \"gridcell\",\n        \"aria-disabled\": ariaAttr(!cellState.selectable),\n        \"aria-selected\": cellState.selected || cellState.inRange,\n        \"aria-invalid\": ariaAttr(cellState.invalid),\n        \"aria-current\": cellState.today ? \"date\" : void 0,\n        \"data-value\": value.toString()\n      });\n    },\n    getDayTableCellTriggerProps(props2) {\n      const {\n        value\n      } = props2;\n      const cellState = getDayTableCellState(props2);\n      return normalize.element({\n        ...parts.tableCellTrigger.attrs,\n        id: dom.getCellTriggerId(state.context, value.toString()),\n        role: \"button\",\n        dir: state.context.dir,\n        tabIndex: cellState.focused ? 0 : -1,\n        \"aria-label\": cellState.ariaLabel,\n        \"aria-disabled\": ariaAttr(!cellState.selectable),\n        \"aria-invalid\": ariaAttr(cellState.invalid),\n        \"data-disabled\": dataAttr(!cellState.selectable),\n        \"data-selected\": dataAttr(cellState.selected),\n        \"data-value\": value.toString(),\n        \"data-view\": \"day\",\n        \"data-today\": dataAttr(cellState.today),\n        \"data-focus\": dataAttr(cellState.focused),\n        \"data-unavailable\": dataAttr(cellState.unavailable),\n        \"data-range-start\": dataAttr(cellState.firstInRange),\n        \"data-range-end\": dataAttr(cellState.lastInRange),\n        \"data-in-range\": dataAttr(cellState.inRange),\n        \"data-outside-range\": dataAttr(cellState.outsideRange),\n        \"data-weekend\": dataAttr(cellState.weekend),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!cellState.selectable) return;\n          send({\n            type: \"CELL.CLICK\",\n            cell: \"day\",\n            value\n          });\n        },\n        onPointerMove(event) {\n          if (event.pointerType === \"touch\" || !cellState.selectable) return;\n          const focus = event.currentTarget.ownerDocument.activeElement !== event.currentTarget;\n          if (hoveredValue && isEqualDay(value, hoveredValue)) return;\n          send({\n            type: \"CELL.POINTER_MOVE\",\n            cell: \"day\",\n            value,\n            focus\n          });\n        }\n      });\n    },\n    getMonthTableCellState,\n    getMonthTableCellProps(props2) {\n      const {\n        value,\n        columns\n      } = props2;\n      const cellState = getMonthTableCellState(props2);\n      return normalize.element({\n        ...parts.tableCell.attrs,\n        dir: state.context.dir,\n        colSpan: columns,\n        role: \"gridcell\",\n        \"aria-selected\": ariaAttr(cellState.selected),\n        \"data-selected\": dataAttr(cellState.selected),\n        \"aria-disabled\": ariaAttr(!cellState.selectable),\n        \"data-value\": value\n      });\n    },\n    getMonthTableCellTriggerProps(props2) {\n      const {\n        value\n      } = props2;\n      const cellState = getMonthTableCellState(props2);\n      return normalize.element({\n        ...parts.tableCellTrigger.attrs,\n        dir: state.context.dir,\n        role: \"button\",\n        id: dom.getCellTriggerId(state.context, value.toString()),\n        \"data-selected\": dataAttr(cellState.selected),\n        \"aria-disabled\": ariaAttr(!cellState.selectable),\n        \"data-disabled\": dataAttr(!cellState.selectable),\n        \"data-focus\": dataAttr(cellState.focused),\n        \"aria-label\": cellState.valueText,\n        \"data-view\": \"month\",\n        \"data-value\": value,\n        tabIndex: cellState.focused ? 0 : -1,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!cellState.selectable) return;\n          send({\n            type: \"CELL.CLICK\",\n            cell: \"month\",\n            value\n          });\n        }\n      });\n    },\n    getYearTableCellState,\n    getYearTableCellProps(props2) {\n      const {\n        value,\n        columns\n      } = props2;\n      const cellState = getYearTableCellState(props2);\n      return normalize.element({\n        ...parts.tableCell.attrs,\n        dir: state.context.dir,\n        colSpan: columns,\n        role: \"gridcell\",\n        \"aria-selected\": ariaAttr(cellState.selected),\n        \"data-selected\": dataAttr(cellState.selected),\n        \"aria-disabled\": ariaAttr(!cellState.selectable),\n        \"data-value\": value\n      });\n    },\n    getYearTableCellTriggerProps(props2) {\n      const {\n        value\n      } = props2;\n      const cellState = getYearTableCellState(props2);\n      return normalize.element({\n        ...parts.tableCellTrigger.attrs,\n        dir: state.context.dir,\n        role: \"button\",\n        id: dom.getCellTriggerId(state.context, value.toString()),\n        \"data-selected\": dataAttr(cellState.selected),\n        \"data-focus\": dataAttr(cellState.focused),\n        \"aria-disabled\": ariaAttr(!cellState.selectable),\n        \"data-disabled\": dataAttr(!cellState.selectable),\n        \"aria-label\": cellState.valueText,\n        \"data-value\": value,\n        \"data-view\": \"year\",\n        tabIndex: cellState.focused ? 0 : -1,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!cellState.selectable) return;\n          send({\n            type: \"CELL.CLICK\",\n            cell: \"year\",\n            value\n          });\n        }\n      });\n    },\n    getNextTriggerProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      const isDisabled = disabled || !state.context.isNextVisibleRangeValid;\n      return normalize.button({\n        ...parts.nextTrigger.attrs,\n        dir: state.context.dir,\n        id: dom.getNextTriggerId(state.context, view),\n        type: \"button\",\n        \"aria-label\": translations.nextTrigger(view),\n        disabled: isDisabled,\n        \"data-disabled\": dataAttr(isDisabled),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"GOTO.NEXT\",\n            view\n          });\n        }\n      });\n    },\n    getPrevTriggerProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      const isDisabled = disabled || !state.context.isPrevVisibleRangeValid;\n      return normalize.button({\n        ...parts.prevTrigger.attrs,\n        dir: state.context.dir,\n        id: dom.getPrevTriggerId(state.context, view),\n        type: \"button\",\n        \"aria-label\": translations.prevTrigger(view),\n        disabled: isDisabled,\n        \"data-disabled\": dataAttr(isDisabled),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"GOTO.PREV\",\n            view\n          });\n        }\n      });\n    },\n    getClearTriggerProps() {\n      return normalize.button({\n        ...parts.clearTrigger.attrs,\n        id: dom.getClearTriggerId(state.context),\n        dir: state.context.dir,\n        type: \"button\",\n        \"aria-label\": translations.clearTrigger,\n        hidden: !state.context.value.length,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send(\"VALUE.CLEAR\");\n        }\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        id: dom.getTriggerId(state.context),\n        dir: state.context.dir,\n        type: \"button\",\n        \"data-placement\": currentPlacement,\n        \"aria-label\": translations.trigger(open),\n        \"aria-controls\": dom.getContentId(state.context),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-haspopup\": \"grid\",\n        disabled,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          send(\"TRIGGER.CLICK\");\n        }\n      });\n    },\n    getViewTriggerProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      return normalize.button({\n        ...parts.viewTrigger.attrs,\n        \"data-view\": view,\n        dir: state.context.dir,\n        id: dom.getViewTriggerId(state.context, view),\n        type: \"button\",\n        disabled,\n        \"aria-label\": translations.viewTrigger(view),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          send({\n            type: \"VIEW.TOGGLE\",\n            src: \"viewTrigger\"\n          });\n        }\n      });\n    },\n    getViewControlProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      return normalize.element({\n        ...parts.viewControl.attrs,\n        \"data-view\": view,\n        dir: state.context.dir\n      });\n    },\n    getInputProps(props2 = {}) {\n      const {\n        index = 0,\n        fixOnBlur = true\n      } = props2;\n      return normalize.input({\n        ...parts.input.attrs,\n        id: dom.getInputId(state.context, index),\n        autoComplete: \"off\",\n        autoCorrect: \"off\",\n        spellCheck: \"false\",\n        dir: state.context.dir,\n        name: state.context.name,\n        \"data-index\": index,\n        \"data-state\": open ? \"open\" : \"closed\",\n        readOnly,\n        disabled,\n        placeholder: state.context.placeholder || getInputPlaceholder(locale),\n        defaultValue: state.context.valueAsString[index],\n        onBeforeInput(event) {\n          const {\n            data\n          } = getNativeEvent(event);\n          if (!isValidCharacter(data, separator)) {\n            event.preventDefault();\n          }\n        },\n        onFocus() {\n          send({\n            type: \"INPUT.FOCUS\",\n            index\n          });\n        },\n        onBlur(event) {\n          const value = event.currentTarget.value.trim();\n          send({\n            type: \"INPUT.BLUR\",\n            value,\n            index,\n            fixOnBlur\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          const keyMap = {\n            Enter(event2) {\n              if (isComposingEvent(event2)) return;\n              if (isUnavailable(state.context.focusedValue)) return;\n              if (event2.currentTarget.value.trim() === \"\") return;\n              send({\n                type: \"INPUT.ENTER\",\n                value: event2.currentTarget.value,\n                index\n              });\n            }\n          };\n          const exec = keyMap[event.key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        },\n        onInput(event) {\n          const value = event.currentTarget.value;\n          send({\n            type: \"INPUT.CHANGE\",\n            value: ensureValidCharacters(value, separator),\n            index\n          });\n        }\n      });\n    },\n    getMonthSelectProps() {\n      return normalize.select({\n        ...parts.monthSelect.attrs,\n        id: dom.getMonthSelectId(state.context),\n        \"aria-label\": translations.monthSelect,\n        disabled,\n        dir: state.context.dir,\n        defaultValue: startValue.month,\n        onChange(event) {\n          focusMonth(Number(event.currentTarget.value));\n        }\n      });\n    },\n    getYearSelectProps() {\n      return normalize.select({\n        ...parts.yearSelect.attrs,\n        id: dom.getYearSelectId(state.context),\n        disabled,\n        \"aria-label\": translations.yearSelect,\n        dir: state.context.dir,\n        defaultValue: startValue.year,\n        onChange(event) {\n          focusYear(Number(event.currentTarget.value));\n        }\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        id: dom.getPositionerId(state.context),\n        ...parts.positioner.attrs,\n        dir: state.context.dir,\n        style: popperStyles.floating\n      });\n    },\n    getPresetTriggerProps(props2) {\n      const value = Array.isArray(props2.value) ? props2.value : getDateRangePreset(props2.value, locale, timeZone);\n      const valueAsString = value.map(item => item.toDate(timeZone).toDateString());\n      return normalize.button({\n        ...parts.presetTrigger.attrs,\n        \"aria-label\": translations.presetTrigger(valueAsString),\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"PRESET.CLICK\",\n            value\n          });\n        }\n      });\n    }\n  };\n}\nvar {\n  and\n} = guards;\nvar transformContext = ctx => {\n  const locale = ctx.locale || \"en-US\";\n  const timeZone = ctx.timeZone || \"UTC\";\n  const selectionMode = ctx.selectionMode || \"single\";\n  const numOfMonths = ctx.numOfMonths || 1;\n  const value = sortDates(ctx.value || []).map(date => constrainValue(date, ctx.min, ctx.max));\n  let focusedValue = value[0] || ctx.focusedValue || getTodayDate(timeZone);\n  focusedValue = constrainValue(focusedValue, ctx.min, ctx.max);\n  const startValue = alignDate(focusedValue, \"start\", {\n    months: numOfMonths\n  }, locale);\n  const minView = \"day\";\n  const maxView = \"year\";\n  const view = clampView(ctx.view || minView, minView, maxView);\n  return {\n    locale,\n    numOfMonths,\n    focusedValue,\n    startValue,\n    inputValue: \"\",\n    timeZone,\n    value,\n    selectionMode,\n    view,\n    minView,\n    maxView,\n    activeIndex: 0,\n    hoveredValue: null,\n    closeOnSelect: true,\n    disabled: false,\n    readOnly: false,\n    min: void 0,\n    max: void 0,\n    format(date, {\n      locale: locale2,\n      timeZone: timeZone2\n    }) {\n      const formatter = new DateFormatter(locale2, {\n        timeZone: timeZone2,\n        day: \"2-digit\",\n        month: \"2-digit\",\n        year: \"numeric\"\n      });\n      return formatter.format(date.toDate(timeZone2));\n    },\n    parse(value2, {\n      locale: locale2,\n      timeZone: timeZone2\n    }) {\n      return parseDateString(value2, locale2, timeZone2);\n    },\n    ...ctx,\n    positioning: {\n      placement: \"bottom\",\n      ...ctx.positioning\n    }\n  };\n};\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"datepicker\",\n    initial: ctx.open ? \"open\" : \"idle\",\n    context: transformContext(ctx),\n    computed: {\n      isInteractive: ctx2 => !ctx2.disabled && !ctx2.readOnly,\n      visibleDuration: ctx2 => ({\n        months: ctx2.numOfMonths\n      }),\n      endValue: ctx2 => getEndDate(ctx2.startValue, ctx2.visibleDuration),\n      visibleRange: ctx2 => ({\n        start: ctx2.startValue,\n        end: ctx2.endValue\n      }),\n      visibleRangeText(ctx2) {\n        const formatter = new DateFormatter(ctx2.locale, {\n          month: \"long\",\n          year: \"numeric\",\n          timeZone: ctx2.timeZone\n        });\n        const start = formatter.format(ctx2.startValue.toDate(ctx2.timeZone));\n        const end = formatter.format(ctx2.endValue.toDate(ctx2.timeZone));\n        const formatted = ctx2.selectionMode === \"range\" ? `${start} - ${end}` : start;\n        return {\n          start,\n          end,\n          formatted\n        };\n      },\n      isPrevVisibleRangeValid: ctx2 => !isPreviousVisibleRangeInvalid(ctx2.startValue, ctx2.min, ctx2.max),\n      isNextVisibleRangeValid: ctx2 => !isNextVisibleRangeInvalid(ctx2.endValue, ctx2.min, ctx2.max),\n      valueAsString(ctx2) {\n        return ctx2.value.map(date => ctx2.format(date, {\n          locale: ctx2.locale,\n          timeZone: ctx2.timeZone\n        }));\n      }\n    },\n    activities: [\"setupLiveRegion\"],\n    created: [\"setStartValue\"],\n    watch: {\n      locale: [\"setStartValue\"],\n      focusedValue: [\"setStartValue\", \"syncMonthSelectElement\", \"syncYearSelectElement\", \"focusActiveCellIfNeeded\", \"setHoveredValueIfKeyboard\"],\n      inputValue: [\"syncInputValue\"],\n      value: [\"syncInputElement\"],\n      valueAsString: [\"announceValueText\"],\n      view: [\"focusActiveCell\"],\n      open: [\"toggleVisibility\"]\n    },\n    on: {\n      \"VALUE.SET\": {\n        actions: [\"setDateValue\", \"setFocusedDate\"]\n      },\n      \"VIEW.SET\": {\n        actions: [\"setView\"]\n      },\n      \"FOCUS.SET\": {\n        actions: [\"setFocusedDate\"]\n      },\n      \"VALUE.CLEAR\": {\n        actions: [\"clearDateValue\", \"clearFocusedDate\", \"focusFirstInputElement\"]\n      },\n      \"INPUT.CHANGE\": [{\n        guard: \"isInputValueEmpty\",\n        actions: [\"setInputValue\", \"clearDateValue\", \"clearFocusedDate\"]\n      }, {\n        actions: [\"setInputValue\", \"focusParsedDate\"]\n      }],\n      \"INPUT.ENTER\": {\n        actions: [\"focusParsedDate\", \"selectFocusedDate\"]\n      },\n      \"INPUT.FOCUS\": {\n        actions: [\"setActiveIndex\"]\n      },\n      \"INPUT.BLUR\": [{\n        guard: \"shouldFixOnBlur\",\n        actions: [\"setActiveIndexToStart\", \"selectParsedDate\"]\n      }, {\n        actions: [\"setActiveIndexToStart\"]\n      }],\n      \"PRESET.CLICK\": [{\n        guard: \"isOpenControlled\",\n        actions: [\"setDateValue\", \"setFocusedDate\", \"invokeOnClose\"]\n      }, {\n        target: \"focused\",\n        actions: [\"setDateValue\", \"setFocusedDate\", \"focusInputElement\"]\n      }],\n      \"GOTO.NEXT\": [{\n        guard: \"isYearView\",\n        actions: [\"focusNextDecade\", \"announceVisibleRange\"]\n      }, {\n        guard: \"isMonthView\",\n        actions: [\"focusNextYear\", \"announceVisibleRange\"]\n      }, {\n        actions: [\"focusNextPage\"]\n      }],\n      \"GOTO.PREV\": [{\n        guard: \"isYearView\",\n        actions: [\"focusPreviousDecade\", \"announceVisibleRange\"]\n      }, {\n        guard: \"isMonthView\",\n        actions: [\"focusPreviousYear\", \"announceVisibleRange\"]\n      }, {\n        actions: [\"focusPreviousPage\"]\n      }]\n    },\n    states: {\n      idle: {\n        tags: \"closed\",\n        on: {\n          \"CONTROLLED.OPEN\": {\n            target: \"open\",\n            actions: [\"focusFirstSelectedDate\", \"focusActiveCell\"]\n          },\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"focusFirstSelectedDate\", \"focusActiveCell\", \"invokeOnOpen\"]\n          }],\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"focusFirstSelectedDate\", \"focusActiveCell\", \"invokeOnOpen\"]\n          }]\n        }\n      },\n      focused: {\n        tags: \"closed\",\n        on: {\n          \"CONTROLLED.OPEN\": {\n            target: \"open\",\n            actions: [\"focusFirstSelectedDate\", \"focusActiveCell\"]\n          },\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"focusFirstSelectedDate\", \"focusActiveCell\", \"invokeOnOpen\"]\n          }],\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"focusFirstSelectedDate\", \"focusActiveCell\", \"invokeOnOpen\"]\n          }]\n        }\n      },\n      open: {\n        tags: \"open\",\n        activities: [\"trackDismissableElement\", \"trackPositioning\"],\n        exit: [\"clearHoveredDate\", \"resetView\"],\n        on: {\n          \"CONTROLLED.CLOSE\": [{\n            guard: and(\"shouldRestoreFocus\", \"isInteractOutsideEvent\"),\n            target: \"focused\",\n            actions: [\"focusTriggerElement\"]\n          }, {\n            guard: \"shouldRestoreFocus\",\n            target: \"focused\",\n            actions: [\"focusInputElement\"]\n          }, {\n            target: \"idle\"\n          }],\n          \"CELL.CLICK\": [{\n            guard: \"isAboveMinView\",\n            actions: [\"setFocusedValueForView\", \"setPreviousView\"]\n          }, {\n            guard: and(\"isRangePicker\", \"hasSelectedRange\"),\n            actions: [\"setActiveIndexToStart\", \"clearDateValue\", \"setFocusedDate\", \"setSelectedDate\", \"setActiveIndexToEnd\"]\n          },\n          // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===\n          {\n            guard: and(\"isRangePicker\", \"isSelectingEndDate\", \"closeOnSelect\", \"isOpenControlled\"),\n            actions: [\"setFocusedDate\", \"setSelectedDate\", \"setActiveIndexToStart\", \"invokeOnClose\", \"setRestoreFocus\"]\n          }, {\n            guard: and(\"isRangePicker\", \"isSelectingEndDate\", \"closeOnSelect\"),\n            target: \"focused\",\n            actions: [\"setFocusedDate\", \"setSelectedDate\", \"setActiveIndexToStart\", \"invokeOnClose\", \"focusInputElement\"]\n          }, {\n            guard: and(\"isRangePicker\", \"isSelectingEndDate\"),\n            actions: [\"setFocusedDate\", \"setSelectedDate\", \"setActiveIndexToStart\", \"clearHoveredDate\"]\n          },\n          // ===\n          {\n            guard: \"isRangePicker\",\n            actions: [\"setFocusedDate\", \"setSelectedDate\", \"setActiveIndexToEnd\"]\n          }, {\n            guard: \"isMultiPicker\",\n            actions: [\"setFocusedDate\", \"toggleSelectedDate\"]\n          },\n          // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===\n          {\n            guard: and(\"closeOnSelect\", \"isOpenControlled\"),\n            actions: [\"setFocusedDate\", \"setSelectedDate\", \"invokeOnClose\"]\n          }, {\n            guard: \"closeOnSelect\",\n            target: \"focused\",\n            actions: [\"setFocusedDate\", \"setSelectedDate\", \"invokeOnClose\", \"focusInputElement\"]\n          }, {\n            actions: [\"setFocusedDate\", \"setSelectedDate\"]\n          }\n          // ===\n          ],\n          \"CELL.POINTER_MOVE\": {\n            guard: and(\"isRangePicker\", \"isSelectingEndDate\"),\n            actions: [\"setHoveredDate\", \"setFocusedDate\"]\n          },\n          \"TABLE.POINTER_LEAVE\": {\n            guard: \"isRangePicker\",\n            actions: [\"clearHoveredDate\"]\n          },\n          \"TABLE.POINTER_DOWN\": {\n            actions: [\"disableTextSelection\"]\n          },\n          \"TABLE.POINTER_UP\": {\n            actions: [\"enableTextSelection\"]\n          },\n          \"TABLE.ESCAPE\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"focusFirstSelectedDate\", \"invokeOnClose\"]\n          }, {\n            target: \"focused\",\n            actions: [\"focusFirstSelectedDate\", \"invokeOnClose\", \"focusTriggerElement\"]\n          }],\n          \"TABLE.ENTER\": [{\n            guard: \"isAboveMinView\",\n            actions: [\"setPreviousView\"]\n          }, {\n            guard: and(\"isRangePicker\", \"hasSelectedRange\"),\n            actions: [\"setActiveIndexToStart\", \"clearDateValue\", \"setSelectedDate\", \"setActiveIndexToEnd\"]\n          },\n          // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===\n          {\n            guard: and(\"isRangePicker\", \"isSelectingEndDate\", \"closeOnSelect\", \"isOpenControlled\"),\n            actions: [\"setSelectedDate\", \"setActiveIndexToStart\", \"invokeOnClose\"]\n          }, {\n            guard: and(\"isRangePicker\", \"isSelectingEndDate\", \"closeOnSelect\"),\n            target: \"focused\",\n            actions: [\"setSelectedDate\", \"setActiveIndexToStart\", \"invokeOnClose\", \"focusInputElement\"]\n          }, {\n            guard: and(\"isRangePicker\", \"isSelectingEndDate\"),\n            actions: [\"setSelectedDate\", \"setActiveIndexToStart\"]\n          },\n          // ===\n          {\n            guard: \"isRangePicker\",\n            actions: [\"setSelectedDate\", \"setActiveIndexToEnd\", \"focusNextDay\"]\n          }, {\n            guard: \"isMultiPicker\",\n            actions: [\"toggleSelectedDate\"]\n          },\n          // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===\n          {\n            guard: and(\"closeOnSelect\", \"isOpenControlled\"),\n            actions: [\"selectFocusedDate\", \"invokeOnClose\"]\n          }, {\n            guard: \"closeOnSelect\",\n            target: \"focused\",\n            actions: [\"selectFocusedDate\", \"invokeOnClose\", \"focusInputElement\"]\n          }, {\n            actions: [\"selectFocusedDate\"]\n          }\n          // ===\n          ],\n          \"TABLE.ARROW_RIGHT\": [{\n            guard: \"isMonthView\",\n            actions: \"focusNextMonth\"\n          }, {\n            guard: \"isYearView\",\n            actions: \"focusNextYear\"\n          }, {\n            actions: [\"focusNextDay\", \"setHoveredDate\"]\n          }],\n          \"TABLE.ARROW_LEFT\": [{\n            guard: \"isMonthView\",\n            actions: \"focusPreviousMonth\"\n          }, {\n            guard: \"isYearView\",\n            actions: \"focusPreviousYear\"\n          }, {\n            actions: [\"focusPreviousDay\"]\n          }],\n          \"TABLE.ARROW_UP\": [{\n            guard: \"isMonthView\",\n            actions: \"focusPreviousMonthColumn\"\n          }, {\n            guard: \"isYearView\",\n            actions: \"focusPreviousYearColumn\"\n          }, {\n            actions: [\"focusPreviousWeek\"]\n          }],\n          \"TABLE.ARROW_DOWN\": [{\n            guard: \"isMonthView\",\n            actions: \"focusNextMonthColumn\"\n          }, {\n            guard: \"isYearView\",\n            actions: \"focusNextYearColumn\"\n          }, {\n            actions: [\"focusNextWeek\"]\n          }],\n          \"TABLE.PAGE_UP\": {\n            actions: [\"focusPreviousSection\"]\n          },\n          \"TABLE.PAGE_DOWN\": {\n            actions: [\"focusNextSection\"]\n          },\n          \"TABLE.HOME\": [{\n            guard: \"isMonthView\",\n            actions: [\"focusFirstMonth\"]\n          }, {\n            guard: \"isYearView\",\n            actions: [\"focusFirstYear\"]\n          }, {\n            actions: [\"focusSectionStart\"]\n          }],\n          \"TABLE.END\": [{\n            guard: \"isMonthView\",\n            actions: [\"focusLastMonth\"]\n          }, {\n            guard: \"isYearView\",\n            actions: [\"focusLastYear\"]\n          }, {\n            actions: [\"focusSectionEnd\"]\n          }],\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"focused\",\n            actions: [\"invokeOnClose\"]\n          }],\n          \"VIEW.TOGGLE\": {\n            actions: [\"setNextView\"]\n          },\n          INTERACT_OUTSIDE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"setActiveIndexToStart\", \"invokeOnClose\"]\n          }, {\n            guard: \"shouldRestoreFocus\",\n            target: \"focused\",\n            actions: [\"setActiveIndexToStart\", \"invokeOnClose\", \"focusTriggerElement\"]\n          }, {\n            target: \"idle\",\n            actions: [\"setActiveIndexToStart\", \"invokeOnClose\"]\n          }],\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"setActiveIndexToStart\", \"invokeOnClose\"]\n          }, {\n            target: \"idle\",\n            actions: [\"setActiveIndexToStart\", \"invokeOnClose\"]\n          }]\n        }\n      }\n    }\n  }, {\n    guards: {\n      isAboveMinView: ctx2 => isAboveMinView(ctx2.view, ctx2.minView),\n      isDayView: (ctx2, evt) => (evt.view || ctx2.view) === \"day\",\n      isMonthView: (ctx2, evt) => (evt.view || ctx2.view) === \"month\",\n      isYearView: (ctx2, evt) => (evt.view || ctx2.view) === \"year\",\n      isRangePicker: ctx2 => ctx2.selectionMode === \"range\",\n      hasSelectedRange: ctx2 => ctx2.value.length === 2,\n      isMultiPicker: ctx2 => ctx2.selectionMode === \"multiple\",\n      shouldRestoreFocus: ctx2 => !!ctx2.restoreFocus,\n      isSelectingEndDate: ctx2 => ctx2.activeIndex === 1,\n      closeOnSelect: ctx2 => !!ctx2.closeOnSelect,\n      isOpenControlled: ctx2 => !!ctx2[\"open.controlled\"],\n      isInteractOutsideEvent: (_ctx, evt) => evt.previousEvent?.type === \"INTERACT_OUTSIDE\",\n      isInputValueEmpty: (_ctx, evt) => evt.value.trim() === \"\",\n      shouldFixOnBlur: (_ctx, evt) => !!evt.fixOnBlur\n    },\n    activities: {\n      trackPositioning(ctx2) {\n        ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);\n        const anchorEl = dom.getControlEl(ctx2);\n        const getPositionerEl = () => dom.getPositionerEl(ctx2);\n        return getPlacement(anchorEl, getPositionerEl, {\n          ...ctx2.positioning,\n          defer: true,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      setupLiveRegion(ctx2) {\n        const doc = dom.getDoc(ctx2);\n        ctx2.announcer = createLiveRegion({\n          level: \"assertive\",\n          document: doc\n        });\n        return () => ctx2.announcer?.destroy?.();\n      },\n      trackDismissableElement(ctx2, _evt, {\n        send\n      }) {\n        const getContentEl = () => dom.getContentEl(ctx2);\n        return trackDismissableElement(getContentEl, {\n          defer: true,\n          exclude: [...dom.getInputEls(ctx2), dom.getTriggerEl(ctx2), dom.getClearTriggerEl(ctx2)],\n          onInteractOutside(event) {\n            ctx2.restoreFocus = !event.detail.focusable;\n          },\n          onDismiss() {\n            send({\n              type: \"INTERACT_OUTSIDE\"\n            });\n          },\n          onEscapeKeyDown(event) {\n            event.preventDefault();\n            send({\n              type: \"TABLE.ESCAPE\",\n              src: \"dismissable\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      setNextView(ctx2) {\n        const nextView = getNextView(ctx2.view, ctx2.minView, ctx2.maxView);\n        set.view(ctx2, nextView);\n      },\n      setPreviousView(ctx2) {\n        const prevView = getPreviousView(ctx2.view, ctx2.minView, ctx2.maxView);\n        set.view(ctx2, prevView);\n      },\n      setView(ctx2, evt) {\n        set.view(ctx2, evt.view);\n      },\n      setRestoreFocus(ctx2) {\n        ctx2.restoreFocus = true;\n      },\n      announceValueText(ctx2) {\n        const announceText = ctx2.value.map(date => formatSelectedDate(date, null, ctx2.locale, ctx2.timeZone));\n        ctx2.announcer?.announce(announceText.join(\",\"), 3e3);\n      },\n      announceVisibleRange(ctx2) {\n        const {\n          formatted\n        } = ctx2.visibleRangeText;\n        ctx2.announcer?.announce(formatted);\n      },\n      disableTextSelection(ctx2) {\n        disableTextSelection({\n          target: dom.getContentEl(ctx2),\n          doc: dom.getDoc(ctx2)\n        });\n      },\n      enableTextSelection(ctx2) {\n        restoreTextSelection({\n          doc: dom.getDoc(ctx2),\n          target: dom.getContentEl(ctx2)\n        });\n      },\n      focusFirstSelectedDate(ctx2) {\n        if (!ctx2.value.length) return;\n        set.focusedValue(ctx2, ctx2.value[0]);\n      },\n      syncInputElement(ctx2) {\n        raf(() => {\n          const inputEls = dom.getInputEls(ctx2);\n          inputEls.forEach((inputEl, index) => {\n            dom.setValue(inputEl, ctx2.valueAsString[index] || \"\");\n          });\n        });\n      },\n      setFocusedDate(ctx2, evt) {\n        const value = Array.isArray(evt.value) ? evt.value[0] : evt.value;\n        set.focusedValue(ctx2, value);\n      },\n      setFocusedValueForView(ctx2, evt) {\n        set.focusedValue(ctx2, ctx2.focusedValue.set({\n          [ctx2.view]: evt.value\n        }));\n      },\n      focusNextMonth(ctx2) {\n        set.focusedValue(ctx2, ctx2.focusedValue.add({\n          months: 1\n        }));\n      },\n      focusPreviousMonth(ctx2) {\n        set.focusedValue(ctx2, ctx2.focusedValue.subtract({\n          months: 1\n        }));\n      },\n      setDateValue(ctx2, evt) {\n        if (!Array.isArray(evt.value)) return;\n        const value = evt.value.map(date => constrainValue(date, ctx2.min, ctx2.max));\n        set.value(ctx2, value);\n      },\n      clearDateValue(ctx2) {\n        set.value(ctx2, []);\n      },\n      setSelectedDate(ctx2, evt) {\n        const values = Array.from(ctx2.value);\n        values[ctx2.activeIndex] = normalizeValue(ctx2, evt.value ?? ctx2.focusedValue);\n        set.value(ctx2, adjustStartAndEndDate(values));\n      },\n      toggleSelectedDate(ctx2, evt) {\n        const currentValue = normalizeValue(ctx2, evt.value ?? ctx2.focusedValue);\n        const index = ctx2.value.findIndex(date => isDateEqual(date, currentValue));\n        if (index === -1) {\n          const values = [...ctx2.value, currentValue];\n          set.value(ctx2, sortDates(values));\n        } else {\n          const values = Array.from(ctx2.value);\n          values.splice(index, 1);\n          set.value(ctx2, sortDates(values));\n        }\n      },\n      setHoveredDate(ctx2, evt) {\n        ctx2.hoveredValue = evt.value;\n      },\n      clearHoveredDate(ctx2) {\n        ctx2.hoveredValue = null;\n      },\n      selectFocusedDate(ctx2) {\n        const values = Array.from(ctx2.value);\n        values[ctx2.activeIndex] = ctx2.focusedValue.copy();\n        set.value(ctx2, adjustStartAndEndDate(values));\n        set.inputValue(ctx2, ctx2.activeIndex);\n      },\n      focusPreviousDay(ctx2) {\n        set.focusedValue(ctx2, ctx2.focusedValue.subtract({\n          days: 1\n        }));\n      },\n      focusNextDay(ctx2) {\n        set.focusedValue(ctx2, ctx2.focusedValue.add({\n          days: 1\n        }));\n      },\n      focusPreviousWeek(ctx2) {\n        set.focusedValue(ctx2, ctx2.focusedValue.subtract({\n          weeks: 1\n        }));\n      },\n      focusNextWeek(ctx2) {\n        set.focusedValue(ctx2, ctx2.focusedValue.add({\n          weeks: 1\n        }));\n      },\n      focusNextPage(ctx2) {\n        const nextPage = getNextPage(ctx2.focusedValue, ctx2.startValue, ctx2.visibleDuration, ctx2.locale, ctx2.min, ctx2.max);\n        set.adjustedValue(ctx2, nextPage);\n      },\n      focusPreviousPage(ctx2) {\n        const previousPage = getPreviousPage(ctx2.focusedValue, ctx2.startValue, ctx2.visibleDuration, ctx2.locale, ctx2.min, ctx2.max);\n        set.adjustedValue(ctx2, previousPage);\n      },\n      focusSectionStart(ctx2) {\n        set.focusedValue(ctx2, ctx2.startValue.copy());\n      },\n      focusSectionEnd(ctx2) {\n        set.focusedValue(ctx2, ctx2.endValue.copy());\n      },\n      focusNextSection(ctx2, evt) {\n        const nextSection = getNextSection(ctx2.focusedValue, ctx2.startValue, evt.larger, ctx2.visibleDuration, ctx2.locale, ctx2.min, ctx2.max);\n        if (!nextSection) return;\n        set.adjustedValue(ctx2, nextSection);\n      },\n      focusPreviousSection(ctx2, evt) {\n        const previousSection = getPreviousSection(ctx2.focusedValue, ctx2.startValue, evt.larger, ctx2.visibleDuration, ctx2.locale, ctx2.min, ctx2.max);\n        if (!previousSection) return;\n        set.adjustedValue(ctx2, previousSection);\n      },\n      focusNextYear(ctx2) {\n        set.focusedValue(ctx2, ctx2.focusedValue.add({\n          years: 1\n        }));\n      },\n      focusPreviousYear(ctx2) {\n        set.focusedValue(ctx2, ctx2.focusedValue.subtract({\n          years: 1\n        }));\n      },\n      focusNextDecade(ctx2) {\n        set.focusedValue(ctx2, ctx2.focusedValue.add({\n          years: 10\n        }));\n      },\n      focusPreviousDecade(ctx2) {\n        set.focusedValue(ctx2, ctx2.focusedValue.subtract({\n          years: 10\n        }));\n      },\n      clearFocusedDate(ctx2) {\n        set.focusedValue(ctx2, getTodayDate(ctx2.timeZone));\n      },\n      focusPreviousMonthColumn(ctx2, evt) {\n        set.focusedValue(ctx2, ctx2.focusedValue.subtract({\n          months: evt.columns\n        }));\n      },\n      focusNextMonthColumn(ctx2, evt) {\n        set.focusedValue(ctx2, ctx2.focusedValue.add({\n          months: evt.columns\n        }));\n      },\n      focusPreviousYearColumn(ctx2, evt) {\n        set.focusedValue(ctx2, ctx2.focusedValue.subtract({\n          years: evt.columns\n        }));\n      },\n      focusNextYearColumn(ctx2, evt) {\n        set.focusedValue(ctx2, ctx2.focusedValue.add({\n          years: evt.columns\n        }));\n      },\n      focusFirstMonth(ctx2) {\n        set.focusedValue(ctx2, ctx2.focusedValue.set({\n          month: 0\n        }));\n      },\n      focusLastMonth(ctx2) {\n        set.focusedValue(ctx2, ctx2.focusedValue.set({\n          month: 12\n        }));\n      },\n      focusFirstYear(ctx2) {\n        const range = getDecadeRange(ctx2.focusedValue.year);\n        set.focusedValue(ctx2, ctx2.focusedValue.set({\n          year: range[0]\n        }));\n      },\n      focusLastYear(ctx2) {\n        const range = getDecadeRange(ctx2.focusedValue.year);\n        set.focusedValue(ctx2, ctx2.focusedValue.set({\n          year: range[range.length - 1]\n        }));\n      },\n      setActiveIndex(ctx2, evt) {\n        ctx2.activeIndex = evt.index;\n      },\n      setActiveIndexToEnd(ctx2) {\n        ctx2.activeIndex = 1;\n      },\n      setActiveIndexToStart(ctx2) {\n        ctx2.activeIndex = 0;\n      },\n      focusActiveCell(ctx2) {\n        raf(() => {\n          dom.getFocusedCell(ctx2)?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      focusActiveCellIfNeeded(ctx2, evt) {\n        if (!evt.focus) return;\n        raf(() => {\n          dom.getFocusedCell(ctx2)?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      setHoveredValueIfKeyboard(ctx2, evt) {\n        if (!evt.type.startsWith(\"TABLE.ARROW\") || ctx2.selectionMode !== \"range\" || ctx2.activeIndex === 0) return;\n        ctx2.hoveredValue = ctx2.focusedValue.copy();\n      },\n      focusTriggerElement(ctx2) {\n        raf(() => {\n          dom.getTriggerEl(ctx2)?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      focusFirstInputElement(ctx2) {\n        raf(() => {\n          const [inputEl] = dom.getInputEls(ctx2);\n          inputEl?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      focusInputElement(ctx2) {\n        raf(() => {\n          const inputEls = dom.getInputEls(ctx2);\n          const lastIndexWithValue = inputEls.findLastIndex(inputEl2 => inputEl2.value !== \"\");\n          const indexToFocus = Math.max(lastIndexWithValue, 0);\n          const inputEl = inputEls[indexToFocus];\n          inputEl?.focus({\n            preventScroll: true\n          });\n          inputEl?.setSelectionRange(inputEl.value.length, inputEl.value.length);\n        });\n      },\n      syncMonthSelectElement(ctx2) {\n        const monthSelectEl = dom.getMonthSelectEl(ctx2);\n        dom.setValue(monthSelectEl, ctx2.startValue.month.toString());\n      },\n      syncYearSelectElement(ctx2) {\n        const yearSelectEl = dom.getYearSelectEl(ctx2);\n        dom.setValue(yearSelectEl, ctx2.startValue.year.toString());\n      },\n      setInputValue(ctx2, evt) {\n        if (ctx2.activeIndex !== evt.index) return;\n        ctx2.inputValue = evt.value;\n      },\n      syncInputValue(ctx2, evt) {\n        queueMicrotask(() => {\n          const inputEls = dom.getInputEls(ctx2);\n          const idx = evt.index ?? ctx2.activeIndex;\n          dom.setValue(inputEls[idx], ctx2.inputValue);\n        });\n      },\n      focusParsedDate(ctx2, evt) {\n        if (evt.index == null) return;\n        const date = ctx2.parse(evt.value, {\n          locale: ctx2.locale,\n          timeZone: ctx2.timeZone\n        });\n        if (!date || !isValidDate(date)) return;\n        set.focusedValue(ctx2, date);\n      },\n      selectParsedDate(ctx2, evt) {\n        if (evt.index == null) return;\n        let date = ctx2.parse(evt.value, {\n          locale: ctx2.locale,\n          timeZone: ctx2.timeZone\n        });\n        if (!date || !isValidDate(date)) {\n          if (evt.value) {\n            date = ctx2.focusedValue.copy();\n          }\n        }\n        if (!date) return;\n        const values = Array.from(ctx2.value);\n        values[evt.index] = date;\n        set.value(ctx2, values);\n        set.inputValue(ctx2, evt.index);\n      },\n      resetView(ctx2, _evt, {\n        initialContext\n      }) {\n        set.view(ctx2, initialContext.view);\n      },\n      setStartValue(ctx2) {\n        const outside = isDateOutsideVisibleRange(ctx2.focusedValue, ctx2.startValue, ctx2.endValue);\n        if (!outside) return;\n        const startValue = alignDate(ctx2.focusedValue, \"start\", {\n          months: ctx2.numOfMonths\n        }, ctx2.locale);\n        ctx2.startValue = startValue;\n      },\n      invokeOnOpen(ctx2) {\n        ctx2.onOpenChange?.({\n          open: true\n        });\n      },\n      invokeOnClose(ctx2) {\n        ctx2.onOpenChange?.({\n          open: false\n        });\n      },\n      toggleVisibility(ctx2, evt, {\n        send\n      }) {\n        send({\n          type: ctx2.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: evt\n        });\n      }\n    },\n    compareFns: {\n      startValue: isDateEqual,\n      endValue: isDateEqual,\n      focusedValue: isDateEqual,\n      value: isDateEqualFn\n    }\n  });\n}\nvar invoke = {\n  change(ctx) {\n    ctx.onValueChange?.({\n      value: Array.from(ctx.value),\n      valueAsString: Array.from(ctx.valueAsString),\n      view: ctx.view\n    });\n  },\n  focusChange(ctx) {\n    ctx.onFocusChange?.({\n      focusedValue: ctx.focusedValue,\n      value: Array.from(ctx.value),\n      valueAsString: Array.from(ctx.valueAsString),\n      view: ctx.view\n    });\n  },\n  viewChange(ctx) {\n    ctx.onViewChange?.({\n      view: ctx.view\n    });\n  }\n};\nvar isDateEqualFn = (a, b) => {\n  if (a.length !== b.length) return false;\n  return a.every((date, index) => isDateEqual(date, b[index]));\n};\nvar normalizeValue = (ctx, value) => {\n  let dateValue = typeof value === \"number\" ? ctx.focusedValue.set({\n    [ctx.view]: value\n  }) : value;\n  eachView(view => {\n    if (isBelowMinView(view, ctx.minView)) {\n      dateValue = dateValue.set({\n        [view]: view === \"day\" ? 1 : 0\n      });\n    }\n  });\n  return dateValue;\n};\nvar set = {\n  value(ctx, value) {\n    if (isDateEqualFn(ctx.value, value)) return;\n    ctx.value = value;\n    invoke.change(ctx);\n  },\n  focusedValue(ctx, mixedValue) {\n    if (!mixedValue) return;\n    const value = normalizeValue(ctx, mixedValue);\n    if (isDateEqual(ctx.focusedValue, value)) return;\n    const adjustFn = getAdjustedDateFn(ctx.visibleDuration, ctx.locale, ctx.min, ctx.max);\n    const adjustedValue = adjustFn({\n      focusedDate: value,\n      startDate: ctx.startValue\n    });\n    ctx.startValue = adjustedValue.startDate;\n    ctx.focusedValue = adjustedValue.focusedDate;\n    invoke.focusChange(ctx);\n  },\n  adjustedValue(ctx, value) {\n    ctx.startValue = value.startDate;\n    if (isDateEqual(ctx.focusedValue, value.focusedDate)) return;\n    ctx.focusedValue = value.focusedDate;\n    invoke.focusChange(ctx);\n  },\n  view(ctx, value) {\n    if (isEqual(ctx.view, value)) return;\n    ctx.view = value;\n    invoke.viewChange(ctx);\n  },\n  inputValue(ctx, index) {\n    const value = ctx.valueAsString[index];\n    if (ctx.inputValue === value) return;\n    ctx.inputValue = value;\n  }\n};\nfunction parse(value) {\n  if (Array.isArray(value)) {\n    return value.map(v => parse(v));\n  }\n  if (value instanceof Date) {\n    return new CalendarDate(value.getFullYear(), value.getMonth() + 1, value.getDate());\n  }\n  return parseDate(value);\n}\nvar props = createProps()([\"closeOnSelect\", \"dir\", \"disabled\", \"fixedWeeks\", \"focusedValue\", \"format\", \"parse\", \"placeholder\", \"getRootNode\", \"id\", \"ids\", \"isDateUnavailable\", \"isDateUnavailable\", \"locale\", \"max\", \"min\", \"name\", \"numOfMonths\", \"onFocusChange\", \"onOpenChange\", \"onValueChange\", \"onViewChange\", \"open\", \"open.controlled\", \"positioning\", \"readOnly\", \"selectionMode\", \"startOfWeek\", \"timeZone\", \"translations\", \"value\", \"view\", \"minView\", \"maxView\"]);\nvar splitProps = createSplitProps(props);\nvar inputProps = createProps()([\"index\", \"fixOnBlur\"]);\nvar splitInputProps = createSplitProps(inputProps);\nvar presetTriggerProps = createProps()([\"value\"]);\nvar splitPresetTriggerProps = createSplitProps(presetTriggerProps);\nvar tableProps = createProps()([\"columns\", \"id\", \"view\"]);\nvar splitTableProps = createSplitProps(tableProps);\nvar tableCellProps = createProps()([\"disabled\", \"value\", \"columns\"]);\nvar splitTableCellProps = createSplitProps(tableCellProps);\nvar viewProps = createProps()([\"view\"]);\nvar splitViewProps = createSplitProps(viewProps);\nexport { anatomy, connect, inputProps, machine, parse, presetTriggerProps, props, splitInputProps, splitPresetTriggerProps, splitProps, splitTableCellProps, splitTableProps, splitViewProps, tableCellProps, tableProps, viewProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
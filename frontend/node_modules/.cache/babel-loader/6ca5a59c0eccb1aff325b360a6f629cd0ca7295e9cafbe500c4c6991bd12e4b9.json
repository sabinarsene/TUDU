{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { mergeProps, createMachine, ref, guards } from '@zag-js/core';\nimport { createScope, dataAttr, contains, isHTMLElement, raf, getComputedStyle as getComputedStyle$1, getWindow, getDocument } from '@zag-js/dom-query';\nimport { getPlacementStyles, getPlacement } from '@zag-js/popper';\nimport { trackDismissableBranch } from '@zag-js/dismissable';\nimport { trapFocus } from '@zag-js/focus-trap';\nimport { trackInteractOutside } from '@zag-js/interact-outside';\nimport { createSplitProps, compact, isString, nextIndex, prevIndex, isEqual } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/tour.anatomy.ts\nvar anatomy = createAnatomy(\"tour\").parts(\"content\", \"actionTrigger\", \"closeTrigger\", \"progressText\", \"title\", \"description\", \"positioner\", \"arrow\", \"arrowTip\", \"backdrop\", \"spotlight\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getPositionerId: ctx => ctx.ids?.positioner ?? `tour-positioner-${ctx.id}`,\n  getContentId: ctx => ctx.ids?.content ?? `tour-content-${ctx.id}`,\n  getTitleId: ctx => ctx.ids?.title ?? `tour-title-${ctx.id}`,\n  getDescriptionId: ctx => ctx.ids?.description ?? `tour-desc-${ctx.id}`,\n  getArrowId: ctx => ctx.ids?.arrow ?? `tour-arrow-${ctx.id}`,\n  getBackdropId: ctx => ctx.ids?.backdrop ?? `tour-backdrop-${ctx.id}`,\n  getContentEl: ctx => dom.getById(ctx, dom.getContentId(ctx)),\n  getPositionerEl: ctx => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getBackdropEl: ctx => dom.getById(ctx, dom.getBackdropId(ctx))\n});\n\n// src/utils/clip-path.ts\nfunction getClipPath(options) {\n  const {\n    radius = 0,\n    rootSize: {\n      width: w,\n      height: h\n    },\n    rect: {\n      width,\n      height,\n      x,\n      y\n    },\n    enabled = true\n  } = options;\n  if (!enabled) return \"\";\n  const {\n    topLeft = 0,\n    topRight = 0,\n    bottomRight = 0,\n    bottomLeft = 0\n  } = typeof radius === \"number\" ? {\n    topLeft: radius,\n    topRight: radius,\n    bottomRight: radius,\n    bottomLeft: radius\n  } : radius;\n  return `M${w},${h}  H0  V0  H${w}  V${h}  Z  M${x + topLeft},${y}  a${topLeft},${topLeft},0,0,0-${topLeft},${topLeft}  V${height + y - bottomLeft}  a${bottomLeft},${bottomLeft},0,0,0,${bottomLeft},${bottomLeft}  H${width + x - bottomRight}  a${bottomRight},${bottomRight},0,0,0,${bottomRight}-${bottomRight}  V${y + topRight}  a${topRight},${topRight},0,0,0-${topRight}-${topRight}  Z`;\n}\n\n// src/utils/step.ts\nvar isTooltipStep = step => {\n  return step?.type === \"tooltip\";\n};\nvar isDialogStep = step => {\n  return step?.type === \"dialog\";\n};\nvar isTooltipPlacement = placement => {\n  return placement != null && placement != \"center\";\n};\nvar normalizeStep = step => {\n  if (step.type === \"floating\") {\n    return {\n      backdrop: false,\n      arrow: false,\n      placement: \"bottom-end\",\n      ...step\n    };\n  }\n  if (step.target == null || step.type === \"dialog\") {\n    return {\n      type: \"dialog\",\n      placement: \"center\",\n      backdrop: true,\n      ...step\n    };\n  }\n  if (!step.type || step.type === \"tooltip\") {\n    return {\n      type: \"tooltip\",\n      arrow: true,\n      backdrop: true,\n      ...step\n    };\n  }\n  return step;\n};\nvar findStep = (steps, id) => {\n  const res = id != null ? steps.find(step => step.id === id) : null;\n  return res ? normalizeStep(res) : null;\n};\nvar findStepIndex = (steps, id) => {\n  return id != null ? steps.findIndex(step => step.id === id) : -1;\n};\n\n// src/tour.connect.ts\nfunction connect(state, send, normalize) {\n  const open = state.hasTag(\"open\");\n  const steps = Array.from(state.context.steps);\n  const stepIndex = state.context.stepIndex;\n  const step = state.context.step;\n  const hasTarget = typeof step?.target?.() !== \"undefined\";\n  const hasNextStep = state.context.hasNextStep;\n  const hasPrevStep = state.context.hasPrevStep;\n  const firstStep = state.context.isFirstStep;\n  const lastStep = state.context.isLastStep;\n  const placement = state.context.currentPlacement;\n  const targetRect = state.context.targetRect;\n  const popperStyles = getPlacementStyles({\n    strategy: \"absolute\",\n    placement: isTooltipPlacement(placement) ? placement : void 0\n  });\n  const clipPath = getClipPath({\n    enabled: isTooltipStep(step),\n    rect: targetRect,\n    rootSize: state.context.boundarySize,\n    radius: state.context.spotlightRadius\n  });\n  const actionMap = {\n    next() {\n      send({\n        type: \"STEP.NEXT\",\n        src: \"actionTrigger\"\n      });\n    },\n    prev() {\n      send({\n        type: \"STEP.PREV\",\n        src: \"actionTrigger\"\n      });\n    },\n    dismiss() {\n      send({\n        type: \"DISMISS\",\n        src: \"actionTrigger\"\n      });\n    },\n    goto(id) {\n      send({\n        type: \"STEP.SET\",\n        value: id,\n        src: \"actionTrigger\"\n      });\n    }\n  };\n  return {\n    open,\n    totalSteps: steps.length,\n    stepIndex,\n    step,\n    hasNextStep,\n    hasPrevStep,\n    firstStep,\n    lastStep,\n    addStep(step2) {\n      const next = steps.concat(step2);\n      send({\n        type: \"STEPS.SET\",\n        value: next,\n        src: \"addStep\"\n      });\n    },\n    removeStep(id) {\n      const next = steps.filter(step2 => step2.id !== id);\n      send({\n        type: \"STEPS.SET\",\n        value: next,\n        src: \"removeStep\"\n      });\n    },\n    updateStep(id, stepOverrides) {\n      const next = steps.map(step2 => step2.id === id ? mergeProps(step2, stepOverrides) : step2);\n      send({\n        type: \"STEPS.SET\",\n        value: next,\n        src: \"updateStep\"\n      });\n    },\n    setSteps(steps2) {\n      send({\n        type: \"STEPS.SET\",\n        value: steps2,\n        src: \"setSteps\"\n      });\n    },\n    setStep(id) {\n      send({\n        type: \"STEP.SET\",\n        value: id\n      });\n    },\n    start(id) {\n      send({\n        type: \"START\",\n        id\n      });\n    },\n    isValidStep(id) {\n      return steps.some(step2 => step2.id === id);\n    },\n    isCurrentStep(id) {\n      return Boolean(step?.id === id);\n    },\n    next() {\n      send({\n        type: \"STEP.NEXT\"\n      });\n    },\n    prev() {\n      send({\n        type: \"STEP.PREV\"\n      });\n    },\n    getProgressPercent() {\n      return stepIndex / steps.length * 100;\n    },\n    getProgressText() {\n      const effectiveSteps = steps.filter(step2 => step2.type !== \"wait\");\n      const index = findStepIndex(effectiveSteps, step?.id);\n      const details = {\n        current: index,\n        total: effectiveSteps.length\n      };\n      return state.context.translations.progressText?.(details) ?? \"\";\n    },\n    getBackdropProps() {\n      return normalize.element({\n        ...parts.backdrop.attrs,\n        id: dom.getBackdropId(state.context),\n        dir: state.context.dir,\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-type\": step?.type,\n        style: {\n          \"--tour-layer\": 0,\n          clipPath: isTooltipStep(step) ? `path(\"${clipPath}\")` : void 0,\n          position: \"absolute\",\n          inset: \"0\",\n          willChange: \"clip-path\"\n        }\n      });\n    },\n    getSpotlightProps() {\n      return normalize.element({\n        ...parts.spotlight.attrs,\n        hidden: !open || !step?.target?.(),\n        style: {\n          \"--tour-layer\": 1,\n          position: \"absolute\",\n          width: `${targetRect.width}px`,\n          height: `${targetRect.height}px`,\n          left: `${targetRect.x}px`,\n          top: `${targetRect.y}px`,\n          borderRadius: `${state.context.spotlightRadius}px`,\n          pointerEvents: \"none\"\n        }\n      });\n    },\n    getProgressTextProps() {\n      return normalize.element({\n        ...parts.progressText.attrs\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        ...parts.positioner.attrs,\n        dir: state.context.dir,\n        id: dom.getPositionerId(state.context),\n        \"data-type\": step?.type,\n        \"data-placement\": state.context.currentPlacement,\n        style: {\n          \"--tour-layer\": 2,\n          ...(step?.type === \"tooltip\" && popperStyles.floating)\n        }\n      });\n    },\n    getArrowProps() {\n      return normalize.element({\n        id: dom.getArrowId(state.context),\n        ...parts.arrow.attrs,\n        dir: state.context.dir,\n        hidden: step?.type !== \"tooltip\",\n        style: step?.type === \"tooltip\" ? popperStyles.arrow : void 0,\n        opacity: hasTarget ? void 0 : 0\n      });\n    },\n    getArrowTipProps() {\n      return normalize.element({\n        ...parts.arrowTip.attrs,\n        dir: state.context.dir,\n        style: popperStyles.arrowTip\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        id: dom.getContentId(state.context),\n        dir: state.context.dir,\n        role: \"alertdialog\",\n        \"aria-modal\": \"true\",\n        \"aria-live\": \"polite\",\n        \"aria-atomic\": \"true\",\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-type\": step?.type,\n        \"data-placement\": state.context.currentPlacement,\n        \"data-step\": step?.id,\n        \"aria-labelledby\": dom.getTitleId(state.context),\n        \"aria-describedby\": dom.getDescriptionId(state.context),\n        tabIndex: -1,\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!state.context.keyboardNavigation) return;\n          const isRtl = state.context.dir === \"rtl\";\n          switch (event.key) {\n            case \"ArrowRight\":\n              if (!hasNextStep) return;\n              send({\n                type: isRtl ? \"STEP.PREV\" : \"STEP.NEXT\",\n                src: \"keydown\"\n              });\n              break;\n            case \"ArrowLeft\":\n              if (!hasPrevStep) return;\n              send({\n                type: isRtl ? \"STEP.NEXT\" : \"STEP.PREV\",\n                src: \"keydown\"\n              });\n              break;\n          }\n        }\n      });\n    },\n    getTitleProps() {\n      return normalize.element({\n        ...parts.title.attrs,\n        id: dom.getTitleId(state.context),\n        \"data-placement\": hasTarget ? state.context.currentPlacement : \"center\"\n      });\n    },\n    getDescriptionProps() {\n      return normalize.element({\n        ...parts.description.attrs,\n        id: dom.getDescriptionId(state.context),\n        \"data-placement\": hasTarget ? state.context.currentPlacement : \"center\"\n      });\n    },\n    getCloseTriggerProps() {\n      return normalize.element({\n        ...parts.closeTrigger.attrs,\n        \"data-type\": step?.type,\n        \"aria-label\": state.context.translations.close,\n        onClick: actionMap.dismiss\n      });\n    },\n    getActionTriggerProps(props2) {\n      const {\n        action,\n        attrs\n      } = props2.action;\n      let actionProps = {};\n      switch (action) {\n        case \"next\":\n          actionProps = {\n            \"data-type\": \"next\",\n            disabled: !hasNextStep,\n            \"data-disabled\": dataAttr(!hasNextStep),\n            \"aria-label\": state.context.translations.nextStep,\n            onClick: actionMap.next\n          };\n          break;\n        case \"prev\":\n          actionProps = {\n            \"data-type\": \"prev\",\n            disabled: !hasPrevStep,\n            \"data-disabled\": dataAttr(!hasPrevStep),\n            \"aria-label\": state.context.translations.prevStep,\n            onClick: actionMap.prev\n          };\n          break;\n        case \"dismiss\":\n          actionProps = {\n            \"data-type\": \"close\",\n            \"aria-label\": state.context.translations.close,\n            onClick: actionMap.dismiss\n          };\n          break;\n        default:\n          actionProps = {\n            \"data-type\": \"custom\",\n            onClick() {\n              if (typeof action === \"function\") {\n                action(actionMap);\n              }\n            }\n          };\n          break;\n      }\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        type: \"button\",\n        ...attrs,\n        ...actionProps\n      });\n    }\n  };\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\nvar normalizeEventPoint = event => {\n  let clientX = event.clientX;\n  let clientY = event.clientY;\n  let win = event.view || window;\n  let frame = getFrameElement(win);\n  while (frame) {\n    const iframeRect = frame.getBoundingClientRect();\n    const css = getComputedStyle(frame);\n    const left = iframeRect.left + (frame.clientLeft + parseFloat(css.paddingLeft));\n    const top = iframeRect.top + (frame.clientTop + parseFloat(css.paddingTop));\n    clientX += left;\n    clientY += top;\n    win = getWindow(frame);\n    frame = getFrameElement(win);\n  }\n  return {\n    clientX,\n    clientY\n  };\n};\nfunction isEventInRect(rect, event) {\n  const {\n    clientX,\n    clientY\n  } = normalizeEventPoint(event);\n  return rect.y <= clientY && clientY <= rect.y + rect.height && rect.x <= clientX && clientX <= rect.x + rect.width;\n}\nfunction offset(r, i) {\n  const dx = i.x || 0;\n  const dy = i.y || 0;\n  return {\n    x: r.x - dx,\n    y: r.y - dy,\n    width: r.width + dx + dx,\n    height: r.height + dy + dy\n  };\n}\n\n// src/tour.machine.ts\nvar {\n  and\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"tour\",\n    initial: \"tour.inactive\",\n    context: {\n      stepId: null,\n      steps: [],\n      preventInteraction: false,\n      closeOnInteractOutside: true,\n      closeOnEscape: true,\n      keyboardNavigation: true,\n      spotlightOffset: {\n        x: 10,\n        y: 10\n      },\n      spotlightRadius: 4,\n      translations: {\n        nextStep: \"next step\",\n        prevStep: \"previous step\",\n        close: \"close tour\",\n        progressText: ({\n          current,\n          total\n        }) => `${current + 1} of ${total}`,\n        skip: \"skip tour\",\n        ...ctx.translations\n      },\n      ...ctx,\n      resolvedTarget: ref({\n        value: null\n      }),\n      targetRect: ref({\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      }),\n      boundarySize: ref({\n        width: 0,\n        height: 0\n      })\n    },\n    computed: {\n      stepIndex: ctx2 => findStepIndex(ctx2.steps, ctx2.stepId),\n      step: ctx2 => findStep(ctx2.steps, ctx2.stepId),\n      hasNextStep: ctx2 => ctx2.stepIndex < ctx2.steps.length - 1,\n      hasPrevStep: ctx2 => ctx2.stepIndex > 0,\n      isFirstStep: ctx2 => ctx2.stepIndex === 0,\n      isLastStep: ctx2 => ctx2.stepIndex === ctx2.steps.length - 1\n    },\n    created: [\"validateSteps\"],\n    watch: {\n      stepId: [\"setResolvedTarget\", \"raiseStepChange\", \"syncTargetAttrs\"]\n    },\n    activities: [\"trackBoundarySize\"],\n    exit: [\"clearStep\", \"cleanupFns\"],\n    on: {\n      \"STEPS.SET\": {\n        actions: [\"setSteps\"]\n      },\n      \"STEP.SET\": {\n        actions: [\"setStep\"]\n      },\n      \"STEP.NEXT\": {\n        actions: [\"setNextStep\"]\n      },\n      \"STEP.PREV\": {\n        actions: [\"setPrevStep\"]\n      },\n      \"STEP.CHANGED\": [{\n        guard: and(\"isValidStep\", \"hasResolvedTarget\"),\n        target: \"target.scrolling\"\n      }, {\n        guard: and(\"isValidStep\", \"hasTarget\"),\n        target: \"target.resolving\"\n      }, {\n        guard: and(\"isValidStep\", \"isWaitingStep\"),\n        target: \"step.waiting\"\n      }, {\n        guard: \"isValidStep\",\n        target: \"tour.active\"\n      }],\n      DISMISS: [{\n        guard: \"isLastStep\",\n        target: \"tour.inactive\",\n        actions: [\"invokeOnDismiss\", \"invokeOnComplete\", \"clearStep\"]\n      }, {\n        target: \"tour.inactive\",\n        actions: [\"invokeOnDismiss\", \"clearStep\"]\n      }]\n    },\n    states: {\n      \"tour.inactive\": {\n        tags: [\"closed\"],\n        on: {\n          START: {\n            actions: [\"setInitialStep\", \"invokeOnStart\"]\n          }\n        }\n      },\n      \"target.resolving\": {\n        tags: [\"closed\"],\n        activities: [\"waitForTarget\"],\n        after: {\n          MISSING_TARGET_TIMEOUT: {\n            target: \"tour.inactive\",\n            actions: [\"invokeOnNotFound\", \"clearStep\"]\n          }\n        },\n        on: {\n          \"TARGET.RESOLVED\": {\n            target: \"target.scrolling\",\n            actions: [\"setResolvedTarget\"]\n          }\n        }\n      },\n      \"target.scrolling\": {\n        tags: [\"open\"],\n        entry: [\"scrollToTarget\"],\n        activities: [\"trapFocus\", \"trackPlacement\", \"trackDismissableBranch\", \"trackInteractOutside\", \"trackEscapeKeydown\"],\n        after: {\n          100: \"tour.active\"\n        }\n      },\n      \"step.waiting\": {\n        tags: [\"closed\"]\n      },\n      \"tour.active\": {\n        tags: [\"open\"],\n        activities: [\"trapFocus\", \"trackPlacement\", \"trackDismissableBranch\", \"trackInteractOutside\", \"trackEscapeKeydown\"]\n      }\n    }\n  }, {\n    delays: {\n      MISSING_TARGET_TIMEOUT: 3e3\n    },\n    guards: {\n      isLastStep: ctx2 => ctx2.isLastStep,\n      isValidStep: ctx2 => ctx2.stepId != null,\n      hasTarget: ctx2 => ctx2.step?.target != null,\n      hasResolvedTarget: ctx2 => ctx2.resolvedTarget.value != null,\n      isWaitingStep: ctx2 => ctx2.step?.type === \"wait\"\n    },\n    actions: {\n      scrollToTarget(ctx2, _evt) {\n        const node = ctx2.resolvedTarget.value;\n        node?.scrollIntoView({\n          behavior: \"instant\",\n          block: \"center\",\n          inline: \"center\"\n        });\n      },\n      setStep(ctx2, evt) {\n        set.step(ctx2, evt.value);\n      },\n      clearStep(ctx2) {\n        ctx2.targetRect = ref({\n          width: 0,\n          height: 0,\n          x: 0,\n          y: 0\n        });\n        set.step(ctx2, -1);\n      },\n      setInitialStep(ctx2, evt) {\n        if (ctx2.steps.length === 0) return;\n        if (isString(evt.id)) {\n          const idx = findStepIndex(ctx2.steps, evt.id);\n          set.step(ctx2, idx);\n          return;\n        }\n        set.step(ctx2, 0);\n      },\n      setNextStep(ctx2) {\n        const idx = nextIndex(ctx2.steps, ctx2.stepIndex);\n        set.step(ctx2, idx);\n      },\n      setPrevStep(ctx2) {\n        const idx = prevIndex(ctx2.steps, ctx2.stepIndex);\n        set.step(ctx2, idx);\n      },\n      invokeOnStart(ctx2) {\n        invoke.statusChange(ctx2, \"started\");\n      },\n      invokeOnDismiss(ctx2) {\n        invoke.statusChange(ctx2, \"dismissed\");\n      },\n      invokeOnComplete(ctx2) {\n        invoke.statusChange(ctx2, \"completed\");\n      },\n      invokeOnSkip(ctx2) {\n        invoke.statusChange(ctx2, \"skipped\");\n      },\n      invokeOnNotFound(ctx2) {\n        invoke.statusChange(ctx2, \"not-found\");\n      },\n      raiseStepChange(_ctx, _evt, {\n        send\n      }) {\n        send({\n          type: \"STEP.CHANGED\"\n        });\n      },\n      setResolvedTarget(ctx2, evt) {\n        const node = evt.node ?? ctx2.step?.target?.();\n        ctx2.resolvedTarget.value = node ?? null;\n      },\n      syncTargetAttrs(ctx2) {\n        ctx2._targetCleanup?.();\n        ctx2._targetCleanup = void 0;\n        const targetEl = ctx2.resolvedTarget.value;\n        if (!targetEl) return;\n        if (ctx2.preventInteraction) targetEl.inert = true;\n        targetEl.setAttribute(\"data-tour-highlighted\", \"\");\n        ctx2._targetCleanup = () => {\n          if (ctx2.preventInteraction) targetEl.inert = false;\n          targetEl.removeAttribute(\"data-tour-highlighted\");\n        };\n      },\n      cleanupFns(ctx2) {\n        ctx2._targetCleanup?.();\n        ctx2._targetCleanup = void 0;\n        ctx2._effectCleanup?.();\n        ctx2._effectCleanup = void 0;\n      },\n      validateSteps(ctx2) {\n        const ids = /* @__PURE__ */new Set();\n        ctx2.steps.forEach(step => {\n          if (ids.has(step.id)) {\n            throw new Error(`[zag-js/tour] Duplicate step id: ${step.id}`);\n          }\n          if (step.target == null && step.type == null) {\n            throw new Error(`[zag-js/tour] Step ${step.id} has no target or type. At least one of those is required.`);\n          }\n          ids.add(step.id);\n        });\n      }\n    },\n    activities: {\n      waitForTarget(ctx2, _evt, {\n        send\n      }) {\n        const targetEl = ctx2.step?.target;\n        const win = dom.getWin(ctx2);\n        const rootNode = dom.getRootNode(ctx2);\n        const observer = new win.MutationObserver(() => {\n          const node = targetEl?.();\n          if (node) {\n            send({\n              type: \"TARGET.RESOLVED\",\n              node\n            });\n            observer.disconnect();\n          }\n        });\n        observer.observe(rootNode, {\n          childList: true,\n          subtree: true,\n          characterData: true\n        });\n        return () => {\n          observer.disconnect();\n        };\n      },\n      trackBoundarySize(ctx2) {\n        const win = dom.getWin(ctx2);\n        const doc = dom.getDoc(ctx2);\n        const onResize = () => {\n          const width = visualViewport?.width ?? win.innerWidth;\n          const height = doc.documentElement.scrollHeight;\n          ctx2.boundarySize = {\n            width,\n            height\n          };\n        };\n        onResize();\n        const viewport = win.visualViewport ?? win;\n        viewport.addEventListener(\"resize\", onResize);\n        return () => viewport.removeEventListener(\"resize\", onResize);\n      },\n      trackEscapeKeydown(ctx2, _evt, {\n        send\n      }) {\n        if (!ctx2.closeOnEscape) return;\n        const doc = dom.getDoc(ctx2);\n        const onKeyDown = event => {\n          if (event.key === \"Escape\") {\n            event.preventDefault();\n            event.stopPropagation();\n            send({\n              type: \"DISMISS\",\n              src: \"esc\"\n            });\n          }\n        };\n        doc.addEventListener(\"keydown\", onKeyDown, true);\n        return () => {\n          doc.removeEventListener(\"keydown\", onKeyDown, true);\n        };\n      },\n      trackInteractOutside(ctx2, _evt, {\n        send\n      }) {\n        if (ctx2.step == null) return;\n        const contentEl = () => dom.getContentEl(ctx2);\n        return trackInteractOutside(contentEl, {\n          defer: true,\n          exclude(target) {\n            return contains(ctx2.step?.target?.(), target);\n          },\n          onFocusOutside(event) {\n            ctx2.onFocusOutside?.(event);\n            if (!ctx2.closeOnInteractOutside) {\n              event.preventDefault();\n            }\n          },\n          onPointerDownOutside(event) {\n            ctx2.onPointerDownOutside?.(event);\n            const isWithin = isEventInRect(ctx2.targetRect, event.detail.originalEvent);\n            if (isWithin) {\n              event.preventDefault();\n              return;\n            }\n            if (!ctx2.closeOnInteractOutside) {\n              event.preventDefault();\n            }\n          },\n          onInteractOutside(event) {\n            ctx2.onInteractOutside?.(event);\n            if (event.defaultPrevented) return;\n            send({\n              type: \"DISMISS\",\n              src: \"interact-outside\"\n            });\n          }\n        });\n      },\n      trackDismissableBranch(ctx2) {\n        if (ctx2.step == null) return;\n        const contentEl = () => dom.getContentEl(ctx2);\n        return trackDismissableBranch(contentEl, {\n          defer: !contentEl()\n        });\n      },\n      trapFocus(ctx2) {\n        const contentEl = () => dom.getContentEl(ctx2);\n        return trapFocus(contentEl, {\n          escapeDeactivates: false,\n          allowOutsideClick: true,\n          preventScroll: true,\n          returnFocusOnDeactivate: false\n        });\n      },\n      trackPlacement(ctx2) {\n        if (ctx2.step == null) return;\n        ctx2.currentPlacement = ctx2.step.placement ?? \"bottom\";\n        if (isDialogStep(ctx2.step)) return syncZIndex(ctx2);\n        if (!isTooltipStep(ctx2.step)) return;\n        const positionerEl = () => dom.getPositionerEl(ctx2);\n        return getPlacement(ctx2.resolvedTarget.value, positionerEl, {\n          defer: true,\n          placement: ctx2.step.placement ?? \"bottom\",\n          strategy: \"absolute\",\n          gutter: 10,\n          offset: ctx2.step.offset,\n          getAnchorRect(el) {\n            if (!isHTMLElement(el)) return null;\n            const rect = el.getBoundingClientRect();\n            return offset(rect, ctx2.spotlightOffset);\n          },\n          onComplete(data) {\n            const {\n              rects\n            } = data.middlewareData;\n            ctx2.currentPlacement = data.placement;\n            ctx2.targetRect = rects.reference;\n          }\n        });\n      }\n    }\n  });\n}\nfunction syncZIndex(ctx) {\n  return raf(() => {\n    const contentEl = dom.getContentEl(ctx);\n    if (!contentEl) return;\n    const styles = getComputedStyle$1(contentEl);\n    const positionerEl = dom.getPositionerEl(ctx);\n    const backdropEl = dom.getBackdropEl(ctx);\n    if (positionerEl) {\n      positionerEl.style.setProperty(\"--z-index\", styles.zIndex);\n      positionerEl.style.setProperty(\"z-index\", \"var(--z-index)\");\n    }\n    if (backdropEl) {\n      backdropEl.style.setProperty(\"--z-index\", styles.zIndex);\n    }\n  });\n}\nvar invoke = {\n  stepChange(ctx) {\n    const effectiveLength = ctx.steps.filter(step => step.type !== \"wait\").length;\n    const progress = (ctx.stepIndex + 1) / effectiveLength;\n    ctx.onStepChange?.({\n      complete: ctx.isLastStep,\n      stepId: ctx.stepId,\n      totalSteps: ctx.steps.length,\n      stepIndex: ctx.stepIndex,\n      progress\n    });\n    ctx._effectCleanup?.();\n    ctx._effectCleanup = void 0;\n  },\n  statusChange(ctx, status) {\n    ctx.onStatusChange?.({\n      status,\n      stepId: ctx.stepId,\n      stepIndex: ctx.stepIndex\n    });\n  }\n};\nvar set = {\n  step(ctx, idx) {\n    const step = ctx.steps[idx];\n    if (!step) {\n      ctx.stepId = null;\n      invoke.stepChange(ctx);\n      return;\n    }\n    if (isEqual(ctx.stepId, step.id)) return;\n    const update = data => {\n      ctx.steps[idx] = {\n        ...step,\n        ...data\n      };\n    };\n    const next = () => {\n      const idx2 = nextIndex(ctx.steps, ctx.stepIndex);\n      ctx.stepId = ctx.steps[idx2].id;\n      invoke.stepChange(ctx);\n    };\n    const goto = id => {\n      const idx2 = ctx.steps.findIndex(s => s.id === id);\n      ctx.stepId = ctx.steps[idx2].id;\n      invoke.stepChange(ctx);\n    };\n    const dismiss = () => {\n      ctx.stepId = null;\n      invoke.stepChange(ctx);\n      invoke.statusChange(ctx, \"dismissed\");\n    };\n    const show = () => {\n      ctx.stepId = step.id;\n      invoke.stepChange(ctx);\n    };\n    if (!step.effect) {\n      show();\n      return;\n    }\n    ctx._effectCleanup = step.effect({\n      show,\n      next,\n      update,\n      target: step.target,\n      dismiss,\n      goto\n    });\n  }\n};\nvar props = createProps()([\"closeOnEscape\", \"closeOnInteractOutside\", \"dir\", \"getRootNode\", \"id\", \"ids\", \"keyboardNavigation\", \"onFocusOutside\", \"onInteractOutside\", \"onPointerDownOutside\", \"onStatusChange\", \"onStepChange\", \"preventInteraction\", \"spotlightOffset\", \"spotlightRadius\", \"stepId\", \"steps\", \"translations\"]);\nvar splitProps = createSplitProps(props);\nfunction waitForPromise(promise, controller, timeout) {\n  const {\n    signal\n  } = controller;\n  const wrappedPromise = new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject(new Error(`Timeout of ${timeout}ms exceeded`));\n    }, timeout);\n    signal.addEventListener(\"abort\", () => {\n      clearTimeout(timeoutId);\n      reject(new Error(\"Promise aborted\"));\n    });\n    promise.then(result => {\n      if (!signal.aborted) {\n        clearTimeout(timeoutId);\n        resolve(result);\n      }\n    }).catch(error => {\n      if (!signal.aborted) {\n        clearTimeout(timeoutId);\n        reject(error);\n      }\n    });\n  });\n  const abort = () => controller.abort();\n  return [wrappedPromise, abort];\n}\nfunction waitForElement(target, options) {\n  const {\n    timeout,\n    rootNode\n  } = options;\n  const win = getWindow(rootNode);\n  const doc = getDocument(rootNode);\n  const controller = new win.AbortController();\n  return waitForPromise(new Promise(resolve => {\n    const el = target();\n    if (el) {\n      resolve(el);\n      return;\n    }\n    const observer = new win.MutationObserver(() => {\n      const el2 = target();\n      if (el2) {\n        observer.disconnect();\n        resolve(el2);\n      }\n    });\n    observer.observe(doc.body, {\n      childList: true,\n      subtree: true\n    });\n  }), controller, timeout);\n}\nfunction waitForElementValue(target, value, options) {\n  const {\n    timeout,\n    rootNode\n  } = options;\n  const win = getWindow(rootNode);\n  const controller = new win.AbortController();\n  return waitForPromise(new Promise(resolve => {\n    const el = target();\n    if (!el) return;\n    const checkValue = () => {\n      if (el.value === value) {\n        resolve();\n        el.removeEventListener(\"input\", checkValue);\n      }\n    };\n    checkValue();\n    el.addEventListener(\"input\", checkValue, {\n      signal: controller.signal\n    });\n  }), controller, timeout);\n}\nexport { anatomy, connect, machine, props, splitProps, waitForElement, waitForElementValue };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
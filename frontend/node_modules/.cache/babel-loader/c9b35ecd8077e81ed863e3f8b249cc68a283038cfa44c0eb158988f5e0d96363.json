{"ast":null,"code":"\"use strict\";\n\nimport { isString } from '../utils/is.js';\nimport { calc } from './calc.js';\nimport { toPx } from './unit-conversion.js';\nconst addNegativeTokens = {\n  enforce: \"pre\",\n  transform(dictionary) {\n    const {\n      prefix,\n      allTokens,\n      formatCssVar,\n      formatTokenName,\n      registerToken\n    } = dictionary;\n    const tokens = allTokens.filter(({\n      extensions\n    }) => extensions.category === \"spacing\");\n    tokens.forEach(token => {\n      const originalPath = token.path.slice();\n      const originalVar = formatCssVar(originalPath, prefix);\n      if (isString(token.value) && token.value === \"0rem\") {\n        return;\n      }\n      const nextToken = structuredClone(token);\n      Object.assign(nextToken.extensions, {\n        negative: true,\n        prop: `-${token.extensions.prop}`,\n        originalPath\n      });\n      nextToken.value = calc.negate(originalVar.ref);\n      const lastPath = nextToken.path[nextToken.path.length - 1];\n      if (lastPath != null) {\n        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;\n      }\n      if (nextToken.path) {\n        nextToken.name = formatTokenName(nextToken.path);\n      }\n      registerToken(nextToken);\n    });\n  }\n};\nconst units = /* @__PURE__ */new Set([\"spacing\", \"sizes\", \"borderWidths\", \"fontSizes\", \"radii\"]);\nconst addPixelUnit = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const tokens = dictionary.allTokens.filter(token => {\n      return units.has(token.extensions.category) && !token.extensions.negative;\n    });\n    tokens.forEach(token => {\n      Object.assign(token.extensions, {\n        pixelValue: toPx(token.value)\n      });\n    });\n  }\n};\nconst addVirtualPalette = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const {\n      allTokens,\n      registerToken,\n      formatTokenName\n    } = dictionary;\n    const tokens = allTokens.filter(({\n      extensions\n    }) => extensions.category === \"colors\");\n    const keys = /* @__PURE__ */new Map();\n    const colorPalettes = /* @__PURE__ */new Map();\n    tokens.forEach(token => {\n      const {\n        colorPalette\n      } = token.extensions;\n      if (!colorPalette) return;\n      colorPalette.keys.forEach(keyPath => {\n        keys.set(formatTokenName(keyPath), keyPath);\n      });\n      colorPalette.roots.forEach(colorPaletteRoot => {\n        const name = formatTokenName(colorPaletteRoot);\n        const colorPaletteList = colorPalettes.get(name) || [];\n        colorPaletteList.push(token);\n        colorPalettes.set(name, colorPaletteList);\n        if (token.extensions.default && colorPaletteRoot.length === 1) {\n          const keyPath = colorPalette.keys[0]?.filter(Boolean);\n          if (!keyPath.length) return;\n          const path = colorPaletteRoot.concat(keyPath);\n          keys.set(formatTokenName(path), []);\n        }\n      });\n    });\n    keys.forEach(segments => {\n      const path = [\"colors\", \"colorPalette\", ...segments].filter(Boolean);\n      const name = formatTokenName(path);\n      const prop = formatTokenName(path.slice(1));\n      const token = {\n        name,\n        value: name,\n        originalValue: name,\n        path,\n        extensions: {\n          condition: \"base\",\n          originalPath: path,\n          category: \"colors\",\n          prop,\n          virtual: true\n        }\n      };\n      registerToken(token, \"pre\");\n    });\n  }\n};\nconst removeEmptyTokens = {\n  enforce: \"post\",\n  transform(dictionary) {\n    dictionary.allTokens = dictionary.allTokens.filter(token => token.value !== \"\");\n  }\n};\nconst tokenMiddlewares = [addNegativeTokens, addVirtualPalette, addPixelUnit, removeEmptyTokens];\nexport { addNegativeTokens, addPixelUnit, addVirtualPalette, removeEmptyTokens, tokenMiddlewares };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
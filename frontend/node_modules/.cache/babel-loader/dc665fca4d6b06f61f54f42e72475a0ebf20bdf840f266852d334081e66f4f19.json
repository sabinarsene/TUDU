{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, queryAll, nextById, prevById, itemById, dataAttr, isSelfTarget, isComposingEvent, getEventKey, isSafari, clickIfLink, raf, getFocusables, nextTick, isAnchorElement } from '@zag-js/dom-query';\nimport { first, last, createSplitProps, compact, isEqual } from '@zag-js/utils';\nimport { createMachine, guards } from '@zag-js/core';\nimport { trackElementRect } from '@zag-js/element-rect';\nimport { createProps } from '@zag-js/types';\n\n// src/tabs.anatomy.ts\nvar anatomy = createAnatomy(\"tabs\").parts(\"root\", \"list\", \"trigger\", \"content\", \"indicator\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `tabs:${ctx.id}`,\n  getListId: ctx => ctx.ids?.list ?? `tabs:${ctx.id}:list`,\n  getContentId: (ctx, id) => ctx.ids?.content ?? `tabs:${ctx.id}:content-${id}`,\n  getTriggerId: (ctx, id) => ctx.ids?.trigger ?? `tabs:${ctx.id}:trigger-${id}`,\n  getIndicatorId: ctx => ctx.ids?.indicator ?? `tabs:${ctx.id}:indicator`,\n  getListEl: ctx => dom.getById(ctx, dom.getListId(ctx)),\n  getContentEl: (ctx, id) => dom.getById(ctx, dom.getContentId(ctx, id)),\n  getTriggerEl: (ctx, id) => dom.getById(ctx, dom.getTriggerId(ctx, id)),\n  getIndicatorEl: ctx => dom.getById(ctx, dom.getIndicatorId(ctx)),\n  getElements: ctx => {\n    const ownerId = CSS.escape(dom.getListId(ctx));\n    const selector = `[role=tab][data-ownedby='${ownerId}']:not([disabled])`;\n    return queryAll(dom.getListEl(ctx), selector);\n  },\n  getFirstTriggerEl: ctx => first(dom.getElements(ctx)),\n  getLastTriggerEl: ctx => last(dom.getElements(ctx)),\n  getNextTriggerEl: (ctx, id) => nextById(dom.getElements(ctx), dom.getTriggerId(ctx, id), ctx.loopFocus),\n  getPrevTriggerEl: (ctx, id) => prevById(dom.getElements(ctx), dom.getTriggerId(ctx, id), ctx.loopFocus),\n  getSelectedContentEl: ctx => {\n    if (!ctx.value) return;\n    return dom.getContentEl(ctx, ctx.value);\n  },\n  getSelectedTriggerEl: ctx => {\n    if (!ctx.value) return;\n    return dom.getTriggerEl(ctx, ctx.value);\n  },\n  getOffsetRect: el => {\n    return {\n      left: el?.offsetLeft ?? 0,\n      top: el?.offsetTop ?? 0,\n      width: el?.offsetWidth ?? 0,\n      height: el?.offsetHeight ?? 0\n    };\n  },\n  getRectById: (ctx, id) => {\n    const tab = itemById(dom.getElements(ctx), dom.getTriggerId(ctx, id));\n    return dom.resolveRect(dom.getOffsetRect(tab));\n  },\n  resolveRect: rect => ({\n    width: `${rect.width}px`,\n    height: `${rect.height}px`,\n    left: `${rect.left}px`,\n    top: `${rect.top}px`\n  })\n});\n\n// src/tabs.connect.ts\nfunction connect(state, send, normalize) {\n  const translations = state.context.translations;\n  const focused = state.matches(\"focused\");\n  const isVertical = state.context.orientation === \"vertical\";\n  const isHorizontal = state.context.orientation === \"horizontal\";\n  const composite = state.context.composite;\n  const indicator = state.context.indicatorState;\n  function getTriggerState(props2) {\n    return {\n      selected: state.context.value === props2.value,\n      focused: state.context.focusedValue === props2.value,\n      disabled: !!props2.disabled\n    };\n  }\n  return {\n    value: state.context.value,\n    focusedValue: state.context.focusedValue,\n    setValue(value) {\n      send({\n        type: \"SET_VALUE\",\n        value\n      });\n    },\n    clearValue() {\n      send({\n        type: \"CLEAR_VALUE\"\n      });\n    },\n    setIndicatorRect(value) {\n      const id = dom.getTriggerId(state.context, value);\n      send({\n        type: \"SET_INDICATOR_RECT\",\n        id\n      });\n    },\n    syncTabIndex() {\n      send(\"SYNC_TAB_INDEX\");\n    },\n    selectNext(fromValue) {\n      send({\n        type: \"TAB_FOCUS\",\n        value: fromValue,\n        src: \"selectNext\"\n      });\n      send({\n        type: \"ARROW_NEXT\",\n        src: \"selectNext\"\n      });\n    },\n    selectPrev(fromValue) {\n      send({\n        type: \"TAB_FOCUS\",\n        value: fromValue,\n        src: \"selectPrev\"\n      });\n      send({\n        type: \"ARROW_PREV\",\n        src: \"selectPrev\"\n      });\n    },\n    focus() {\n      dom.getSelectedTriggerEl(state.context)?.focus();\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: dom.getRootId(state.context),\n        \"data-orientation\": state.context.orientation,\n        \"data-focus\": dataAttr(focused),\n        dir: state.context.dir\n      });\n    },\n    getListProps() {\n      return normalize.element({\n        ...parts.list.attrs,\n        id: dom.getListId(state.context),\n        role: \"tablist\",\n        dir: state.context.dir,\n        \"data-focus\": dataAttr(focused),\n        \"aria-orientation\": state.context.orientation,\n        \"data-orientation\": state.context.orientation,\n        \"aria-label\": translations?.listLabel,\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!isSelfTarget(event)) return;\n          if (isComposingEvent(event)) return;\n          const keyMap = {\n            ArrowDown() {\n              if (isHorizontal) return;\n              send({\n                type: \"ARROW_NEXT\",\n                key: \"ArrowDown\"\n              });\n            },\n            ArrowUp() {\n              if (isHorizontal) return;\n              send({\n                type: \"ARROW_PREV\",\n                key: \"ArrowUp\"\n              });\n            },\n            ArrowLeft() {\n              if (isVertical) return;\n              send({\n                type: \"ARROW_PREV\",\n                key: \"ArrowLeft\"\n              });\n            },\n            ArrowRight() {\n              if (isVertical) return;\n              send({\n                type: \"ARROW_NEXT\",\n                key: \"ArrowRight\"\n              });\n            },\n            Home() {\n              send(\"HOME\");\n            },\n            End() {\n              send(\"END\");\n            },\n            Enter() {\n              send({\n                type: \"ENTER\"\n              });\n            }\n          };\n          let key = getEventKey(event, state.context);\n          const exec = keyMap[key];\n          if (exec) {\n            event.preventDefault();\n            exec(event);\n          }\n        }\n      });\n    },\n    getTriggerState,\n    getTriggerProps(props2) {\n      const {\n        value,\n        disabled\n      } = props2;\n      const triggerState = getTriggerState(props2);\n      return normalize.button({\n        ...parts.trigger.attrs,\n        role: \"tab\",\n        type: \"button\",\n        disabled,\n        dir: state.context.dir,\n        \"data-orientation\": state.context.orientation,\n        \"data-disabled\": dataAttr(disabled),\n        \"aria-disabled\": disabled,\n        \"data-value\": value,\n        \"aria-selected\": triggerState.selected,\n        \"data-selected\": dataAttr(triggerState.selected),\n        \"data-focus\": dataAttr(triggerState.focused),\n        \"aria-controls\": triggerState.selected ? dom.getContentId(state.context, value) : void 0,\n        \"data-ownedby\": dom.getListId(state.context),\n        \"data-ssr\": dataAttr(state.context.ssr),\n        id: dom.getTriggerId(state.context, value),\n        tabIndex: triggerState.selected && composite ? 0 : -1,\n        onFocus() {\n          send({\n            type: \"TAB_FOCUS\",\n            value\n          });\n        },\n        onBlur(event) {\n          const target = event.relatedTarget;\n          if (target?.getAttribute(\"role\") !== \"tab\") {\n            send({\n              type: \"TAB_BLUR\"\n            });\n          }\n        },\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (isSafari()) {\n            event.currentTarget.focus();\n          }\n          send({\n            type: \"TAB_CLICK\",\n            value\n          });\n        }\n      });\n    },\n    getContentProps(props2) {\n      const {\n        value\n      } = props2;\n      const selected = state.context.value === value;\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: state.context.dir,\n        id: dom.getContentId(state.context, value),\n        tabIndex: composite ? 0 : -1,\n        \"aria-labelledby\": dom.getTriggerId(state.context, value),\n        role: \"tabpanel\",\n        \"data-ownedby\": dom.getListId(state.context),\n        \"data-selected\": dataAttr(selected),\n        \"data-orientation\": state.context.orientation,\n        hidden: !selected\n      });\n    },\n    getIndicatorProps() {\n      return normalize.element({\n        id: dom.getIndicatorId(state.context),\n        ...parts.indicator.attrs,\n        dir: state.context.dir,\n        \"data-orientation\": state.context.orientation,\n        style: {\n          \"--transition-property\": \"left, right, top, bottom, width, height\",\n          \"--left\": indicator.rect?.left,\n          \"--top\": indicator.rect?.top,\n          \"--width\": indicator.rect?.width,\n          \"--height\": indicator.rect?.height,\n          position: \"absolute\",\n          willChange: \"var(--transition-property)\",\n          transitionProperty: \"var(--transition-property)\",\n          transitionDuration: indicator.transition ? \"var(--transition-duration, 150ms)\" : \"0ms\",\n          transitionTimingFunction: \"var(--transition-timing-function)\",\n          [isHorizontal ? \"left\" : \"top\"]: isHorizontal ? \"var(--left)\" : \"var(--top)\"\n        }\n      });\n    }\n  };\n}\nvar {\n  not\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    initial: \"idle\",\n    context: {\n      dir: \"ltr\",\n      orientation: \"horizontal\",\n      activationMode: \"automatic\",\n      value: null,\n      loopFocus: true,\n      composite: true,\n      navigate(details) {\n        clickIfLink(details.node);\n      },\n      ...ctx,\n      focusedValue: ctx.value ?? null,\n      ssr: true,\n      indicatorState: {\n        rendered: false,\n        transition: false,\n        rect: {\n          left: \"0px\",\n          top: \"0px\",\n          width: \"0px\",\n          height: \"0px\"\n        }\n      }\n    },\n    watch: {\n      value: [\"allowIndicatorTransition\", \"syncIndicatorRect\", \"syncTabIndex\", \"navigateIfNeeded\"],\n      dir: [\"syncIndicatorRect\"],\n      orientation: [\"syncIndicatorRect\"]\n    },\n    on: {\n      SET_VALUE: {\n        actions: \"setValue\"\n      },\n      CLEAR_VALUE: {\n        actions: \"clearValue\"\n      },\n      SET_INDICATOR_RECT: {\n        actions: \"setIndicatorRect\"\n      },\n      SYNC_TAB_INDEX: {\n        actions: \"syncTabIndex\"\n      }\n    },\n    created: [\"syncFocusedValue\"],\n    entry: [\"checkRenderedElements\", \"syncIndicatorRect\", \"syncTabIndex\", \"syncSsr\"],\n    exit: [\"cleanupObserver\"],\n    states: {\n      idle: {\n        on: {\n          TAB_FOCUS: {\n            target: \"focused\",\n            actions: \"setFocusedValue\"\n          },\n          TAB_CLICK: {\n            target: \"focused\",\n            actions: [\"setFocusedValue\", \"setValue\"]\n          }\n        }\n      },\n      focused: {\n        on: {\n          TAB_CLICK: {\n            target: \"focused\",\n            actions: [\"setFocusedValue\", \"setValue\"]\n          },\n          ARROW_PREV: [{\n            guard: \"selectOnFocus\",\n            actions: [\"focusPrevTab\", \"selectFocusedTab\"]\n          }, {\n            actions: \"focusPrevTab\"\n          }],\n          ARROW_NEXT: [{\n            guard: \"selectOnFocus\",\n            actions: [\"focusNextTab\", \"selectFocusedTab\"]\n          }, {\n            actions: \"focusNextTab\"\n          }],\n          HOME: [{\n            guard: \"selectOnFocus\",\n            actions: [\"focusFirstTab\", \"selectFocusedTab\"]\n          }, {\n            actions: \"focusFirstTab\"\n          }],\n          END: [{\n            guard: \"selectOnFocus\",\n            actions: [\"focusLastTab\", \"selectFocusedTab\"]\n          }, {\n            actions: \"focusLastTab\"\n          }],\n          ENTER: {\n            guard: not(\"selectOnFocus\"),\n            actions: \"selectFocusedTab\"\n          },\n          TAB_FOCUS: {\n            actions: [\"setFocusedValue\"]\n          },\n          TAB_BLUR: {\n            target: \"idle\",\n            actions: \"clearFocusedValue\"\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      selectOnFocus: ctx2 => ctx2.activationMode === \"automatic\"\n    },\n    actions: {\n      syncFocusedValue(ctx2) {\n        if (ctx2.value != null && ctx2.focusedValue == null) {\n          ctx2.focusedValue = ctx2.value;\n        }\n      },\n      selectFocusedTab(ctx2) {\n        raf(() => {\n          const nullable = ctx2.deselectable && ctx2.value === ctx2.focusedValue;\n          const value = nullable ? null : ctx2.focusedValue;\n          set.value(ctx2, value);\n        });\n      },\n      setFocusedValue(ctx2, evt) {\n        if (evt.value == null) return;\n        set.focusedValue(ctx2, evt.value);\n      },\n      clearFocusedValue(ctx2) {\n        set.focusedValue(ctx2, null);\n      },\n      setValue(ctx2, evt) {\n        const nullable = ctx2.deselectable && ctx2.value === ctx2.focusedValue;\n        const value = nullable ? null : evt.value;\n        set.value(ctx2, value);\n      },\n      clearValue(ctx2) {\n        set.value(ctx2, null);\n      },\n      focusFirstTab(ctx2) {\n        raf(() => {\n          dom.getFirstTriggerEl(ctx2)?.focus();\n        });\n      },\n      focusLastTab(ctx2) {\n        raf(() => {\n          dom.getLastTriggerEl(ctx2)?.focus();\n        });\n      },\n      focusNextTab(ctx2) {\n        if (!ctx2.focusedValue) return;\n        const triggerEl = dom.getNextTriggerEl(ctx2, ctx2.focusedValue);\n        raf(() => {\n          if (ctx2.composite) {\n            triggerEl?.focus();\n          } else if (triggerEl?.dataset.value != null) {\n            set.focusedValue(ctx2, triggerEl.dataset.value);\n          }\n        });\n      },\n      focusPrevTab(ctx2) {\n        if (!ctx2.focusedValue) return;\n        const triggerEl = dom.getPrevTriggerEl(ctx2, ctx2.focusedValue);\n        raf(() => {\n          if (ctx2.composite) {\n            triggerEl?.focus();\n          } else if (triggerEl?.dataset.value != null) {\n            set.focusedValue(ctx2, triggerEl.dataset.value);\n          }\n        });\n      },\n      checkRenderedElements(ctx2) {\n        ctx2.indicatorState.rendered = !!dom.getIndicatorEl(ctx2);\n      },\n      syncTabIndex(ctx2) {\n        raf(() => {\n          const contentEl = dom.getSelectedContentEl(ctx2);\n          if (!contentEl) return;\n          const focusables = getFocusables(contentEl);\n          if (focusables.length > 0) {\n            contentEl.removeAttribute(\"tabindex\");\n          } else {\n            contentEl.setAttribute(\"tabindex\", \"0\");\n          }\n        });\n      },\n      cleanupObserver(ctx2) {\n        ctx2.indicatorCleanup?.();\n      },\n      allowIndicatorTransition(ctx2) {\n        ctx2.indicatorState.transition = true;\n      },\n      setIndicatorRect(ctx2, evt) {\n        const value = evt.id ?? ctx2.value;\n        if (!ctx2.indicatorState.rendered || !value) return;\n        const triggerEl = dom.getTriggerEl(ctx2, value);\n        if (!triggerEl) return;\n        ctx2.indicatorState.rect = dom.getRectById(ctx2, value);\n        nextTick(() => {\n          ctx2.indicatorState.transition = false;\n        });\n      },\n      syncSsr(ctx2) {\n        ctx2.ssr = false;\n      },\n      syncIndicatorRect(ctx2) {\n        ctx2.indicatorCleanup?.();\n        const value = ctx2.value;\n        if (!ctx2.indicatorState.rendered || !value) return;\n        const triggerEl = dom.getSelectedTriggerEl(ctx2);\n        if (!triggerEl) return;\n        ctx2.indicatorCleanup = trackElementRect(triggerEl, {\n          getRect(el) {\n            return dom.getOffsetRect(el);\n          },\n          onChange(rect) {\n            ctx2.indicatorState.rect = dom.resolveRect(rect);\n            nextTick(() => {\n              ctx2.indicatorState.transition = false;\n            });\n          }\n        });\n      },\n      navigateIfNeeded(ctx2) {\n        const triggerEl = dom.getSelectedTriggerEl(ctx2);\n        if (!isAnchorElement(triggerEl)) return;\n        ctx2.navigate({\n          value: ctx2.value,\n          node: triggerEl\n        });\n      }\n    }\n  });\n}\nvar invoke = {\n  change: ctx => {\n    if (ctx.value == null) return;\n    ctx.onValueChange?.({\n      value: ctx.value\n    });\n  },\n  focusChange: ctx => {\n    if (ctx.focusedValue == null) return;\n    ctx.onFocusChange?.({\n      focusedValue: ctx.focusedValue\n    });\n  }\n};\nvar set = {\n  value: (ctx, value) => {\n    if (isEqual(value, ctx.value)) return;\n    ctx.value = value;\n    invoke.change(ctx);\n  },\n  focusedValue: (ctx, value) => {\n    if (isEqual(value, ctx.focusedValue)) return;\n    ctx.focusedValue = value;\n    invoke.focusChange(ctx);\n  }\n};\nvar props = createProps()([\"activationMode\", \"composite\", \"deselectable\", \"dir\", \"getRootNode\", \"id\", \"ids\", \"loopFocus\", \"navigate\", \"onFocusChange\", \"onValueChange\", \"orientation\", \"translations\", \"value\"]);\nvar splitProps = createSplitProps(props);\nvar triggerProps = createProps()([\"disabled\", \"value\"]);\nvar splitTriggerProps = createSplitProps(triggerProps);\nvar contentProps = createProps()([\"value\"]);\nvar splitContentProps = createSplitProps(contentProps);\nexport { anatomy, connect, contentProps, machine, props, splitContentProps, splitProps, splitTriggerProps, triggerProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
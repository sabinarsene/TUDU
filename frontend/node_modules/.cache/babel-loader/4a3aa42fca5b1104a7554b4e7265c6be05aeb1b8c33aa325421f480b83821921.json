{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, dataAttr, raf, getComputedStyle, getEventTarget } from '@zag-js/dom-query';\nimport { createMachine, ref } from '@zag-js/core';\nimport { createSplitProps, compact } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/collapsible.anatomy.ts\nvar anatomy = createAnatomy(\"collapsible\").parts(\"root\", \"trigger\", \"content\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `collapsible:${ctx.id}`,\n  getContentId: ctx => ctx.ids?.content ?? `collapsible:${ctx.id}:content`,\n  getTriggerId: ctx => ctx.ids?.trigger ?? `collapsible:${ctx.id}:trigger`,\n  getRootEl: ctx => dom.getById(ctx, dom.getRootId(ctx)),\n  getContentEl: ctx => dom.getById(ctx, dom.getContentId(ctx)),\n  getTriggerEl: ctx => dom.getById(ctx, dom.getTriggerId(ctx))\n});\n\n// src/collapsible.connect.ts\nfunction connect(state, send, normalize) {\n  const visible = state.matches(\"open\", \"closing\");\n  const open = state.matches(\"open\");\n  const height = state.context.height;\n  const width = state.context.width;\n  const disabled = !!state.context.disabled;\n  const skip = !state.context.initial && open;\n  return {\n    disabled,\n    visible,\n    open,\n    measureSize() {\n      send(\"SIZE.MEASURE\");\n    },\n    setOpen(nextOpen) {\n      if (nextOpen === open) return;\n      send(nextOpen ? \"OPEN\" : \"CLOSE\");\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-state\": open ? \"open\" : \"closed\",\n        dir: state.context.dir,\n        id: dom.getRootId(state.context)\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        \"data-collapsible\": \"\",\n        \"data-state\": skip ? void 0 : open ? \"open\" : \"closed\",\n        id: dom.getContentId(state.context),\n        \"data-disabled\": dataAttr(disabled),\n        hidden: !visible,\n        style: {\n          \"--height\": height != null ? `${height}px` : void 0,\n          \"--width\": width != null ? `${width}px` : void 0\n        }\n      });\n    },\n    getTriggerProps() {\n      return normalize.element({\n        ...parts.trigger.attrs,\n        id: dom.getTriggerId(state.context),\n        dir: state.context.dir,\n        type: \"button\",\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(disabled),\n        \"aria-controls\": dom.getContentId(state.context),\n        \"aria-expanded\": visible || false,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          send({\n            type: open ? \"CLOSE\" : \"OPEN\",\n            src: \"trigger.click\"\n          });\n        }\n      });\n    }\n  };\n}\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"collapsible\",\n    initial: ctx.open ? \"open\" : \"closed\",\n    context: {\n      ...ctx,\n      height: 0,\n      width: 0,\n      initial: false,\n      stylesRef: null,\n      unmountAnimationName: null\n    },\n    watch: {\n      open: [\"setInitial\", \"computeSize\", \"toggleVisibility\"]\n    },\n    exit: [\"clearInitial\", \"cleanupNode\"],\n    states: {\n      closed: {\n        tags: [\"closed\"],\n        on: {\n          \"CONTROLLED.OPEN\": \"open\",\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"setInitial\", \"computeSize\", \"invokeOnOpen\"]\n          }]\n        }\n      },\n      closing: {\n        tags: [\"open\"],\n        activities: [\"trackExitAnimation\"],\n        on: {\n          \"CONTROLLED.CLOSE\": \"closed\",\n          \"CONTROLLED.OPEN\": \"open\",\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"setInitial\", \"invokeOnOpen\"]\n          }],\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnExitComplete\"]\n          }, {\n            target: \"closed\",\n            actions: [\"setInitial\", \"computeSize\", \"invokeOnExitComplete\"]\n          }],\n          \"ANIMATION.END\": {\n            target: \"closed\",\n            actions: [\"invokeOnExitComplete\", \"clearInitial\"]\n          }\n        }\n      },\n      open: {\n        tags: [\"open\"],\n        activities: [\"trackEnterAnimation\"],\n        on: {\n          \"CONTROLLED.CLOSE\": \"closing\",\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"closing\",\n            actions: [\"setInitial\", \"computeSize\", \"invokeOnClose\"]\n          }],\n          \"SIZE.MEASURE\": {\n            actions: [\"measureSize\"]\n          },\n          \"ANIMATION.END\": {\n            actions: [\"clearInitial\"]\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      isOpenControlled: ctx2 => !!ctx2[\"open.controlled\"]\n    },\n    activities: {\n      trackEnterAnimation(ctx2, _evt, {\n        send\n      }) {\n        let cleanup;\n        const rafCleanup = raf(() => {\n          const contentEl = dom.getContentEl(ctx2);\n          if (!contentEl) return;\n          const animationName = getComputedStyle(contentEl).animationName;\n          const hasNoAnimation = !animationName || animationName === \"none\";\n          if (hasNoAnimation) {\n            send({\n              type: \"ANIMATION.END\"\n            });\n            return;\n          }\n          const onEnd = event => {\n            const target = getEventTarget(event);\n            if (target === contentEl) {\n              send({\n                type: \"ANIMATION.END\"\n              });\n            }\n          };\n          contentEl.addEventListener(\"animationend\", onEnd);\n          cleanup = () => {\n            contentEl.removeEventListener(\"animationend\", onEnd);\n          };\n        });\n        return () => {\n          rafCleanup();\n          cleanup?.();\n        };\n      },\n      trackExitAnimation(ctx2, _evt, {\n        send\n      }) {\n        let cleanup;\n        const rafCleanup = raf(() => {\n          const contentEl = dom.getContentEl(ctx2);\n          if (!contentEl) return;\n          const animationName = getComputedStyle(contentEl).animationName;\n          const hasNoAnimation = !animationName || animationName === \"none\";\n          if (hasNoAnimation) {\n            send({\n              type: \"ANIMATION.END\"\n            });\n            return;\n          }\n          const onEnd = event => {\n            const win = contentEl.ownerDocument.defaultView || window;\n            const animationName2 = win.getComputedStyle(contentEl).animationName;\n            const target = getEventTarget(event);\n            if (target === contentEl && animationName2 === ctx2.unmountAnimationName) {\n              send({\n                type: \"ANIMATION.END\"\n              });\n            }\n          };\n          contentEl.addEventListener(\"animationend\", onEnd);\n          cleanup = () => {\n            contentEl.removeEventListener(\"animationend\", onEnd);\n          };\n        });\n        return () => {\n          rafCleanup();\n          cleanup?.();\n        };\n      }\n    },\n    actions: {\n      setInitial(ctx2) {\n        ctx2.initial = true;\n      },\n      clearInitial(ctx2) {\n        raf(() => {\n          ctx2.initial = false;\n        });\n      },\n      cleanupNode(ctx2) {\n        ctx2.stylesRef = null;\n      },\n      measureSize(ctx2) {\n        const contentEl = dom.getContentEl(ctx2);\n        if (!contentEl) return;\n        const {\n          height,\n          width\n        } = contentEl.getBoundingClientRect();\n        ctx2.height = height;\n        ctx2.width = width;\n      },\n      computeSize(ctx2, evt) {\n        ctx2._rafCleanup?.();\n        ctx2._rafCleanup = raf(() => {\n          const contentEl = dom.getContentEl(ctx2);\n          if (!contentEl) return;\n          ctx2.stylesRef || (ctx2.stylesRef = ref({\n            animationName: contentEl.style.animationName,\n            animationDuration: contentEl.style.animationDuration\n          }));\n          if (evt.type === \"CLOSE\" || !ctx2.open) {\n            const win = contentEl.ownerDocument.defaultView || window;\n            ctx2.unmountAnimationName = win.getComputedStyle(contentEl).animationName;\n          }\n          const hidden = contentEl.hidden;\n          contentEl.style.animationName = \"none\";\n          contentEl.style.animationDuration = \"0s\";\n          contentEl.hidden = false;\n          const rect = contentEl.getBoundingClientRect();\n          ctx2.height = rect.height;\n          ctx2.width = rect.width;\n          if (ctx2.initial) {\n            contentEl.style.animationName = ctx2.stylesRef.animationName;\n            contentEl.style.animationDuration = ctx2.stylesRef.animationDuration;\n          }\n          contentEl.hidden = hidden;\n        });\n      },\n      invokeOnOpen: ctx2 => {\n        ctx2.onOpenChange?.({\n          open: true\n        });\n      },\n      invokeOnClose: ctx2 => {\n        ctx2.onOpenChange?.({\n          open: false\n        });\n      },\n      invokeOnExitComplete(ctx2) {\n        ctx2.onExitComplete?.();\n      },\n      toggleVisibility: (ctx2, _evt, {\n        send\n      }) => {\n        send({\n          type: ctx2.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\"\n        });\n      }\n    }\n  });\n}\nvar props = createProps()([\"dir\", \"disabled\", \"getRootNode\", \"id\", \"ids\", \"onExitComplete\", \"onOpenChange\", \"open.controlled\", \"open\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
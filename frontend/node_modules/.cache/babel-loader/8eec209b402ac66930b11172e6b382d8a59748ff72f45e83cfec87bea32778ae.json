{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, queryAll, getRelativePoint, dispatchInputValueEvent, dataAttr, ariaAttr, getEventStep, getEventKey, isLeftClick, isModifierKey, getEventPoint, trackFormControl, trackPointerMove, raf } from '@zag-js/dom-query';\nimport { getPercentValue, createSplitProps, compact, getValuePercent, isEqual, getValueRanges, snapValueToStep, clampValue, getPreviousStepValue, getNextStepValue, getClosestValueIndex, getValueTransformer } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { trackElementsSize } from '@zag-js/element-size';\nimport { createProps } from '@zag-js/types';\n\n// src/slider.anatomy.ts\nvar anatomy = createAnatomy(\"slider\").parts(\"root\", \"label\", \"thumb\", \"valueText\", \"track\", \"range\", \"control\", \"markerGroup\", \"marker\", \"draggingIndicator\");\nvar parts = anatomy.build();\nfunction getBounds(value) {\n  const firstValue = value[0];\n  const lastThumb = value[value.length - 1];\n  return [firstValue, lastThumb];\n}\nfunction getRangeOffsets(ctx) {\n  const [firstPercent, lastPercent] = getBounds(ctx.valuePercent);\n  if (ctx.valuePercent.length === 1) {\n    if (ctx.origin === \"center\") {\n      const isNegative = ctx.valuePercent[0] < 50;\n      const start = isNegative ? `${ctx.valuePercent[0]}%` : \"50%\";\n      const end = isNegative ? \"50%\" : `${100 - ctx.valuePercent[0]}%`;\n      return {\n        start,\n        end\n      };\n    }\n    return {\n      start: \"0%\",\n      end: `${100 - lastPercent}%`\n    };\n  }\n  return {\n    start: `${firstPercent}%`,\n    end: `${100 - lastPercent}%`\n  };\n}\nfunction getRangeStyle(ctx) {\n  if (ctx.isVertical) {\n    return {\n      position: \"absolute\",\n      bottom: \"var(--slider-range-start)\",\n      top: \"var(--slider-range-end)\"\n    };\n  }\n  return {\n    position: \"absolute\",\n    [ctx.isRtl ? \"right\" : \"left\"]: \"var(--slider-range-start)\",\n    [ctx.isRtl ? \"left\" : \"right\"]: \"var(--slider-range-end)\"\n  };\n}\nfunction getVerticalThumbOffset(ctx) {\n  const {\n    height = 0\n  } = ctx.thumbSize ?? {};\n  const getValue = getValueTransformer([ctx.min, ctx.max], [-height / 2, height / 2]);\n  return parseFloat(getValue(ctx.value).toFixed(2));\n}\nfunction getHorizontalThumbOffset(ctx) {\n  const {\n    width = 0\n  } = ctx.thumbSize ?? {};\n  if (ctx.isRtl) {\n    const getValue2 = getValueTransformer([ctx.max, ctx.min], [-width / 2, width / 2]);\n    return -1 * parseFloat(getValue2(ctx.value).toFixed(2));\n  }\n  const getValue = getValueTransformer([ctx.min, ctx.max], [-width / 2, width / 2]);\n  return parseFloat(getValue(ctx.value).toFixed(2));\n}\nfunction getOffset(ctx, percent) {\n  if (ctx.thumbAlignment === \"center\") return `${percent}%`;\n  const offset = ctx.isVertical ? getVerticalThumbOffset(ctx) : getHorizontalThumbOffset(ctx);\n  return `calc(${percent}% - ${offset}px)`;\n}\nfunction getThumbOffset(ctx) {\n  let percent = getValuePercent(ctx.value, ctx.min, ctx.max) * 100;\n  return getOffset(ctx, percent);\n}\nfunction getVisibility(ctx) {\n  let visibility = \"visible\";\n  if (ctx.thumbAlignment === \"contain\" && !ctx.hasMeasuredThumbSize) {\n    visibility = \"hidden\";\n  }\n  return visibility;\n}\nfunction getThumbStyle(ctx, index) {\n  const placementProp = ctx.isVertical ? \"bottom\" : \"insetInlineStart\";\n  return {\n    visibility: getVisibility(ctx),\n    position: \"absolute\",\n    transform: \"var(--slider-thumb-transform)\",\n    [placementProp]: `var(--slider-thumb-offset-${index})`\n  };\n}\nfunction getControlStyle() {\n  return {\n    touchAction: \"none\",\n    userSelect: \"none\",\n    WebkitUserSelect: \"none\",\n    position: \"relative\"\n  };\n}\nfunction getRootStyle(ctx) {\n  const range = getRangeOffsets(ctx);\n  const offsetStyles = ctx.value.reduce((styles, value, index) => {\n    const offset = getThumbOffset({\n      ...ctx,\n      value\n    });\n    return {\n      ...styles,\n      [`--slider-thumb-offset-${index}`]: offset\n    };\n  }, {});\n  return {\n    ...offsetStyles,\n    \"--slider-thumb-transform\": ctx.isVertical ? \"translateY(50%)\" : ctx.isRtl ? \"translateX(50%)\" : \"translateX(-50%)\",\n    \"--slider-range-start\": range.start,\n    \"--slider-range-end\": range.end\n  };\n}\nfunction getMarkerStyle(ctx, value) {\n  return {\n    // @ts-expect-error\n    visibility: getVisibility(ctx),\n    position: \"absolute\",\n    pointerEvents: \"none\",\n    // @ts-expect-error\n    [ctx.isHorizontal ? \"insetInlineStart\" : \"bottom\"]: getThumbOffset({\n      ...ctx,\n      value\n    }),\n    translate: \"var(--tx) var(--ty)\",\n    \"--tx\": ctx.isHorizontal ? ctx.isRtl ? \"50%\" : \"-50%\" : \"0%\",\n    \"--ty\": !ctx.isHorizontal ? \"50%\" : \"0%\"\n  };\n}\nfunction getMarkerGroupStyle() {\n  return {\n    userSelect: \"none\",\n    WebkitUserSelect: \"none\",\n    pointerEvents: \"none\",\n    position: \"relative\"\n  };\n}\nvar styleGetterFns = {\n  getRootStyle,\n  getControlStyle,\n  getThumbStyle,\n  getRangeStyle,\n  getMarkerStyle,\n  getMarkerGroupStyle\n};\n\n// src/slider.dom.ts\nvar dom = createScope({\n  ...styleGetterFns,\n  getRootId: ctx => ctx.ids?.root ?? `slider:${ctx.id}`,\n  getThumbId: (ctx, index) => ctx.ids?.thumb?.(index) ?? `slider:${ctx.id}:thumb:${index}`,\n  getHiddenInputId: (ctx, index) => ctx.ids?.hiddenInput?.(index) ?? `slider:${ctx.id}:input:${index}`,\n  getControlId: ctx => ctx.ids?.control ?? `slider:${ctx.id}:control`,\n  getTrackId: ctx => ctx.ids?.track ?? `slider:${ctx.id}:track`,\n  getRangeId: ctx => ctx.ids?.range ?? `slider:${ctx.id}:range`,\n  getLabelId: ctx => ctx.ids?.label ?? `slider:${ctx.id}:label`,\n  getValueTextId: ctx => ctx.ids?.valueText ?? `slider:${ctx.id}:value-text`,\n  getMarkerId: (ctx, value) => ctx.ids?.marker?.(value) ?? `slider:${ctx.id}:marker:${value}`,\n  getRootEl: ctx => dom.getById(ctx, dom.getRootId(ctx)),\n  getThumbEl: (ctx, index) => dom.getById(ctx, dom.getThumbId(ctx, index)),\n  getHiddenInputEl: (ctx, index) => dom.getById(ctx, dom.getHiddenInputId(ctx, index)),\n  getControlEl: ctx => dom.getById(ctx, dom.getControlId(ctx)),\n  getElements: ctx => queryAll(dom.getControlEl(ctx), \"[role=slider]\"),\n  getFirstEl: ctx => dom.getElements(ctx)[0],\n  getRangeEl: ctx => dom.getById(ctx, dom.getRangeId(ctx)),\n  getValueFromPoint(ctx, point) {\n    const controlEl = dom.getControlEl(ctx);\n    if (!controlEl) return;\n    const relativePoint = getRelativePoint(point, controlEl);\n    const percent = relativePoint.getPercentValue({\n      orientation: ctx.orientation,\n      dir: ctx.dir,\n      inverted: {\n        y: true\n      }\n    });\n    return getPercentValue(percent, ctx.min, ctx.max, ctx.step);\n  },\n  dispatchChangeEvent(ctx) {\n    const valueArray = Array.from(ctx.value);\n    valueArray.forEach((value, index) => {\n      const inputEl = dom.getHiddenInputEl(ctx, index);\n      if (!inputEl) return;\n      dispatchInputValueEvent(inputEl, {\n        value\n      });\n    });\n  }\n});\nfunction normalizeValues(ctx, nextValues) {\n  return nextValues.map((value, index, values) => {\n    return constrainValue({\n      ...ctx,\n      value: values\n    }, value, index);\n  });\n}\nfunction getRangeAtIndex(ctx, index) {\n  return getValueRanges(ctx.value, ctx.min, ctx.max, ctx.minStepsBetweenThumbs)[index];\n}\nfunction constrainValue(ctx, value, index) {\n  const range = getRangeAtIndex(ctx, index);\n  const snapValue = snapValueToStep(value, ctx.min, ctx.max, ctx.step);\n  return clampValue(snapValue, range.min, range.max);\n}\nfunction decrement(ctx, index, step) {\n  const idx = index ?? ctx.focusedIndex;\n  const range = getRangeAtIndex(ctx, idx);\n  const nextValues = getPreviousStepValue(idx, {\n    ...range,\n    step: step ?? ctx.step,\n    values: ctx.value\n  });\n  nextValues[idx] = clampValue(nextValues[idx], range.min, range.max);\n  return nextValues;\n}\nfunction increment(ctx, index, step) {\n  const idx = index ?? ctx.focusedIndex;\n  const range = getRangeAtIndex(ctx, idx);\n  const nextValues = getNextStepValue(idx, {\n    ...range,\n    step: step ?? ctx.step,\n    values: ctx.value\n  });\n  nextValues[idx] = clampValue(nextValues[idx], range.min, range.max);\n  return nextValues;\n}\nfunction getClosestIndex(ctx, pointValue) {\n  return getClosestValueIndex(ctx.value, pointValue);\n}\nfunction assignArray(current, next) {\n  for (let i = 0; i < next.length; i++) {\n    const value = next[i];\n    current[i] = value;\n  }\n}\n\n// src/slider.connect.ts\nfunction connect(state, send, normalize) {\n  const ariaLabel = state.context[\"aria-label\"];\n  const ariaLabelledBy = state.context[\"aria-labelledby\"];\n  const sliderValue = state.context.value;\n  const focused = state.matches(\"focus\");\n  const dragging = state.matches(\"dragging\");\n  const disabled = state.context.isDisabled;\n  const invalid = state.context.invalid;\n  const interactive = state.context.isInteractive;\n  const isHorizontal = state.context.orientation === \"horizontal\";\n  const isVertical = state.context.orientation === \"vertical\";\n  function getValuePercentFn(value) {\n    return getValuePercent(value, state.context.min, state.context.max);\n  }\n  function getPercentValueFn(percent) {\n    return getPercentValue(percent, state.context.min, state.context.max, state.context.step);\n  }\n  return {\n    value: state.context.value,\n    dragging,\n    focused,\n    setValue(value) {\n      send({\n        type: \"SET_VALUE\",\n        value\n      });\n    },\n    getThumbValue(index) {\n      return sliderValue[index];\n    },\n    setThumbValue(index, value) {\n      send({\n        type: \"SET_VALUE\",\n        index,\n        value\n      });\n    },\n    getValuePercent: getValuePercentFn,\n    getPercentValue: getPercentValueFn,\n    getThumbPercent(index) {\n      return getValuePercentFn(sliderValue[index]);\n    },\n    setThumbPercent(index, percent) {\n      const value = getPercentValueFn(percent);\n      send({\n        type: \"SET_VALUE\",\n        index,\n        value\n      });\n    },\n    getThumbMin(index) {\n      return getRangeAtIndex(state.context, index).min;\n    },\n    getThumbMax(index) {\n      return getRangeAtIndex(state.context, index).max;\n    },\n    increment(index) {\n      send({\n        type: \"INCREMENT\",\n        index\n      });\n    },\n    decrement(index) {\n      send({\n        type: \"DECREMENT\",\n        index\n      });\n    },\n    focus() {\n      if (!interactive) return;\n      send({\n        type: \"FOCUS\",\n        index: 0\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-orientation\": state.context.orientation,\n        \"data-invalid\": dataAttr(invalid),\n        \"data-dragging\": dataAttr(dragging),\n        \"data-focus\": dataAttr(focused),\n        id: dom.getLabelId(state.context),\n        htmlFor: dom.getHiddenInputId(state.context, 0),\n        onClick(event) {\n          if (!interactive) return;\n          event.preventDefault();\n          dom.getFirstEl(state.context)?.focus();\n        },\n        style: {\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\"\n        }\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-orientation\": state.context.orientation,\n        \"data-dragging\": dataAttr(dragging),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-focus\": dataAttr(focused),\n        id: dom.getRootId(state.context),\n        dir: state.context.dir,\n        style: dom.getRootStyle(state.context)\n      });\n    },\n    getValueTextProps() {\n      return normalize.element({\n        ...parts.valueText.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-orientation\": state.context.orientation,\n        \"data-invalid\": dataAttr(invalid),\n        \"data-focus\": dataAttr(focused),\n        id: dom.getValueTextId(state.context)\n      });\n    },\n    getTrackProps() {\n      return normalize.element({\n        ...parts.track.attrs,\n        dir: state.context.dir,\n        id: dom.getTrackId(state.context),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-dragging\": dataAttr(dragging),\n        \"data-orientation\": state.context.orientation,\n        \"data-focus\": dataAttr(focused),\n        style: {\n          position: \"relative\"\n        }\n      });\n    },\n    getThumbProps(props2) {\n      const {\n        index = 0,\n        name\n      } = props2;\n      const value = sliderValue[index];\n      const range = getRangeAtIndex(state.context, index);\n      const valueText = state.context.getAriaValueText?.({\n        value,\n        index\n      });\n      const _ariaLabel = Array.isArray(ariaLabel) ? ariaLabel[index] : ariaLabel;\n      const _ariaLabelledBy = Array.isArray(ariaLabelledBy) ? ariaLabelledBy[index] : ariaLabelledBy;\n      return normalize.element({\n        ...parts.thumb.attrs,\n        dir: state.context.dir,\n        \"data-index\": index,\n        \"data-name\": name,\n        id: dom.getThumbId(state.context, index),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-orientation\": state.context.orientation,\n        \"data-focus\": dataAttr(focused && state.context.focusedIndex === index),\n        \"data-dragging\": dataAttr(dragging && state.context.focusedIndex === index),\n        draggable: false,\n        \"aria-disabled\": ariaAttr(disabled),\n        \"aria-label\": _ariaLabel,\n        \"aria-labelledby\": _ariaLabelledBy ?? dom.getLabelId(state.context),\n        \"aria-orientation\": state.context.orientation,\n        \"aria-valuemax\": range.max,\n        \"aria-valuemin\": range.min,\n        \"aria-valuenow\": sliderValue[index],\n        \"aria-valuetext\": valueText,\n        role: \"slider\",\n        tabIndex: disabled ? void 0 : 0,\n        style: dom.getThumbStyle(state.context, index),\n        onPointerDown(event) {\n          if (!interactive) return;\n          send({\n            type: \"THUMB_POINTER_DOWN\",\n            index\n          });\n          event.stopPropagation();\n        },\n        onBlur() {\n          if (!interactive) return;\n          send(\"BLUR\");\n        },\n        onFocus() {\n          if (!interactive) return;\n          send({\n            type: \"FOCUS\",\n            index\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          const step = getEventStep(event) * state.context.step;\n          const keyMap = {\n            ArrowUp() {\n              if (isHorizontal) return;\n              send({\n                type: \"ARROW_INC\",\n                step,\n                src: \"ArrowUp\"\n              });\n            },\n            ArrowDown() {\n              if (isHorizontal) return;\n              send({\n                type: \"ARROW_DEC\",\n                step,\n                src: \"ArrowDown\"\n              });\n            },\n            ArrowLeft() {\n              if (isVertical) return;\n              send({\n                type: \"ARROW_DEC\",\n                step,\n                src: \"ArrowLeft\"\n              });\n            },\n            ArrowRight() {\n              if (isVertical) return;\n              send({\n                type: \"ARROW_INC\",\n                step,\n                src: \"ArrowRight\"\n              });\n            },\n            PageUp() {\n              send({\n                type: \"ARROW_INC\",\n                step,\n                src: \"PageUp\"\n              });\n            },\n            PageDown() {\n              send({\n                type: \"ARROW_DEC\",\n                step,\n                src: \"PageDown\"\n              });\n            },\n            Home() {\n              send(\"HOME\");\n            },\n            End() {\n              send(\"END\");\n            }\n          };\n          const key = getEventKey(event, state.context);\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        }\n      });\n    },\n    getHiddenInputProps(props2) {\n      const {\n        index = 0,\n        name\n      } = props2;\n      return normalize.input({\n        name: name ?? (state.context.name ? state.context.name + (state.context.value.length > 1 ? \"[]\" : \"\") : void 0),\n        form: state.context.form,\n        type: \"text\",\n        hidden: true,\n        defaultValue: state.context.value[index],\n        id: dom.getHiddenInputId(state.context, index)\n      });\n    },\n    getRangeProps() {\n      return normalize.element({\n        id: dom.getRangeId(state.context),\n        ...parts.range.attrs,\n        dir: state.context.dir,\n        \"data-dragging\": dataAttr(dragging),\n        \"data-focus\": dataAttr(focused),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-orientation\": state.context.orientation,\n        style: dom.getRangeStyle(state.context)\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        dir: state.context.dir,\n        id: dom.getControlId(state.context),\n        \"data-dragging\": dataAttr(dragging),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-orientation\": state.context.orientation,\n        \"data-invalid\": dataAttr(invalid),\n        \"data-focus\": dataAttr(focused),\n        style: dom.getControlStyle(),\n        onPointerDown(event) {\n          if (!interactive) return;\n          if (!isLeftClick(event)) return;\n          if (isModifierKey(event)) return;\n          const point = getEventPoint(event);\n          send({\n            type: \"POINTER_DOWN\",\n            point\n          });\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      });\n    },\n    getMarkerGroupProps() {\n      return normalize.element({\n        ...parts.markerGroup.attrs,\n        role: \"presentation\",\n        dir: state.context.dir,\n        \"aria-hidden\": true,\n        \"data-orientation\": state.context.orientation,\n        style: dom.getMarkerGroupStyle()\n      });\n    },\n    getMarkerProps(props2) {\n      const style = dom.getMarkerStyle(state.context, props2.value);\n      let markerState;\n      const first = state.context.value[0];\n      const last = state.context.value[state.context.value.length - 1];\n      if (props2.value < first) {\n        markerState = \"under-value\";\n      } else if (props2.value > last) {\n        markerState = \"over-value\";\n      } else {\n        markerState = \"at-value\";\n      }\n      return normalize.element({\n        ...parts.marker.attrs,\n        id: dom.getMarkerId(state.context, props2.value),\n        role: \"presentation\",\n        dir: state.context.dir,\n        \"data-orientation\": state.context.orientation,\n        \"data-value\": props2.value,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-state\": markerState,\n        style\n      });\n    },\n    getDraggingIndicatorProps(props2) {\n      const {\n        index = 0\n      } = props2;\n      const isDragging = index === state.context.focusedIndex && dragging;\n      return normalize.element({\n        ...parts.draggingIndicator.attrs,\n        role: \"presentation\",\n        dir: state.context.dir,\n        hidden: !isDragging,\n        \"data-orientation\": state.context.orientation,\n        \"data-state\": isDragging ? \"open\" : \"closed\",\n        style: dom.getThumbStyle(state.context, index)\n      });\n    }\n  };\n}\nvar isEqualSize = (a, b) => {\n  return a?.width === b?.width && a?.height === b?.height;\n};\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"slider\",\n    initial: \"idle\",\n    context: {\n      thumbSize: null,\n      thumbAlignment: \"contain\",\n      min: 0,\n      max: 100,\n      step: 1,\n      value: [0],\n      origin: \"start\",\n      orientation: \"horizontal\",\n      dir: \"ltr\",\n      minStepsBetweenThumbs: 0,\n      disabled: false,\n      readOnly: false,\n      ...ctx,\n      focusedIndex: -1,\n      fieldsetDisabled: false\n    },\n    computed: {\n      isHorizontal: ctx2 => ctx2.orientation === \"horizontal\",\n      isVertical: ctx2 => ctx2.orientation === \"vertical\",\n      isRtl: ctx2 => ctx2.orientation === \"horizontal\" && ctx2.dir === \"rtl\",\n      isDisabled: ctx2 => !!ctx2.disabled || ctx2.fieldsetDisabled,\n      isInteractive: ctx2 => !(ctx2.readOnly || ctx2.isDisabled),\n      hasMeasuredThumbSize: ctx2 => ctx2.thumbSize != null,\n      valuePercent(ctx2) {\n        return ctx2.value.map(value => 100 * getValuePercent(value, ctx2.min, ctx2.max));\n      }\n    },\n    watch: {\n      value: [\"syncInputElements\"]\n    },\n    entry: [\"coarseValue\"],\n    activities: [\"trackFormControlState\", \"trackThumbsSize\"],\n    on: {\n      SET_VALUE: [{\n        guard: \"hasIndex\",\n        actions: \"setValueAtIndex\"\n      }, {\n        actions: \"setValue\"\n      }],\n      INCREMENT: {\n        actions: \"incrementThumbAtIndex\"\n      },\n      DECREMENT: {\n        actions: \"decrementThumbAtIndex\"\n      }\n    },\n    states: {\n      idle: {\n        on: {\n          POINTER_DOWN: {\n            target: \"dragging\",\n            actions: [\"setClosestThumbIndex\", \"setPointerValue\", \"focusActiveThumb\"]\n          },\n          FOCUS: {\n            target: \"focus\",\n            actions: \"setFocusedIndex\"\n          },\n          THUMB_POINTER_DOWN: {\n            target: \"dragging\",\n            actions: [\"setFocusedIndex\", \"focusActiveThumb\"]\n          }\n        }\n      },\n      focus: {\n        entry: \"focusActiveThumb\",\n        on: {\n          POINTER_DOWN: {\n            target: \"dragging\",\n            actions: [\"setClosestThumbIndex\", \"setPointerValue\", \"focusActiveThumb\"]\n          },\n          THUMB_POINTER_DOWN: {\n            target: \"dragging\",\n            actions: [\"setFocusedIndex\", \"focusActiveThumb\"]\n          },\n          ARROW_DEC: {\n            actions: [\"decrementThumbAtIndex\", \"invokeOnChangeEnd\"]\n          },\n          ARROW_INC: {\n            actions: [\"incrementThumbAtIndex\", \"invokeOnChangeEnd\"]\n          },\n          HOME: {\n            actions: [\"setFocusedThumbToMin\", \"invokeOnChangeEnd\"]\n          },\n          END: {\n            actions: [\"setFocusedThumbToMax\", \"invokeOnChangeEnd\"]\n          },\n          BLUR: {\n            target: \"idle\",\n            actions: \"clearFocusedIndex\"\n          }\n        }\n      },\n      dragging: {\n        entry: \"focusActiveThumb\",\n        activities: \"trackPointerMove\",\n        on: {\n          POINTER_UP: {\n            target: \"focus\",\n            actions: \"invokeOnChangeEnd\"\n          },\n          POINTER_MOVE: {\n            actions: \"setPointerValue\"\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      hasIndex: (_ctx, evt) => evt.index != null\n    },\n    activities: {\n      trackFormControlState(ctx2, _evt, {\n        initialContext\n      }) {\n        return trackFormControl(dom.getRootEl(ctx2), {\n          onFieldsetDisabledChange(disabled) {\n            ctx2.fieldsetDisabled = disabled;\n          },\n          onFormReset() {\n            set.value(ctx2, initialContext.value);\n          }\n        });\n      },\n      trackPointerMove(ctx2, _evt, {\n        send\n      }) {\n        return trackPointerMove(dom.getDoc(ctx2), {\n          onPointerMove(info) {\n            send({\n              type: \"POINTER_MOVE\",\n              point: info.point\n            });\n          },\n          onPointerUp() {\n            send(\"POINTER_UP\");\n          }\n        });\n      },\n      trackThumbsSize(ctx2) {\n        if (ctx2.thumbAlignment !== \"contain\" || ctx2.thumbSize) return;\n        return trackElementsSize({\n          getNodes: () => dom.getElements(ctx2),\n          observeMutation: true,\n          callback(size) {\n            if (!size || isEqualSize(ctx2.thumbSize, size)) return;\n            ctx2.thumbSize = size;\n          }\n        });\n      }\n    },\n    actions: {\n      syncInputElements(ctx2) {\n        ctx2.value.forEach((value, index) => {\n          const inputEl = dom.getHiddenInputEl(ctx2, index);\n          dom.setValue(inputEl, value);\n        });\n      },\n      invokeOnChangeEnd(ctx2) {\n        invoke.valueChangeEnd(ctx2);\n      },\n      setClosestThumbIndex(ctx2, evt) {\n        const pointValue = dom.getValueFromPoint(ctx2, evt.point);\n        if (pointValue == null) return;\n        const focusedIndex = getClosestIndex(ctx2, pointValue);\n        set.focusedIndex(ctx2, focusedIndex);\n      },\n      setFocusedIndex(ctx2, evt) {\n        set.focusedIndex(ctx2, evt.index);\n      },\n      clearFocusedIndex(ctx2) {\n        set.focusedIndex(ctx2, -1);\n      },\n      setPointerValue(ctx2, evt) {\n        const pointerValue = dom.getValueFromPoint(ctx2, evt.point);\n        if (pointerValue == null) return;\n        const value = constrainValue(ctx2, pointerValue, ctx2.focusedIndex);\n        set.valueAtIndex(ctx2, ctx2.focusedIndex, value);\n      },\n      focusActiveThumb(ctx2) {\n        raf(() => {\n          const thumbEl = dom.getThumbEl(ctx2, ctx2.focusedIndex);\n          thumbEl?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      decrementThumbAtIndex(ctx2, evt) {\n        const value = decrement(ctx2, evt.index, evt.step);\n        set.value(ctx2, value);\n      },\n      incrementThumbAtIndex(ctx2, evt) {\n        const value = increment(ctx2, evt.index, evt.step);\n        set.value(ctx2, value);\n      },\n      setFocusedThumbToMin(ctx2) {\n        const {\n          min\n        } = getRangeAtIndex(ctx2, ctx2.focusedIndex);\n        set.valueAtIndex(ctx2, ctx2.focusedIndex, min);\n      },\n      setFocusedThumbToMax(ctx2) {\n        const {\n          max\n        } = getRangeAtIndex(ctx2, ctx2.focusedIndex);\n        set.valueAtIndex(ctx2, ctx2.focusedIndex, max);\n      },\n      coarseValue(ctx2) {\n        const value = normalizeValues(ctx2, ctx2.value);\n        set.value(ctx2, value);\n      },\n      setValueAtIndex(ctx2, evt) {\n        const value = constrainValue(ctx2, evt.value, evt.index);\n        set.valueAtIndex(ctx2, evt.index, value);\n      },\n      setValue(ctx2, evt) {\n        const value = normalizeValues(ctx2, evt.value);\n        set.value(ctx2, value);\n      }\n    }\n  });\n}\nvar invoke = {\n  valueChange(ctx) {\n    ctx.onValueChange?.({\n      value: Array.from(ctx.value)\n    });\n    dom.dispatchChangeEvent(ctx);\n  },\n  valueChangeEnd(ctx) {\n    ctx.onValueChangeEnd?.({\n      value: Array.from(ctx.value)\n    });\n  },\n  focusChange(ctx) {\n    ctx.onFocusChange?.({\n      value: Array.from(ctx.value),\n      focusedIndex: ctx.focusedIndex\n    });\n  }\n};\nvar set = {\n  valueAtIndex: (ctx, index, value) => {\n    if (isEqual(ctx.value[index], value)) return;\n    ctx.value[index] = value;\n    invoke.valueChange(ctx);\n  },\n  value: (ctx, value) => {\n    if (isEqual(ctx.value, value)) return;\n    assignArray(ctx.value, value);\n    invoke.valueChange(ctx);\n  },\n  focusedIndex: (ctx, index) => {\n    if (isEqual(ctx.focusedIndex, index)) return;\n    ctx.focusedIndex = index;\n    invoke.focusChange(ctx);\n  }\n};\nvar props = createProps()([\"aria-label\", \"aria-labelledby\", \"dir\", \"disabled\", \"form\", \"getAriaValueText\", \"getRootNode\", \"id\", \"ids\", \"invalid\", \"max\", \"min\", \"minStepsBetweenThumbs\", \"name\", \"onFocusChange\", \"onValueChange\", \"onValueChangeEnd\", \"orientation\", \"origin\", \"readOnly\", \"step\", \"thumbAlignment\", \"thumbAlignment\", \"thumbSize\", \"value\"]);\nvar splitProps = createSplitProps(props);\nvar thumbProps = createProps()([\"index\", \"name\"]);\nvar splitThumbProps = createSplitProps(thumbProps);\nexport { anatomy, connect, machine, props, splitProps, splitThumbProps, thumbProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
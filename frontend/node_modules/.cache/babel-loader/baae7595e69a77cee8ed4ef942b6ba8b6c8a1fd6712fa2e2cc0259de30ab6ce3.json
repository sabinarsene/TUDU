{"ast":null,"code":"import { time } from '../../frameloop/sync-time.mjs';\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\n/**\r\n * Maximum time allowed between an animation being created and it being\r\n * resolved for us to use the latter as the start time.\r\n *\r\n * This is to ensure that while we prefer to \"start\" an animation as soon\r\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\r\n * between these two moments.\r\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass BaseAnimation {\n  constructor({\n    autoplay = true,\n    delay = 0,\n    type = \"keyframes\",\n    repeat = 0,\n    repeatDelay = 0,\n    repeatType = \"loop\",\n    ...options\n  }) {\n    // Track whether the animation has been stopped. Stopped animations won't restart.\n    this.isStopped = false;\n    this.hasAttemptedResolve = false;\n    this.createdAt = time.now();\n    this.options = {\n      autoplay,\n      delay,\n      type,\n      repeat,\n      repeatDelay,\n      repeatType,\n      ...options\n    };\n    this.updateFinishedPromise();\n  }\n  /**\r\n   * This method uses the createdAt and resolvedAt to calculate the\r\n   * animation startTime. *Ideally*, we would use the createdAt time as t=0\r\n   * as the following frame would then be the first frame of the animation in\r\n   * progress, which would feel snappier.\r\n   *\r\n   * However, if there's a delay (main thread work) between the creation of\r\n   * the animation and the first commited frame, we prefer to use resolvedAt\r\n   * to avoid a sudden jump into the animation.\r\n   */\n  calcStartTime() {\n    if (!this.resolvedAt) return this.createdAt;\n    return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt;\n  }\n  /**\r\n   * A getter for resolved data. If keyframes are not yet resolved, accessing\r\n   * this.resolved will synchronously flush all pending keyframe resolvers.\r\n   * This is a deoptimisation, but at its worst still batches read/writes.\r\n   */\n  get resolved() {\n    if (!this._resolved && !this.hasAttemptedResolve) {\n      flushKeyframeResolvers();\n    }\n    return this._resolved;\n  }\n  /**\r\n   * A method to be called when the keyframes resolver completes. This method\r\n   * will check if its possible to run the animation and, if not, skip it.\r\n   * Otherwise, it will call initPlayback on the implementing class.\r\n   */\n  onKeyframesResolved(keyframes, finalKeyframe) {\n    this.resolvedAt = time.now();\n    this.hasAttemptedResolve = true;\n    const {\n      name,\n      type,\n      velocity,\n      delay,\n      onComplete,\n      onUpdate,\n      isGenerator\n    } = this.options;\n    /**\r\n     * If we can't animate this value with the resolved keyframes\r\n     * then we should complete it immediately.\r\n     */\n    if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n      // Finish immediately\n      if (instantAnimationState.current || !delay) {\n        onUpdate && onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n        onComplete && onComplete();\n        this.resolveFinishedPromise();\n        return;\n      }\n      // Finish after a delay\n      else {\n        this.options.duration = 0;\n      }\n    }\n    const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n    if (resolvedAnimation === false) return;\n    this._resolved = {\n      keyframes,\n      finalKeyframe,\n      ...resolvedAnimation\n    };\n    this.onPostResolved();\n  }\n  onPostResolved() {}\n  /**\r\n   * Allows the returned animation to be awaited or promise-chained. Currently\r\n   * resolves when the animation finishes at all but in a future update could/should\r\n   * reject if its cancels.\r\n   */\n  then(resolve, reject) {\n    return this.currentFinishedPromise.then(resolve, reject);\n  }\n  flatten() {\n    if (!this.options.allowFlatten) return;\n    this.options.type = \"keyframes\";\n    this.options.ease = \"linear\";\n  }\n  updateFinishedPromise() {\n    this.currentFinishedPromise = new Promise(resolve => {\n      this.resolveFinishedPromise = resolve;\n    });\n  }\n}\nexport { BaseAnimation };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
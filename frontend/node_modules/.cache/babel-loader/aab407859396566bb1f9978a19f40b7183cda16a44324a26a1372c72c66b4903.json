{"ast":null,"code":"import { getComputedStyle } from '@zag-js/dom-query';\n\n// src/index.ts\nfunction getScrollPadding(element) {\n  const style = getComputedStyle(element);\n  const rect = element.getBoundingClientRect();\n  let xBeforeRaw = style.getPropertyValue(\"scroll-padding-left\").replace(\"auto\", \"0px\");\n  let yBeforeRaw = style.getPropertyValue(\"scroll-padding-top\").replace(\"auto\", \"0px\");\n  let xAfterRaw = style.getPropertyValue(\"scroll-padding-right\").replace(\"auto\", \"0px\");\n  let yAfterRaw = style.getPropertyValue(\"scroll-padding-bottom\").replace(\"auto\", \"0px\");\n  function convert(raw, size) {\n    let n = parseFloat(raw);\n    if (/%/.test(raw)) {\n      n /= 100;\n      n *= size;\n    }\n    return n;\n  }\n  let xBefore = convert(xBeforeRaw, rect.width);\n  let yBefore = convert(yBeforeRaw, rect.height);\n  let xAfter = convert(xAfterRaw, rect.width);\n  let yAfter = convert(yAfterRaw, rect.height);\n  return {\n    x: {\n      before: xBefore,\n      after: xAfter\n    },\n    y: {\n      before: yBefore,\n      after: yAfter\n    }\n  };\n}\nfunction isRectIntersecting(a, b, axis = \"both\") {\n  return axis === \"x\" && a.right >= b.left && a.left <= b.right || axis === \"y\" && a.bottom >= b.top && a.top <= b.bottom || axis === \"both\" && a.right >= b.left && a.left <= b.right && a.bottom >= b.top && a.top <= b.bottom;\n}\nfunction getDescendants(parent) {\n  let children = [];\n  for (const child of parent.children) {\n    children = children.concat(child, getDescendants(child));\n  }\n  return children;\n}\nfunction getSnapPositions(parent, subtree = false) {\n  const parentRect = parent.getBoundingClientRect();\n  const positions = {\n    x: {\n      start: [],\n      center: [],\n      end: []\n    },\n    y: {\n      start: [],\n      center: [],\n      end: []\n    }\n  };\n  const children = subtree ? getDescendants(parent) : parent.children;\n  for (const axis of [\"x\", \"y\"]) {\n    const orthogonalAxis = axis === \"x\" ? \"y\" : \"x\";\n    const axisStart = axis === \"x\" ? \"left\" : \"top\";\n    const axisSize = axis === \"x\" ? \"width\" : \"height\";\n    const axisScroll = axis === \"x\" ? \"scrollLeft\" : \"scrollTop\";\n    for (const child of children) {\n      const childRect = child.getBoundingClientRect();\n      if (!isRectIntersecting(parentRect, childRect, orthogonalAxis)) {\n        continue;\n      }\n      const childStyle = getComputedStyle(child);\n      let [childAlignY, childAlignX] = childStyle.getPropertyValue(\"scroll-snap-align\").split(\" \");\n      if (typeof childAlignX === \"undefined\") {\n        childAlignX = childAlignY;\n      }\n      const childAlign = axis === \"x\" ? childAlignX : childAlignY;\n      const childOffsetStart = childRect[axisStart] - parentRect[axisStart] + parent[axisScroll];\n      switch (childAlign) {\n        case \"none\":\n          break;\n        case \"start\":\n          positions[axis].start.push({\n            node: child,\n            position: childOffsetStart\n          });\n          break;\n        case \"center\":\n          positions[axis].center.push({\n            node: child,\n            position: childOffsetStart + childRect[axisSize] / 2\n          });\n          break;\n        case \"end\":\n          positions[axis].end.push({\n            node: child,\n            position: childOffsetStart + childRect[axisSize]\n          });\n          break;\n      }\n    }\n  }\n  return positions;\n}\nfunction getScrollSnapPositions(element) {\n  const rect = element.getBoundingClientRect();\n  const scrollPadding = getScrollPadding(element);\n  const snapPositions = getSnapPositions(element);\n  const maxScroll = {\n    x: element.scrollWidth - element.offsetWidth,\n    y: element.scrollHeight - element.offsetHeight\n  };\n  return {\n    x: uniq([...snapPositions.x.start.map(v => v.position - scrollPadding.x.before), ...snapPositions.x.center.map(v => v.position - rect.width / 2), ...snapPositions.x.end.map(v => v.position - rect.width + scrollPadding.x.after)].map(clamp(0, maxScroll.x))),\n    y: uniq([...snapPositions.y.start.map(v => v.position - scrollPadding.y.before), ...snapPositions.y.center.map(v => v.position - rect.height / 2), ...snapPositions.y.end.map(v => v.position - rect.height + scrollPadding.y.after)].map(clamp(0, maxScroll.y)))\n  };\n}\nfunction findSnapPoint(parent, axis, predicate) {\n  const snapPositions = getSnapPositions(parent);\n  const items = [...snapPositions[axis].start, ...snapPositions[axis].center, ...snapPositions[axis].end];\n  for (const item of items) {\n    if (predicate(item.node)) {\n      return item.position;\n    }\n  }\n}\nfunction getSnapPointTarget(parent, snapPoint) {\n  const rect = parent.getBoundingClientRect();\n  const scrollPadding = getScrollPadding(parent);\n  const children = Array.from(parent.children);\n  for (const child of children) {\n    const childRect = child.getBoundingClientRect();\n    const childOffsetStart = {\n      x: childRect.left - rect.left + parent.scrollLeft,\n      y: childRect.top - rect.top + parent.scrollTop\n    };\n    const matchesX = [childOffsetStart.x - scrollPadding.x.before,\n    // start\n    childOffsetStart.x + childRect.width / 2 - rect.width / 2,\n    // center\n    childOffsetStart.x + childRect.width - rect.width + scrollPadding.x.after\n    // end\n    ].some(pos => Math.abs(pos - snapPoint) < 1);\n    const matchesY = [childOffsetStart.y - scrollPadding.y.before, childOffsetStart.y + childRect.height / 2 - rect.height / 2, childOffsetStart.y + childRect.height - rect.height + scrollPadding.y.after].some(pos => Math.abs(pos - snapPoint) < 1);\n    if (matchesX || matchesY) {\n      return child;\n    }\n  }\n  return children[0];\n}\nvar uniq = arr => [...new Set(arr)];\nvar clamp = (min, max) => value => Math.max(min, Math.min(max, value));\nexport { findSnapPoint, getScrollSnapPositions, getSnapPointTarget, getSnapPositions };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
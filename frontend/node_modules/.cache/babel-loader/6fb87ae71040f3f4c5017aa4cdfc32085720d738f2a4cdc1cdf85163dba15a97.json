{"ast":null,"code":"'use client';\n\nimport { useDisclosure, useOutsideClick, useFocusOnHide, useAnimationState, useIds, useUpdateEffect, mergeRefs, useControllableState } from '@chakra-ui/hooks';\nimport { createContext, dataAttr, callAllHandlers, lazyDisclosure, getValidChildren } from '@chakra-ui/utils';\nimport { useRef, useCallback, useState, useEffect, useId, cloneElement } from 'react';\nimport { getNextItemFromSearch } from './get-next-item-from-search.mjs';\nimport { useShortcut } from './use-shortcut.mjs';\nimport { createDescendantContext } from '../descendant/use-descendant.mjs';\nimport { usePopper } from '../popper/use-popper.mjs';\nimport { useClickable } from '../clickable/use-clickable.mjs';\nconst [MenuDescendantsProvider, useMenuDescendantsContext, useMenuDescendants, useMenuDescendant] = createDescendantContext();\nconst [MenuProvider, useMenuContext] = createContext({\n  strict: false,\n  name: \"MenuContext\"\n});\nfunction getOwnerDocument(node) {\n  return node?.ownerDocument ?? document;\n}\nfunction isActiveElement(element) {\n  const doc = getOwnerDocument(element);\n  return doc.activeElement === element;\n}\nfunction useMenu(props = {}) {\n  const {\n    id,\n    closeOnSelect = true,\n    closeOnBlur = true,\n    initialFocusRef,\n    autoSelect = true,\n    isLazy,\n    isOpen: isOpenProp,\n    defaultIsOpen,\n    onClose: onCloseProp,\n    onOpen: onOpenProp,\n    placement = \"bottom-start\",\n    lazyBehavior = \"unmount\",\n    direction,\n    computePositionOnMount = false,\n    ...popperProps\n  } = props;\n  const menuRef = useRef(null);\n  const buttonRef = useRef(null);\n  const scrollIntoViewRef = useRef(true);\n  const descendants = useMenuDescendants();\n  const focusMenu = useCallback(() => {\n    requestAnimationFrame(() => {\n      menuRef.current?.focus({\n        preventScroll: false\n      });\n    });\n  }, []);\n  const focusFirstItem = useCallback(() => {\n    const id2 = setTimeout(() => {\n      if (initialFocusRef) {\n        initialFocusRef.current?.focus();\n      } else if (!descendants.count()) {\n        menuRef.current?.focus({\n          preventScroll: false\n        });\n      } else {\n        const first = descendants.firstEnabled();\n        if (first) setFocusedIndex(first.index);\n      }\n    });\n    timeoutIds.current.add(id2);\n  }, [descendants, initialFocusRef]);\n  const focusLastItem = useCallback(() => {\n    const id2 = setTimeout(() => {\n      if (!descendants.count()) {\n        menuRef.current?.focus({\n          preventScroll: false\n        });\n      } else {\n        const last = descendants.lastEnabled();\n        if (last) setFocusedIndex(last.index);\n      }\n    });\n    timeoutIds.current.add(id2);\n  }, [descendants]);\n  const onOpenInternal = useCallback(() => {\n    onOpenProp?.();\n    if (autoSelect) {\n      focusFirstItem();\n    } else {\n      focusMenu();\n    }\n  }, [autoSelect, focusFirstItem, focusMenu, onOpenProp]);\n  const {\n    isOpen,\n    onOpen,\n    onClose,\n    onToggle\n  } = useDisclosure({\n    isOpen: isOpenProp,\n    defaultIsOpen,\n    onClose: onCloseProp,\n    onOpen: onOpenInternal\n  });\n  useOutsideClick({\n    enabled: isOpen && closeOnBlur,\n    ref: menuRef,\n    handler: event => {\n      const target = event.composedPath?.()?.[0] ?? event.target;\n      if (!buttonRef.current?.contains(target)) {\n        onClose();\n      }\n    }\n  });\n  const popper = usePopper({\n    ...popperProps,\n    enabled: isOpen || computePositionOnMount,\n    placement,\n    direction\n  });\n  const [focusedIndex, setFocusedIndex] = useState(-1);\n  useFocusOnHide(menuRef, {\n    focusRef: buttonRef,\n    visible: isOpen,\n    shouldFocus: true\n  });\n  const animationState = useAnimationState({\n    isOpen,\n    ref: menuRef\n  });\n  const [buttonId, menuId] = useIds(id, `menu-button`, `menu-list`);\n  const openAndFocusMenu = useCallback(() => {\n    onOpen();\n    focusMenu();\n  }, [onOpen, focusMenu]);\n  const timeoutIds = useRef(/* @__PURE__ */new Set([]));\n  useEffect(() => {\n    const ids = timeoutIds.current;\n    return () => {\n      ids.forEach(id2 => clearTimeout(id2));\n      ids.clear();\n    };\n  }, []);\n  useUpdateEffect(() => {\n    if (isOpen) return;\n    setFocusedIndex(-1);\n    menuRef.current?.scrollTo(0, 0);\n  }, [isOpen]);\n  useUpdateEffect(() => {\n    if (!isOpen) return;\n    if (focusedIndex === -1) {\n      focusMenu();\n    }\n  }, [focusedIndex, isOpen]);\n  useEffect(() => {\n    if (!isOpen) return;\n    const item = descendants.item(focusedIndex);\n    item?.node?.focus({\n      preventScroll: !scrollIntoViewRef.current\n    });\n  }, [descendants, focusedIndex, isOpen]);\n  const openAndFocusFirstItem = useCallback(() => {\n    onOpen();\n    focusFirstItem();\n  }, [focusFirstItem, onOpen]);\n  const openAndFocusLastItem = useCallback(() => {\n    scrollIntoViewRef.current = true;\n    onOpen();\n    focusLastItem();\n  }, [onOpen, focusLastItem]);\n  const refocus = useCallback(() => {\n    const doc = getOwnerDocument(menuRef.current);\n    const hasFocusWithin = menuRef.current?.contains(doc.activeElement);\n    const shouldRefocus = isOpen && !hasFocusWithin;\n    if (!shouldRefocus) return;\n    const node = descendants.item(focusedIndex)?.node;\n    node?.focus({\n      preventScroll: !scrollIntoViewRef.current\n    });\n  }, [isOpen, focusedIndex, descendants]);\n  return {\n    openAndFocusMenu,\n    openAndFocusFirstItem,\n    openAndFocusLastItem,\n    onTransitionEnd: refocus,\n    unstable__animationState: animationState,\n    descendants,\n    popper,\n    buttonId,\n    menuId,\n    forceUpdate: popper.forceUpdate,\n    orientation: \"vertical\",\n    isOpen,\n    onToggle,\n    onOpen,\n    onClose,\n    menuRef,\n    buttonRef,\n    focusedIndex,\n    closeOnSelect,\n    closeOnBlur,\n    autoSelect,\n    setFocusedIndex,\n    isLazy,\n    lazyBehavior,\n    initialFocusRef,\n    scrollIntoViewRef\n  };\n}\nfunction useMenuButton(props = {}, externalRef = null) {\n  const menu = useMenuContext();\n  const {\n    onToggle,\n    popper,\n    openAndFocusFirstItem,\n    openAndFocusLastItem,\n    scrollIntoViewRef\n  } = menu;\n  const onKeyDown = useCallback(event => {\n    const eventKey = event.key;\n    const keyMap = {\n      Enter: openAndFocusFirstItem,\n      ArrowDown: openAndFocusFirstItem,\n      ArrowUp: openAndFocusLastItem\n    };\n    const action = keyMap[eventKey];\n    if (action) {\n      scrollIntoViewRef.current = true;\n      event.preventDefault();\n      event.stopPropagation();\n      action(event);\n    }\n  }, [openAndFocusFirstItem, openAndFocusLastItem, scrollIntoViewRef]);\n  return {\n    ...props,\n    ref: mergeRefs(menu.buttonRef, externalRef, popper.referenceRef),\n    id: menu.buttonId,\n    \"data-active\": dataAttr(menu.isOpen),\n    \"aria-expanded\": menu.isOpen,\n    \"aria-haspopup\": \"menu\",\n    \"aria-controls\": menu.menuId,\n    onClick: callAllHandlers(props.onClick, onToggle),\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  };\n}\nfunction isTargetMenuItem(target) {\n  return isHTMLElement(target) && !!target?.getAttribute(\"role\")?.startsWith(\"menuitem\");\n}\nfunction useMenuList(props = {}, ref = null) {\n  const menu = useMenuContext();\n  if (!menu) {\n    throw new Error(`useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>`);\n  }\n  const {\n    focusedIndex,\n    setFocusedIndex,\n    menuRef,\n    isOpen,\n    onClose,\n    menuId,\n    isLazy,\n    lazyBehavior,\n    scrollIntoViewRef,\n    unstable__animationState: animated\n  } = menu;\n  const descendants = useMenuDescendantsContext();\n  const createTypeaheadHandler = useShortcut({\n    preventDefault: event => event.key !== \" \" && isTargetMenuItem(event.target)\n  });\n  const onKeyDown = useCallback(event => {\n    if (!event.currentTarget.contains(event.target)) return;\n    const eventKey = event.key;\n    const keyMap = {\n      Tab: event2 => event2.preventDefault(),\n      Escape: event2 => {\n        event2.stopPropagation();\n        onClose();\n      },\n      ArrowDown: () => {\n        scrollIntoViewRef.current = true;\n        const next = descendants.nextEnabled(focusedIndex) ?? descendants.firstEnabled();\n        if (next) setFocusedIndex(next.index);\n      },\n      ArrowUp: () => {\n        scrollIntoViewRef.current = true;\n        const prev = descendants.prevEnabled(focusedIndex) ?? descendants.firstEnabled();\n        if (prev) setFocusedIndex(prev.index);\n      }\n    };\n    const fn = keyMap[eventKey];\n    if (fn) {\n      event.preventDefault();\n      fn(event);\n      return;\n    }\n    const onTypeahead = createTypeaheadHandler(character => {\n      const nextItem = getNextItemFromSearch(descendants.values(), character, item => item?.node?.textContent ?? \"\", descendants.item(focusedIndex));\n      if (nextItem) {\n        const index = descendants.indexOf(nextItem.node);\n        setFocusedIndex(index);\n      }\n    });\n    if (isTargetMenuItem(event.target)) {\n      onTypeahead(event);\n    }\n  }, [descendants, focusedIndex, createTypeaheadHandler, onClose, setFocusedIndex, scrollIntoViewRef]);\n  const hasBeenOpened = useRef(false);\n  if (isOpen) {\n    hasBeenOpened.current = true;\n  }\n  const shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenOpened.current,\n    enabled: isLazy,\n    mode: lazyBehavior,\n    isSelected: animated.present\n  });\n  return {\n    ...props,\n    ref: mergeRefs(menuRef, ref),\n    children: shouldRenderChildren ? props.children : null,\n    tabIndex: -1,\n    role: \"menu\",\n    id: menuId,\n    style: {\n      ...props.style,\n      transformOrigin: \"var(--popper-transform-origin)\"\n    },\n    \"aria-orientation\": \"vertical\",\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  };\n}\nfunction useMenuPositioner(props = {}) {\n  const {\n    popper,\n    isOpen\n  } = useMenuContext();\n  return popper.getPopperProps({\n    ...props,\n    style: {\n      visibility: isOpen ? \"visible\" : \"hidden\",\n      ...props.style\n    }\n  });\n}\nfunction useMenuItem(props = {}, externalRef = null) {\n  const {\n    onMouseEnter: onMouseEnterProp,\n    onMouseMove: onMouseMoveProp,\n    onMouseLeave: onMouseLeaveProp,\n    onClick: onClickProp,\n    onFocus: onFocusProp,\n    isDisabled,\n    isFocusable,\n    closeOnSelect,\n    type: typeProp,\n    ...htmlProps\n  } = props;\n  const menu = useMenuContext();\n  const {\n    setFocusedIndex,\n    focusedIndex,\n    closeOnSelect: menuCloseOnSelect,\n    onClose,\n    menuId,\n    scrollIntoViewRef\n  } = menu;\n  const ref = useRef(null);\n  const id = `${menuId}-menuitem-${useId()}`;\n  const {\n    index,\n    register\n  } = useMenuDescendant({\n    disabled: isDisabled && !isFocusable\n  });\n  const onMouseEnter = useCallback(event => {\n    onMouseEnterProp?.(event);\n    if (isDisabled) return;\n    scrollIntoViewRef.current = false;\n    setFocusedIndex(index);\n  }, [setFocusedIndex, index, isDisabled, onMouseEnterProp, scrollIntoViewRef]);\n  const onMouseMove = useCallback(event => {\n    onMouseMoveProp?.(event);\n    if (ref.current && !isActiveElement(ref.current)) {\n      onMouseEnter(event);\n    }\n  }, [onMouseEnter, onMouseMoveProp]);\n  const onMouseLeave = useCallback(event => {\n    onMouseLeaveProp?.(event);\n    if (isDisabled) return;\n    setFocusedIndex(-1);\n  }, [setFocusedIndex, isDisabled, onMouseLeaveProp]);\n  const onClick = useCallback(event => {\n    onClickProp?.(event);\n    if (!isTargetMenuItem(event.currentTarget)) return;\n    if (closeOnSelect ?? menuCloseOnSelect) {\n      onClose();\n    }\n  }, [onClose, onClickProp, menuCloseOnSelect, closeOnSelect]);\n  const onFocus = useCallback(event => {\n    onFocusProp?.(event);\n    setFocusedIndex(index);\n  }, [setFocusedIndex, onFocusProp, index]);\n  const isFocused = index === focusedIndex;\n  const clickableProps = useClickable({\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    ref: mergeRefs(register, ref, externalRef),\n    isDisabled,\n    isFocusable\n  });\n  return {\n    ...htmlProps,\n    ...clickableProps,\n    type: typeProp ?? clickableProps.type,\n    id,\n    role: \"menuitem\",\n    tabIndex: isFocused ? 0 : -1\n  };\n}\nfunction useMenuOption(props = {}, ref = null) {\n  const {\n    type = \"radio\",\n    isChecked,\n    ...rest\n  } = props;\n  const ownProps = useMenuItem(rest, ref);\n  return {\n    ...ownProps,\n    role: `menuitem${type}`,\n    \"aria-checked\": isChecked\n  };\n}\nfunction useMenuOptionGroup(props = {}) {\n  const {\n    children,\n    type = \"radio\",\n    value: valueProp,\n    defaultValue,\n    onChange: onChangeProp,\n    ...htmlProps\n  } = props;\n  const isRadio = type === \"radio\";\n  const fallback = isRadio ? \"\" : [];\n  const [value, setValue] = useControllableState({\n    defaultValue: defaultValue ?? fallback,\n    value: valueProp,\n    onChange: onChangeProp\n  });\n  const onChange = useCallback(selectedValue => {\n    if (type === \"radio\" && typeof value === \"string\") {\n      setValue(selectedValue);\n    }\n    if (type === \"checkbox\" && Array.isArray(value)) {\n      const nextValue = value.includes(selectedValue) ? value.filter(item => item !== selectedValue) : value.concat(selectedValue);\n      setValue(nextValue);\n    }\n  }, [value, setValue, type]);\n  const validChildren = getValidChildren(children);\n  const clones = validChildren.map(child => {\n    if (child.type.id !== \"MenuItemOption\") return child;\n    const onClick = event => {\n      onChange(child.props.value);\n      child.props.onClick?.(event);\n    };\n    const isChecked = type === \"radio\" ? child.props.value === value : value.includes(child.props.value);\n    return cloneElement(child, {\n      type,\n      onClick,\n      isChecked\n    });\n  });\n  return {\n    ...htmlProps,\n    children: clones\n  };\n}\nfunction useMenuState() {\n  const {\n    isOpen,\n    onClose\n  } = useMenuContext();\n  return {\n    isOpen,\n    onClose\n  };\n}\nfunction isHTMLElement(el) {\n  if (!isElement(el)) return false;\n  const win = el.ownerDocument.defaultView ?? window;\n  return el instanceof win.HTMLElement;\n}\nfunction isElement(el) {\n  return el != null && typeof el == \"object\" && \"nodeType\" in el && el.nodeType === Node.ELEMENT_NODE;\n}\nexport { MenuDescendantsProvider, MenuProvider, useMenu, useMenuButton, useMenuContext, useMenuDescendant, useMenuDescendants, useMenuDescendantsContext, useMenuItem, useMenuList, useMenuOption, useMenuOptionGroup, useMenuPositioner, useMenuState };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import axios from 'axios';\nimport { API_BASE_URL } from '../config/api';\n\n// Use consistent API URL format\nconst API_ENDPOINT = `${API_BASE_URL}/api/services`;\n\n// Log the API URL for debugging\nconsole.log('API URL:', API_ENDPOINT);\n\n/**\n * Fetch all services from the API\n * @returns {Promise<Array>} Array of services\n */\nconst getServices = async (filters = {}) => {\n  try {\n    const queryParams = new URLSearchParams(filters).toString();\n    const fullUrl = `${API_ENDPOINT}${queryParams ? `?${queryParams}` : ''}`;\n    const response = await fetch(fullUrl);\n    return await response.json();\n  } catch (error) {\n    console.error('Error fetching services:', error);\n    throw error;\n  }\n};\n\n/**\n * Fetch a single service by ID\n * @param {number} id - Service ID\n * @returns {Promise<Object>} Service object\n */\nconst getServiceById = async id => {\n  try {\n    const response = await fetch(`${API_ENDPOINT}/${id}`);\n    return await response.json();\n  } catch (error) {\n    console.error('Error fetching service:', error);\n    throw error;\n  }\n};\n\n/**\n * Create a new service\n * @param {FormData} serviceData - Service data as FormData (for file uploads)\n * @returns {Promise<Object>} Created service\n */\nconst createService = async serviceData => {\n  try {\n    // Log the raw service data for debugging\n    console.log('Raw service data fields:', Array.from(serviceData.entries()));\n    const formattedData = new FormData();\n\n    // Add basic fields\n    const fields = ['title', 'category', 'price', 'currency', 'location', 'description'];\n    fields.forEach(field => {\n      const value = serviceData.get(field);\n      if (value) {\n        formattedData.append(field, value.trim());\n      }\n    });\n\n    // Handle images\n    const images = serviceData.getAll('images');\n    if (images && images.length > 0) {\n      console.log('Processing images:', images.length, 'files');\n      images.forEach((image, index) => {\n        console.log(`Image ${index + 1}:`, image.name, image.type, image.size);\n        formattedData.append('image', image); // Changed to 'image' as per Multer config\n      });\n    }\n\n    // Log the formatted data for debugging\n    console.log('Formatted form data fields:', Array.from(formattedData.entries()));\n    const token = localStorage.getItem('token');\n    if (!token) {\n      throw new Error('Nu ești autentificat');\n    }\n    console.log('Sending request to:', API_ENDPOINT);\n    const response = await fetch(API_ENDPOINT, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${token}`\n      },\n      body: formattedData\n    });\n    console.log('Response status:', response.status);\n    console.log('Response headers:', Object.fromEntries(response.headers));\n    if (!response.ok) {\n      let errorMessage = 'Failed to create service';\n      try {\n        const errorData = await response.json();\n        console.error('Server error details:', errorData);\n        errorMessage = errorData.message || errorMessage;\n      } catch (e) {\n        console.error('Could not parse error response:', e);\n      }\n      throw new Error(errorMessage);\n    }\n    const data = await response.json();\n    console.log('Service created successfully:', data);\n    return data;\n  } catch (error) {\n    console.error('Error creating service:', error);\n    throw error;\n  }\n};\n\n/**\n * Update an existing service\n * @param {number} id - Service ID\n * @param {Object|FormData} serviceData - Updated service data\n * @param {string} token - Authentication token\n * @returns {Promise<Object>} Updated service\n */\nconst updateService = async (id, serviceData) => {\n  try {\n    const response = await fetch(`${API_ENDPOINT}/${id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${localStorage.getItem('token')}`\n      },\n      body: JSON.stringify(serviceData)\n    });\n    return await response.json();\n  } catch (error) {\n    console.error('Error updating service:', error);\n    throw error;\n  }\n};\n\n/**\n * Delete a service\n * @param {number} id - Service ID\n * @param {string} token - Authentication token\n * @returns {Promise<Object>} Response message\n */\nconst deleteService = async id => {\n  try {\n    const response = await fetch(`${API_ENDPOINT}/${id}`, {\n      method: 'DELETE',\n      headers: {\n        'Authorization': `Bearer ${localStorage.getItem('token')}`\n      }\n    });\n    return await response.json();\n  } catch (error) {\n    console.error('Error deleting service:', error);\n    throw error;\n  }\n};\n\n/**\n * Submit a rating for a user\n * @param {string} userId - ID of the user being rated\n * @param {number} rating - Rating value (1-5)\n * @param {string} comment - Optional comment with the rating\n * @param {string} token - Authentication token\n * @returns {Promise<Object>} Response with the updated rating information\n */\nconst submitUserRating = async (userId, rating, comment, token) => {\n  try {\n    console.log(`Submitting rating ${rating} for user ${userId} with comment: ${comment}`);\n    const apiUrl = `${API_BASE_URL}/api/users/${userId}/ratings`;\n    console.log('API URL:', apiUrl);\n\n    // Verificăm dacă avem token\n    if (!token) {\n      console.error('No token provided');\n      throw new Error('Nu ești autentificat');\n    }\n    console.log('Using token:', token);\n\n    // Configurăm axios cu timeout și headers\n    const axiosInstance = axios.create({\n      timeout: 10000,\n      // 10 secunde timeout\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`,\n        'x-auth-token': token // pentru compatibilitate\n      }\n    });\n    console.log('Request headers:', axiosInstance.defaults.headers);\n    const response = await axiosInstance.post(apiUrl, {\n      rating,\n      comment\n    });\n    console.log('Response status:', response.status);\n    console.log('Response headers:', response.headers);\n    console.log('Rating submitted successfully:', response.data);\n    return response.data;\n  } catch (error) {\n    console.error(`Error submitting rating for user ${userId}:`, error);\n    if (error.response) {\n      // Serverul a răspuns cu un status code în afara intervalului 2xx\n      console.error('Server error response:', error.response.data);\n      const errorMessage = error.response.data.message || `Error submitting rating: ${error.response.statusText}`;\n      throw new Error(errorMessage);\n    } else if (error.request) {\n      // Cererea a fost făcută dar nu s-a primit răspuns\n      console.error('No response received:', error.request);\n      throw new Error('Nu s-a putut contacta serverul. Verificați conexiunea la internet.');\n    } else {\n      // Ceva s-a întâmplat la configurarea cererii\n      console.error('Request configuration error:', error.message);\n      throw error;\n    }\n  }\n};\n\n/**\n * Fetch ratings for a user\n * @param {string} userId - ID of the user\n * @returns {Promise<Object>} Object with ratings array\n */\nconst fetchUserRatings = async userId => {\n  try {\n    console.log(`Fetching ratings for user ${userId}`);\n    const apiUrl = `${API_BASE_URL}/api/users/${userId}/ratings`;\n    console.log('API URL:', apiUrl);\n\n    // Adăugăm un timeout pentru a evita blocarea UI-ului\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 secunde timeout\n\n    try {\n      const response = await fetch(apiUrl, {\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n      console.log('Response status:', response.status);\n      console.log('Response headers:', Object.fromEntries([...response.headers]));\n      if (!response.ok) {\n        if (response.status === 404) {\n          console.log(`Endpoint /users/${userId}/ratings nu este disponibil sau utilizatorul nu are evaluări`);\n          return {\n            ratings: [],\n            averageRating: 0,\n            reviewCount: 0\n          };\n        }\n\n        // Încercăm să obținem detalii despre eroare\n        try {\n          const errorData = await response.json();\n          console.error('Error response data:', errorData);\n          throw new Error(errorData.message || `Error fetching ratings: ${response.statusText}`);\n        } catch (jsonError) {\n          console.error('Could not parse error response:', jsonError);\n          throw new Error(`Error fetching ratings: ${response.statusText}`);\n        }\n      }\n      const data = await response.json();\n      console.log('Ratings fetched successfully:', data);\n      return data;\n    } catch (fetchError) {\n      clearTimeout(timeoutId);\n      if (fetchError.name === 'AbortError') {\n        console.error('Request timed out after 10 seconds');\n        throw new Error('Cererea a expirat. Serverul nu a răspuns în timp util.');\n      }\n      throw fetchError;\n    }\n  } catch (error) {\n    console.error(`Error fetching ratings for user ${userId}:`, error);\n\n    // Returnăm un obiect gol în loc să aruncăm eroarea\n    // pentru a permite componentei să afișeze un mesaj de eroare\n    return {\n      ratings: [],\n      averageRating: 0,\n      reviewCount: 0\n    };\n  }\n};\n\n/**\n * Fetch services for a specific user\n * @param {string} userId - User ID\n * @returns {Promise<Array>} Array of services\n */\nconst getUserServices = async userId => {\n  try {\n    const response = await fetch(`${API_ENDPOINT}/user/${userId}`);\n    return await response.json();\n  } catch (error) {\n    console.error('Error fetching user services:', error);\n    throw error;\n  }\n};\n\n// Single export statement at the end of the file\nexport { getServices, getServiceById, createService, updateService, deleteService, getUserServices, submitUserRating, fetchUserRatings };","map":{"version":3,"names":["axios","API_BASE_URL","API_ENDPOINT","console","log","getServices","filters","queryParams","URLSearchParams","toString","fullUrl","response","fetch","json","error","getServiceById","id","createService","serviceData","Array","from","entries","formattedData","FormData","fields","forEach","field","value","get","append","trim","images","getAll","length","image","index","name","type","size","token","localStorage","getItem","Error","method","headers","body","status","Object","fromEntries","ok","errorMessage","errorData","message","e","data","updateService","JSON","stringify","deleteService","submitUserRating","userId","rating","comment","apiUrl","axiosInstance","create","timeout","defaults","post","statusText","request","fetchUserRatings","controller","AbortController","timeoutId","setTimeout","abort","signal","clearTimeout","ratings","averageRating","reviewCount","jsonError","fetchError","getUserServices"],"sources":["C:/Users/sabin.arsene/Desktop/Tudu-app/TUDU/frontend/src/services/serviceApi.js"],"sourcesContent":["import axios from 'axios';\nimport { API_BASE_URL } from '../config/api';\n\n// Use consistent API URL format\nconst API_ENDPOINT = `${API_BASE_URL}/api/services`;\n\n// Log the API URL for debugging\nconsole.log('API URL:', API_ENDPOINT);\n\n/**\n * Fetch all services from the API\n * @returns {Promise<Array>} Array of services\n */\nconst getServices = async (filters = {}) => {\n  try {\n    const queryParams = new URLSearchParams(filters).toString();\n    const fullUrl = `${API_ENDPOINT}${queryParams ? `?${queryParams}` : ''}`;\n    const response = await fetch(fullUrl);\n    return await response.json();\n  } catch (error) {\n    console.error('Error fetching services:', error);\n    throw error;\n  }\n};\n\n/**\n * Fetch a single service by ID\n * @param {number} id - Service ID\n * @returns {Promise<Object>} Service object\n */\nconst getServiceById = async (id) => {\n  try {\n    const response = await fetch(`${API_ENDPOINT}/${id}`);\n    return await response.json();\n  } catch (error) {\n    console.error('Error fetching service:', error);\n    throw error;\n  }\n};\n\n/**\n * Create a new service\n * @param {FormData} serviceData - Service data as FormData (for file uploads)\n * @returns {Promise<Object>} Created service\n */\nconst createService = async (serviceData) => {\n  try {\n    // Log the raw service data for debugging\n    console.log('Raw service data fields:', Array.from(serviceData.entries()));\n\n    const formattedData = new FormData();\n    \n    // Add basic fields\n    const fields = ['title', 'category', 'price', 'currency', 'location', 'description'];\n    fields.forEach(field => {\n      const value = serviceData.get(field);\n      if (value) {\n        formattedData.append(field, value.trim());\n      }\n    });\n\n    // Handle images\n    const images = serviceData.getAll('images');\n    if (images && images.length > 0) {\n      console.log('Processing images:', images.length, 'files');\n      images.forEach((image, index) => {\n        console.log(`Image ${index + 1}:`, image.name, image.type, image.size);\n        formattedData.append('image', image); // Changed to 'image' as per Multer config\n      });\n    }\n\n    // Log the formatted data for debugging\n    console.log('Formatted form data fields:', Array.from(formattedData.entries()));\n\n    const token = localStorage.getItem('token');\n    if (!token) {\n      throw new Error('Nu ești autentificat');\n    }\n\n    console.log('Sending request to:', API_ENDPOINT);\n    const response = await fetch(API_ENDPOINT, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${token}`\n      },\n      body: formattedData\n    });\n\n    console.log('Response status:', response.status);\n    console.log('Response headers:', Object.fromEntries(response.headers));\n\n    if (!response.ok) {\n      let errorMessage = 'Failed to create service';\n      try {\n        const errorData = await response.json();\n        console.error('Server error details:', errorData);\n        errorMessage = errorData.message || errorMessage;\n      } catch (e) {\n        console.error('Could not parse error response:', e);\n      }\n      throw new Error(errorMessage);\n    }\n\n    const data = await response.json();\n    console.log('Service created successfully:', data);\n    return data;\n  } catch (error) {\n    console.error('Error creating service:', error);\n    throw error;\n  }\n};\n\n/**\n * Update an existing service\n * @param {number} id - Service ID\n * @param {Object|FormData} serviceData - Updated service data\n * @param {string} token - Authentication token\n * @returns {Promise<Object>} Updated service\n */\nconst updateService = async (id, serviceData) => {\n  try {\n    const response = await fetch(`${API_ENDPOINT}/${id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${localStorage.getItem('token')}`\n      },\n      body: JSON.stringify(serviceData)\n    });\n    return await response.json();\n  } catch (error) {\n    console.error('Error updating service:', error);\n    throw error;\n  }\n};\n\n/**\n * Delete a service\n * @param {number} id - Service ID\n * @param {string} token - Authentication token\n * @returns {Promise<Object>} Response message\n */\nconst deleteService = async (id) => {\n  try {\n    const response = await fetch(`${API_ENDPOINT}/${id}`, {\n      method: 'DELETE',\n      headers: {\n        'Authorization': `Bearer ${localStorage.getItem('token')}`\n      }\n    });\n    return await response.json();\n  } catch (error) {\n    console.error('Error deleting service:', error);\n    throw error;\n  }\n};\n\n/**\n * Submit a rating for a user\n * @param {string} userId - ID of the user being rated\n * @param {number} rating - Rating value (1-5)\n * @param {string} comment - Optional comment with the rating\n * @param {string} token - Authentication token\n * @returns {Promise<Object>} Response with the updated rating information\n */\nconst submitUserRating = async (userId, rating, comment, token) => {\n  try {\n    console.log(`Submitting rating ${rating} for user ${userId} with comment: ${comment}`);\n    const apiUrl = `${API_BASE_URL}/api/users/${userId}/ratings`;\n    console.log('API URL:', apiUrl);\n    \n    // Verificăm dacă avem token\n    if (!token) {\n      console.error('No token provided');\n      throw new Error('Nu ești autentificat');\n    }\n    \n    console.log('Using token:', token);\n    \n    // Configurăm axios cu timeout și headers\n    const axiosInstance = axios.create({\n      timeout: 10000, // 10 secunde timeout\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`,\n        'x-auth-token': token // pentru compatibilitate\n      }\n    });\n    \n    console.log('Request headers:', axiosInstance.defaults.headers);\n    \n    const response = await axiosInstance.post(apiUrl, {\n      rating,\n      comment\n    });\n    \n    console.log('Response status:', response.status);\n    console.log('Response headers:', response.headers);\n    console.log('Rating submitted successfully:', response.data);\n    \n    return response.data;\n  } catch (error) {\n    console.error(`Error submitting rating for user ${userId}:`, error);\n    \n    if (error.response) {\n      // Serverul a răspuns cu un status code în afara intervalului 2xx\n      console.error('Server error response:', error.response.data);\n      const errorMessage = error.response.data.message || `Error submitting rating: ${error.response.statusText}`;\n      throw new Error(errorMessage);\n    } else if (error.request) {\n      // Cererea a fost făcută dar nu s-a primit răspuns\n      console.error('No response received:', error.request);\n      throw new Error('Nu s-a putut contacta serverul. Verificați conexiunea la internet.');\n    } else {\n      // Ceva s-a întâmplat la configurarea cererii\n      console.error('Request configuration error:', error.message);\n      throw error;\n    }\n  }\n};\n\n/**\n * Fetch ratings for a user\n * @param {string} userId - ID of the user\n * @returns {Promise<Object>} Object with ratings array\n */\nconst fetchUserRatings = async (userId) => {\n  try {\n    console.log(`Fetching ratings for user ${userId}`);\n    const apiUrl = `${API_BASE_URL}/api/users/${userId}/ratings`;\n    console.log('API URL:', apiUrl);\n    \n    // Adăugăm un timeout pentru a evita blocarea UI-ului\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 secunde timeout\n    \n    try {\n      const response = await fetch(apiUrl, {\n        signal: controller.signal\n      });\n      \n      clearTimeout(timeoutId);\n      \n      console.log('Response status:', response.status);\n      console.log('Response headers:', Object.fromEntries([...response.headers]));\n      \n      if (!response.ok) {\n        if (response.status === 404) {\n          console.log(`Endpoint /users/${userId}/ratings nu este disponibil sau utilizatorul nu are evaluări`);\n          return { ratings: [], averageRating: 0, reviewCount: 0 };\n        }\n        \n        // Încercăm să obținem detalii despre eroare\n        try {\n          const errorData = await response.json();\n          console.error('Error response data:', errorData);\n          throw new Error(errorData.message || `Error fetching ratings: ${response.statusText}`);\n        } catch (jsonError) {\n          console.error('Could not parse error response:', jsonError);\n          throw new Error(`Error fetching ratings: ${response.statusText}`);\n        }\n      }\n      \n      const data = await response.json();\n      console.log('Ratings fetched successfully:', data);\n      return data;\n    } catch (fetchError) {\n      clearTimeout(timeoutId);\n      \n      if (fetchError.name === 'AbortError') {\n        console.error('Request timed out after 10 seconds');\n        throw new Error('Cererea a expirat. Serverul nu a răspuns în timp util.');\n      }\n      \n      throw fetchError;\n    }\n  } catch (error) {\n    console.error(`Error fetching ratings for user ${userId}:`, error);\n    \n    // Returnăm un obiect gol în loc să aruncăm eroarea\n    // pentru a permite componentei să afișeze un mesaj de eroare\n    return { ratings: [], averageRating: 0, reviewCount: 0 };\n  }\n};\n\n/**\n * Fetch services for a specific user\n * @param {string} userId - User ID\n * @returns {Promise<Array>} Array of services\n */\nconst getUserServices = async (userId) => {\n  try {\n    const response = await fetch(`${API_ENDPOINT}/user/${userId}`);\n    return await response.json();\n  } catch (error) {\n    console.error('Error fetching user services:', error);\n    throw error;\n  }\n};\n\n// Single export statement at the end of the file\nexport {\n  getServices,\n  getServiceById,\n  createService,\n  updateService,\n  deleteService,\n  getUserServices,\n  submitUserRating,\n  fetchUserRatings\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
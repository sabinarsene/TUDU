{"ast":null,"code":"import axios from 'axios';\n\n// Service API for handling service-related API calls\n// Folosim window.location.hostname pentru a obține adresa IP sau hostname-ul curent\nexport const API_URL = `http://${window.location.hostname}:5000/api`;\n\n// Log the API URL for debugging\nconsole.log('API URL:', API_URL);\n\n/**\r\n * Fetch all services from the API\r\n * @returns {Promise<Array>} Array of services\r\n */\nexport const fetchServices = async () => {\n  try {\n    const fullUrl = `${API_URL}/services`;\n    console.log('Fetching services from:', fullUrl);\n    const response = await fetch(fullUrl);\n    if (!response.ok) {\n      throw new Error(`Error fetching services: ${response.statusText}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Error fetching services:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Fetch a single service by ID\r\n * @param {number} id - Service ID\r\n * @returns {Promise<Object>} Service object\r\n */\nexport const fetchServiceById = async id => {\n  try {\n    const fullUrl = `${API_URL}/services/${id}`;\n    console.log('Fetching service by ID from:', fullUrl);\n    const response = await fetch(fullUrl);\n    if (!response.ok) {\n      throw new Error(`Error fetching service: ${response.statusText}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error(`Error fetching service with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\r\n * Create a new service\r\n * @param {FormData} serviceData - Service data as FormData (for file uploads)\r\n * @param {string} token - Authentication token\r\n * @returns {Promise<Object>} Created service\r\n */\nexport const createService = async (serviceData, token) => {\n  try {\n    const fullUrl = `${API_URL}/services`;\n    console.log('Creating service at:', fullUrl);\n    const response = await fetch(fullUrl, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${token}`\n        // Note: Don't set Content-Type when sending FormData\n        // The browser will set it automatically with the correct boundary\n      },\n      body: serviceData\n    });\n\n    // Încercăm să obținem răspunsul JSON\n    let responseData;\n    try {\n      responseData = await response.json();\n    } catch (jsonError) {\n      console.error('Error parsing response:', jsonError);\n      // Dacă nu putem parsa JSON, folosim textul răspunsului\n      const textResponse = await response.text();\n      if (!response.ok) {\n        throw new Error(textResponse || `Error creating service: ${response.statusText}`);\n      }\n      throw new Error('Răspunsul serverului nu este în format valid');\n    }\n    if (!response.ok) {\n      console.error('Server returned error:', responseData);\n\n      // Verificăm dacă eroarea este legată de Supabase storage\n      if (responseData.error && responseData.error.includes('storage')) {\n        throw new Error('Eroare la încărcarea imaginii. Serviciul Supabase Storage nu este disponibil.');\n      }\n      throw new Error(responseData.message || `Error creating service: ${response.statusText}`);\n    }\n    return responseData;\n  } catch (error) {\n    console.error('Error creating service:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Update an existing service\r\n * @param {number} id - Service ID\r\n * @param {Object|FormData} serviceData - Updated service data\r\n * @param {string} token - Authentication token\r\n * @returns {Promise<Object>} Updated service\r\n */\nexport const updateService = async (id, serviceData, token) => {\n  try {\n    // Check if serviceData is FormData\n    const isFormData = serviceData instanceof FormData;\n    const headers = {\n      'Authorization': `Bearer ${token}`\n    };\n\n    // Only set Content-Type for JSON data, not for FormData\n    if (!isFormData) {\n      headers['Content-Type'] = 'application/json';\n    }\n    const response = await fetch(`${API_URL}/services/${id}`, {\n      method: 'PUT',\n      headers: headers,\n      body: isFormData ? serviceData : JSON.stringify(serviceData)\n    });\n    if (!response.ok) {\n      throw new Error(`Error updating service: ${response.statusText}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error(`Error updating service with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\r\n * Delete a service\r\n * @param {number} id - Service ID\r\n * @param {string} token - Authentication token\r\n * @returns {Promise<Object>} Response message\r\n */\nexport const deleteService = async (id, token) => {\n  try {\n    const response = await fetch(`${API_URL}/services/${id}`, {\n      method: 'DELETE',\n      headers: {\n        'Authorization': `Bearer ${token}`\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`Error deleting service: ${response.statusText}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error(`Error deleting service with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\r\n * Submit a rating for a user\r\n * @param {string} userId - ID of the user being rated\r\n * @param {number} rating - Rating value (1-5)\r\n * @param {string} comment - Optional comment with the rating\r\n * @param {string} token - Authentication token\r\n * @returns {Promise<Object>} Response with the updated rating information\r\n */\nexport const submitUserRating = async (userId, rating, comment, token) => {\n  try {\n    console.log(`Submitting rating ${rating} for user ${userId} with comment: ${comment}`);\n    const apiUrl = `${API_URL}/users/${userId}/ratings`;\n    console.log('API URL:', apiUrl);\n\n    // Verificăm dacă avem token\n    if (!token) {\n      console.error('No token provided');\n      throw new Error('Nu ești autentificat');\n    }\n    console.log('Using token:', token);\n\n    // Configurăm axios cu timeout și headers\n    const axiosInstance = axios.create({\n      timeout: 10000,\n      // 10 secunde timeout\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`,\n        'x-auth-token': token // pentru compatibilitate\n      }\n    });\n    console.log('Request headers:', axiosInstance.defaults.headers);\n    const response = await axiosInstance.post(apiUrl, {\n      rating,\n      comment\n    });\n    console.log('Response status:', response.status);\n    console.log('Response headers:', response.headers);\n    console.log('Rating submitted successfully:', response.data);\n    return response.data;\n  } catch (error) {\n    console.error(`Error submitting rating for user ${userId}:`, error);\n    if (error.response) {\n      // Serverul a răspuns cu un status code în afara intervalului 2xx\n      console.error('Server error response:', error.response.data);\n      const errorMessage = error.response.data.message || `Error submitting rating: ${error.response.statusText}`;\n      throw new Error(errorMessage);\n    } else if (error.request) {\n      // Cererea a fost făcută dar nu s-a primit răspuns\n      console.error('No response received:', error.request);\n      throw new Error('Nu s-a putut contacta serverul. Verificați conexiunea la internet.');\n    } else {\n      // Ceva s-a întâmplat la configurarea cererii\n      console.error('Request configuration error:', error.message);\n      throw error;\n    }\n  }\n};\n\n/**\r\n * Fetch ratings for a user\r\n * @param {string} userId - ID of the user\r\n * @returns {Promise<Object>} Object with ratings array\r\n */\nexport const fetchUserRatings = async userId => {\n  try {\n    console.log(`Fetching ratings for user ${userId}`);\n    const apiUrl = `${API_URL}/users/${userId}/ratings`;\n    console.log('API URL:', apiUrl);\n\n    // Adăugăm un timeout pentru a evita blocarea UI-ului\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 secunde timeout\n\n    try {\n      const response = await fetch(apiUrl, {\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n      console.log('Response status:', response.status);\n      console.log('Response headers:', Object.fromEntries([...response.headers]));\n      if (!response.ok) {\n        if (response.status === 404) {\n          console.log(`Endpoint /users/${userId}/ratings nu este disponibil sau utilizatorul nu are evaluări`);\n          return {\n            ratings: [],\n            averageRating: 0,\n            reviewCount: 0\n          };\n        }\n\n        // Încercăm să obținem detalii despre eroare\n        try {\n          const errorData = await response.json();\n          console.error('Error response data:', errorData);\n          throw new Error(errorData.message || `Error fetching ratings: ${response.statusText}`);\n        } catch (jsonError) {\n          console.error('Could not parse error response:', jsonError);\n          throw new Error(`Error fetching ratings: ${response.statusText}`);\n        }\n      }\n      const data = await response.json();\n      console.log('Ratings fetched successfully:', data);\n      return data;\n    } catch (fetchError) {\n      clearTimeout(timeoutId);\n      if (fetchError.name === 'AbortError') {\n        console.error('Request timed out after 10 seconds');\n        throw new Error('Cererea a expirat. Serverul nu a răspuns în timp util.');\n      }\n      throw fetchError;\n    }\n  } catch (error) {\n    console.error(`Error fetching ratings for user ${userId}:`, error);\n\n    // Returnăm un obiect gol în loc să aruncăm eroarea\n    // pentru a permite componentei să afișeze un mesaj de eroare\n    return {\n      ratings: [],\n      averageRating: 0,\n      reviewCount: 0\n    };\n  }\n};\n\n/**\r\n * Fetch services for a specific user\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} Array of services\r\n */\nexport const fetchUserServices = async userId => {\n  try {\n    // Încercăm să facem apelul API\n    try {\n      const response = await fetch(`${API_URL}/services/user/${userId}`);\n      if (!response.ok) {\n        // Dacă primim 404, returnăm date mock\n        if (response.status === 404) {\n          console.log(`Endpoint /services/user/${userId} nu este disponibil, returnăm date mock`);\n          return getMockUserServices(userId);\n        }\n        throw new Error(`Error fetching user services: ${response.statusText}`);\n      }\n      return await response.json();\n    } catch (error) {\n      // Dacă primim orice eroare, returnăm date mock\n      console.error(`Error fetching services for user ${userId}:`, error);\n      return getMockUserServices(userId);\n    }\n  } catch (error) {\n    console.error(`Error fetching services for user ${userId}:`, error);\n    throw error;\n  }\n};\n\n/**\r\n * Generează date mock pentru serviciile unui utilizator\r\n * @param {string} userId - ID-ul utilizatorului\r\n * @returns {Array} Array de servicii mock\r\n */\nconst getMockUserServices = userId => {\n  // Generăm un număr aleatoriu de servicii între 1 și 5\n  const numServices = Math.floor(Math.random() * 5) + 1;\n  const services = [];\n  const categories = ['Instalații', 'Curățenie', 'Transport', 'Reparații', 'IT', 'Design', 'Educație'];\n  const locations = ['București', 'Cluj-Napoca', 'Timișoara', 'Iași', 'Brașov', 'Constanța'];\n\n  // Generăm servicii aleatorii\n  for (let i = 0; i < numServices; i++) {\n    const service = {\n      id: `mock-service-${i}`,\n      title: `Serviciu Mock ${i + 1}`,\n      description: `Aceasta este o descriere mock pentru serviciul ${i + 1} al utilizatorului cu ID-ul ${userId}.`,\n      category: categories[Math.floor(Math.random() * categories.length)],\n      location: locations[Math.floor(Math.random() * locations.length)],\n      price: Math.floor(Math.random() * 500) + 50,\n      currency: 'RON',\n      rating: (Math.random() * 4 + 1).toFixed(1),\n      review_count: Math.floor(Math.random() * 50),\n      image: null,\n      provider: {\n        id: userId,\n        name: `Utilizator ${userId}`,\n        image: null\n      }\n    };\n    services.push(service);\n  }\n  return services;\n};","map":{"version":3,"names":["axios","API_URL","window","location","hostname","console","log","fetchServices","fullUrl","response","fetch","ok","Error","statusText","json","error","fetchServiceById","id","createService","serviceData","token","method","headers","body","responseData","jsonError","textResponse","text","includes","message","updateService","isFormData","FormData","JSON","stringify","deleteService","submitUserRating","userId","rating","comment","apiUrl","axiosInstance","create","timeout","defaults","post","status","data","errorMessage","request","fetchUserRatings","controller","AbortController","timeoutId","setTimeout","abort","signal","clearTimeout","Object","fromEntries","ratings","averageRating","reviewCount","errorData","fetchError","name","fetchUserServices","getMockUserServices","numServices","Math","floor","random","services","categories","locations","i","service","title","description","category","length","price","currency","toFixed","review_count","image","provider","push"],"sources":["C:/Users/sabin.arsene/Desktop/Tudu-app/TUDU/frontend/src/services/serviceApi.js"],"sourcesContent":["import axios from 'axios';\r\n\r\n// Service API for handling service-related API calls\r\n// Folosim window.location.hostname pentru a obține adresa IP sau hostname-ul curent\r\nexport const API_URL = `http://${window.location.hostname}:5000/api`;\r\n\r\n// Log the API URL for debugging\r\nconsole.log('API URL:', API_URL);\r\n\r\n/**\r\n * Fetch all services from the API\r\n * @returns {Promise<Array>} Array of services\r\n */\r\nexport const fetchServices = async () => {\r\n  try {\r\n    const fullUrl = `${API_URL}/services`;\r\n    console.log('Fetching services from:', fullUrl);\r\n    \r\n    const response = await fetch(fullUrl);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Error fetching services: ${response.statusText}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error('Error fetching services:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Fetch a single service by ID\r\n * @param {number} id - Service ID\r\n * @returns {Promise<Object>} Service object\r\n */\r\nexport const fetchServiceById = async (id) => {\r\n  try {\r\n    const fullUrl = `${API_URL}/services/${id}`;\r\n    console.log('Fetching service by ID from:', fullUrl);\r\n    \r\n    const response = await fetch(fullUrl);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Error fetching service: ${response.statusText}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error(`Error fetching service with ID ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Create a new service\r\n * @param {FormData} serviceData - Service data as FormData (for file uploads)\r\n * @param {string} token - Authentication token\r\n * @returns {Promise<Object>} Created service\r\n */\r\nexport const createService = async (serviceData, token) => {\r\n  try {\r\n    const fullUrl = `${API_URL}/services`;\r\n    console.log('Creating service at:', fullUrl);\r\n    \r\n    const response = await fetch(fullUrl, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Authorization': `Bearer ${token}`\r\n        // Note: Don't set Content-Type when sending FormData\r\n        // The browser will set it automatically with the correct boundary\r\n      },\r\n      body: serviceData\r\n    });\r\n    \r\n    // Încercăm să obținem răspunsul JSON\r\n    let responseData;\r\n    try {\r\n      responseData = await response.json();\r\n    } catch (jsonError) {\r\n      console.error('Error parsing response:', jsonError);\r\n      // Dacă nu putem parsa JSON, folosim textul răspunsului\r\n      const textResponse = await response.text();\r\n      if (!response.ok) {\r\n        throw new Error(textResponse || `Error creating service: ${response.statusText}`);\r\n      }\r\n      throw new Error('Răspunsul serverului nu este în format valid');\r\n    }\r\n    \r\n    if (!response.ok) {\r\n      console.error('Server returned error:', responseData);\r\n      \r\n      // Verificăm dacă eroarea este legată de Supabase storage\r\n      if (responseData.error && responseData.error.includes('storage')) {\r\n        throw new Error('Eroare la încărcarea imaginii. Serviciul Supabase Storage nu este disponibil.');\r\n      }\r\n      \r\n      throw new Error(responseData.message || `Error creating service: ${response.statusText}`);\r\n    }\r\n    \r\n    return responseData;\r\n  } catch (error) {\r\n    console.error('Error creating service:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Update an existing service\r\n * @param {number} id - Service ID\r\n * @param {Object|FormData} serviceData - Updated service data\r\n * @param {string} token - Authentication token\r\n * @returns {Promise<Object>} Updated service\r\n */\r\nexport const updateService = async (id, serviceData, token) => {\r\n  try {\r\n    // Check if serviceData is FormData\r\n    const isFormData = serviceData instanceof FormData;\r\n    \r\n    const headers = {\r\n      'Authorization': `Bearer ${token}`\r\n    };\r\n    \r\n    // Only set Content-Type for JSON data, not for FormData\r\n    if (!isFormData) {\r\n      headers['Content-Type'] = 'application/json';\r\n    }\r\n    \r\n    const response = await fetch(`${API_URL}/services/${id}`, {\r\n      method: 'PUT',\r\n      headers: headers,\r\n      body: isFormData ? serviceData : JSON.stringify(serviceData)\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Error updating service: ${response.statusText}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error(`Error updating service with ID ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Delete a service\r\n * @param {number} id - Service ID\r\n * @param {string} token - Authentication token\r\n * @returns {Promise<Object>} Response message\r\n */\r\nexport const deleteService = async (id, token) => {\r\n  try {\r\n    const response = await fetch(`${API_URL}/services/${id}`, {\r\n      method: 'DELETE',\r\n      headers: {\r\n        'Authorization': `Bearer ${token}`\r\n      }\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Error deleting service: ${response.statusText}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error(`Error deleting service with ID ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Submit a rating for a user\r\n * @param {string} userId - ID of the user being rated\r\n * @param {number} rating - Rating value (1-5)\r\n * @param {string} comment - Optional comment with the rating\r\n * @param {string} token - Authentication token\r\n * @returns {Promise<Object>} Response with the updated rating information\r\n */\r\nexport const submitUserRating = async (userId, rating, comment, token) => {\r\n  try {\r\n    console.log(`Submitting rating ${rating} for user ${userId} with comment: ${comment}`);\r\n    const apiUrl = `${API_URL}/users/${userId}/ratings`;\r\n    console.log('API URL:', apiUrl);\r\n    \r\n    // Verificăm dacă avem token\r\n    if (!token) {\r\n      console.error('No token provided');\r\n      throw new Error('Nu ești autentificat');\r\n    }\r\n    \r\n    console.log('Using token:', token);\r\n    \r\n    // Configurăm axios cu timeout și headers\r\n    const axiosInstance = axios.create({\r\n      timeout: 10000, // 10 secunde timeout\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Authorization': `Bearer ${token}`,\r\n        'x-auth-token': token // pentru compatibilitate\r\n      }\r\n    });\r\n    \r\n    console.log('Request headers:', axiosInstance.defaults.headers);\r\n    \r\n    const response = await axiosInstance.post(apiUrl, {\r\n      rating,\r\n      comment\r\n    });\r\n    \r\n    console.log('Response status:', response.status);\r\n    console.log('Response headers:', response.headers);\r\n    console.log('Rating submitted successfully:', response.data);\r\n    \r\n    return response.data;\r\n  } catch (error) {\r\n    console.error(`Error submitting rating for user ${userId}:`, error);\r\n    \r\n    if (error.response) {\r\n      // Serverul a răspuns cu un status code în afara intervalului 2xx\r\n      console.error('Server error response:', error.response.data);\r\n      const errorMessage = error.response.data.message || `Error submitting rating: ${error.response.statusText}`;\r\n      throw new Error(errorMessage);\r\n    } else if (error.request) {\r\n      // Cererea a fost făcută dar nu s-a primit răspuns\r\n      console.error('No response received:', error.request);\r\n      throw new Error('Nu s-a putut contacta serverul. Verificați conexiunea la internet.');\r\n    } else {\r\n      // Ceva s-a întâmplat la configurarea cererii\r\n      console.error('Request configuration error:', error.message);\r\n      throw error;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Fetch ratings for a user\r\n * @param {string} userId - ID of the user\r\n * @returns {Promise<Object>} Object with ratings array\r\n */\r\nexport const fetchUserRatings = async (userId) => {\r\n  try {\r\n    console.log(`Fetching ratings for user ${userId}`);\r\n    const apiUrl = `${API_URL}/users/${userId}/ratings`;\r\n    console.log('API URL:', apiUrl);\r\n    \r\n    // Adăugăm un timeout pentru a evita blocarea UI-ului\r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 secunde timeout\r\n    \r\n    try {\r\n      const response = await fetch(apiUrl, {\r\n        signal: controller.signal\r\n      });\r\n      \r\n      clearTimeout(timeoutId);\r\n      \r\n      console.log('Response status:', response.status);\r\n      console.log('Response headers:', Object.fromEntries([...response.headers]));\r\n      \r\n      if (!response.ok) {\r\n        if (response.status === 404) {\r\n          console.log(`Endpoint /users/${userId}/ratings nu este disponibil sau utilizatorul nu are evaluări`);\r\n          return { ratings: [], averageRating: 0, reviewCount: 0 };\r\n        }\r\n        \r\n        // Încercăm să obținem detalii despre eroare\r\n        try {\r\n          const errorData = await response.json();\r\n          console.error('Error response data:', errorData);\r\n          throw new Error(errorData.message || `Error fetching ratings: ${response.statusText}`);\r\n        } catch (jsonError) {\r\n          console.error('Could not parse error response:', jsonError);\r\n          throw new Error(`Error fetching ratings: ${response.statusText}`);\r\n        }\r\n      }\r\n      \r\n      const data = await response.json();\r\n      console.log('Ratings fetched successfully:', data);\r\n      return data;\r\n    } catch (fetchError) {\r\n      clearTimeout(timeoutId);\r\n      \r\n      if (fetchError.name === 'AbortError') {\r\n        console.error('Request timed out after 10 seconds');\r\n        throw new Error('Cererea a expirat. Serverul nu a răspuns în timp util.');\r\n      }\r\n      \r\n      throw fetchError;\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fetching ratings for user ${userId}:`, error);\r\n    \r\n    // Returnăm un obiect gol în loc să aruncăm eroarea\r\n    // pentru a permite componentei să afișeze un mesaj de eroare\r\n    return { ratings: [], averageRating: 0, reviewCount: 0 };\r\n  }\r\n};\r\n\r\n/**\r\n * Fetch services for a specific user\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} Array of services\r\n */\r\nexport const fetchUserServices = async (userId) => {\r\n  try {\r\n    // Încercăm să facem apelul API\r\n    try {\r\n      const response = await fetch(`${API_URL}/services/user/${userId}`);\r\n      \r\n      if (!response.ok) {\r\n        // Dacă primim 404, returnăm date mock\r\n        if (response.status === 404) {\r\n          console.log(`Endpoint /services/user/${userId} nu este disponibil, returnăm date mock`);\r\n          return getMockUserServices(userId);\r\n        }\r\n        throw new Error(`Error fetching user services: ${response.statusText}`);\r\n      }\r\n      \r\n      return await response.json();\r\n    } catch (error) {\r\n      // Dacă primim orice eroare, returnăm date mock\r\n      console.error(`Error fetching services for user ${userId}:`, error);\r\n      return getMockUserServices(userId);\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fetching services for user ${userId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Generează date mock pentru serviciile unui utilizator\r\n * @param {string} userId - ID-ul utilizatorului\r\n * @returns {Array} Array de servicii mock\r\n */\r\nconst getMockUserServices = (userId) => {\r\n  // Generăm un număr aleatoriu de servicii între 1 și 5\r\n  const numServices = Math.floor(Math.random() * 5) + 1;\r\n  const services = [];\r\n  \r\n  const categories = ['Instalații', 'Curățenie', 'Transport', 'Reparații', 'IT', 'Design', 'Educație'];\r\n  const locations = ['București', 'Cluj-Napoca', 'Timișoara', 'Iași', 'Brașov', 'Constanța'];\r\n  \r\n  // Generăm servicii aleatorii\r\n  for (let i = 0; i < numServices; i++) {\r\n    const service = {\r\n      id: `mock-service-${i}`,\r\n      title: `Serviciu Mock ${i + 1}`,\r\n      description: `Aceasta este o descriere mock pentru serviciul ${i + 1} al utilizatorului cu ID-ul ${userId}.`,\r\n      category: categories[Math.floor(Math.random() * categories.length)],\r\n      location: locations[Math.floor(Math.random() * locations.length)],\r\n      price: Math.floor(Math.random() * 500) + 50,\r\n      currency: 'RON',\r\n      rating: (Math.random() * 4 + 1).toFixed(1),\r\n      review_count: Math.floor(Math.random() * 50),\r\n      image: null,\r\n      provider: {\r\n        id: userId,\r\n        name: `Utilizator ${userId}`,\r\n        image: null\r\n      }\r\n    };\r\n    services.push(service);\r\n  }\r\n  \r\n  return services;\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
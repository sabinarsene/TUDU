{"ast":null,"code":"import { NEW_FOCUS, newFocus } from './solver';\nimport { getFocusableNodes } from './utils/DOMutils';\nimport { getAllAffectedNodes } from './utils/all-affected';\nimport { asArray, getFirst } from './utils/array';\nimport { pickAutofocus } from './utils/auto-focus';\nimport { getActiveElement } from './utils/getActiveElement';\nimport { isDefined, isNotAGuard } from './utils/is';\nimport { allParentAutofocusables, getTopCommonParent } from './utils/parenting';\nvar reorderNodes = function (srcNodes, dstNodes) {\n  var remap = new Map();\n  // no Set(dstNodes) for IE11 :(\n  dstNodes.forEach(function (entity) {\n    return remap.set(entity.node, entity);\n  });\n  // remap to dstNodes\n  return srcNodes.map(function (node) {\n    return remap.get(node);\n  }).filter(isDefined);\n};\n/**\r\n * contains the main logic of the `focus-lock` package.\r\n *\r\n * ! you probably dont need this function !\r\n *\r\n * given top node(s) and the last active element returns the element to be focused next\r\n * @returns element which should be focused to move focus inside\r\n * @param topNode\r\n * @param lastNode\r\n */\nexport var focusSolver = function (topNode, lastNode) {\n  var activeElement = getActiveElement(asArray(topNode).length > 0 ? document : getFirst(topNode).ownerDocument);\n  var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);\n  var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);\n  var visibilityCache = new Map();\n  var anyFocusable = getFocusableNodes(entries, visibilityCache);\n  var innerElements = anyFocusable.filter(function (_a) {\n    var node = _a.node;\n    return isNotAGuard(node);\n  });\n  if (!innerElements[0]) {\n    return undefined;\n  }\n  var outerNodes = getFocusableNodes([commonParent], visibilityCache).map(function (_a) {\n    var node = _a.node;\n    return node;\n  });\n  var orderedInnerElements = reorderNodes(outerNodes, innerElements);\n  // collect inner focusable and separately tabbables\n  var innerFocusables = orderedInnerElements.map(function (_a) {\n    var node = _a.node;\n    return node;\n  });\n  var innerTabbable = orderedInnerElements.filter(function (_a) {\n    var tabIndex = _a.tabIndex;\n    return tabIndex >= 0;\n  }).map(function (_a) {\n    var node = _a.node;\n    return node;\n  });\n  var newId = newFocus(innerFocusables, innerTabbable, outerNodes, activeElement, lastNode);\n  if (newId === NEW_FOCUS) {\n    var focusNode =\n    // first try only tabbable, and the fallback to all focusable, as long as at least one element should be picked for focus\n    pickAutofocus(anyFocusable, innerTabbable, allParentAutofocusables(entries, visibilityCache)) || pickAutofocus(anyFocusable, innerFocusables, allParentAutofocusables(entries, visibilityCache));\n    if (focusNode) {\n      return {\n        node: focusNode\n      };\n    } else {\n      console.warn('focus-lock: cannot find any node to move focus into');\n      return undefined;\n    }\n  }\n  if (newId === undefined) {\n    return newId;\n  }\n  return orderedInnerElements[newId];\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
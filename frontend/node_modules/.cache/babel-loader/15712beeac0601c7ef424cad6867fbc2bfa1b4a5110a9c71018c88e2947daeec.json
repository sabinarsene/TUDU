{"ast":null,"code":"import { createMachine, subscribe, guards, ref, isMachine } from '@zag-js/core';\nimport { createScope, raf, queryAll, dataAttr, contains, addDomEvent, MAX_Z_INDEX } from '@zag-js/dom-query';\nimport { compact, warn, runIfFn, uuid } from '@zag-js/utils';\nimport { createAnatomy } from '@zag-js/anatomy';\nimport { trackDismissableBranch } from '@zag-js/dismissable';\n\n// src/toast-group.connect.ts\nvar anatomy = createAnatomy(\"toast\").parts(\"group\", \"root\", \"title\", \"description\", \"actionTrigger\", \"closeTrigger\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRegionId: placement => `toast-group:${placement}`,\n  getRegionEl: (ctx, placement) => dom.getById(ctx, `toast-group:${placement}`),\n  getRootId: ctx => `toast:${ctx.id}`,\n  getRootEl: ctx => dom.getById(ctx, dom.getRootId(ctx)),\n  getTitleId: ctx => `toast:${ctx.id}:title`,\n  getDescriptionId: ctx => `toast:${ctx.id}:description`,\n  getCloseTriggerId: ctx => `toast${ctx.id}:close`\n});\nfunction getToastsByPlacement(toasts, placement) {\n  return toasts.filter(toast => toast.state.context.placement === placement);\n}\nvar defaultTimeouts = {\n  info: 5e3,\n  error: 5e3,\n  success: 2e3,\n  loading: Infinity,\n  DEFAULT: 5e3\n};\nfunction getToastDuration(duration, type) {\n  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;\n}\nfunction getGroupPlacementStyle(ctx, placement) {\n  const offset = ctx.offsets;\n  const computedOffset = typeof offset === \"string\" ? {\n    left: offset,\n    right: offset,\n    bottom: offset,\n    top: offset\n  } : offset;\n  const rtl = ctx.dir === \"rtl\";\n  const computedPlacement = placement.replace(\"-start\", rtl ? \"-right\" : \"-left\").replace(\"-end\", rtl ? \"-left\" : \"-right\");\n  const isRighty = computedPlacement.includes(\"right\");\n  const isLefty = computedPlacement.includes(\"left\");\n  const styles = {\n    position: \"fixed\",\n    pointerEvents: ctx.count > 0 ? void 0 : \"none\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    \"--gap\": `${ctx.gap}px`,\n    \"--first-height\": `${ctx.heights[0]?.height || 0}px`,\n    zIndex: MAX_Z_INDEX\n  };\n  let alignItems = \"center\";\n  if (isRighty) alignItems = \"flex-end\";\n  if (isLefty) alignItems = \"flex-start\";\n  styles.alignItems = alignItems;\n  if (computedPlacement.includes(\"top\")) {\n    const offset2 = computedOffset.top;\n    styles.top = `max(env(safe-area-inset-top, 0px), ${offset2})`;\n  }\n  if (computedPlacement.includes(\"bottom\")) {\n    const offset2 = computedOffset.bottom;\n    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset2})`;\n  }\n  if (!computedPlacement.includes(\"left\")) {\n    const offset2 = computedOffset.right;\n    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset2})`;\n  }\n  if (!computedPlacement.includes(\"right\")) {\n    const offset2 = computedOffset.left;\n    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset2})`;\n  }\n  return styles;\n}\nfunction getPlacementStyle(ctx, visible) {\n  const [side] = ctx.placement.split(\"-\");\n  const sibling = !ctx.frontmost;\n  const overlap = !ctx.stacked;\n  const styles = {\n    position: \"absolute\",\n    pointerEvents: \"auto\",\n    \"--opacity\": \"0\",\n    \"--remove-delay\": `${ctx.removeDelay}ms`,\n    \"--duration\": `${ctx.type === \"loading\" ? Number.MAX_SAFE_INTEGER : ctx.duration}ms`,\n    \"--initial-height\": `${ctx.height}px`,\n    \"--offset\": `${ctx.offset}px`,\n    \"--index\": ctx.index,\n    \"--z-index\": ctx.zIndex,\n    \"--lift-amount\": \"calc(var(--lift) * var(--gap))\",\n    \"--y\": \"100%\",\n    \"--x\": \"0\"\n  };\n  const assign = overrides => Object.assign(styles, overrides);\n  if (side === \"top\") {\n    assign({\n      top: \"0\",\n      \"--sign\": \"-1\",\n      \"--y\": \"-100%\",\n      \"--lift\": \"1\"\n    });\n  } else if (side === \"bottom\") {\n    assign({\n      bottom: \"0\",\n      \"--sign\": \"1\",\n      \"--y\": \"100%\",\n      \"--lift\": \"-1\"\n    });\n  }\n  if (ctx.mounted) {\n    assign({\n      \"--y\": \"0\",\n      \"--opacity\": \"1\"\n    });\n    if (ctx.stacked) {\n      assign({\n        \"--y\": \"calc(var(--lift) * var(--offset))\",\n        \"--height\": \"var(--initial-height)\"\n      });\n    }\n  }\n  if (!visible) {\n    assign({\n      \"--opacity\": \"0\",\n      pointerEvents: \"none\"\n    });\n  }\n  if (sibling && overlap) {\n    assign({\n      \"--base-scale\": \"var(--index) * 0.05 + 1\",\n      \"--y\": \"calc(var(--lift-amount) * var(--index))\",\n      \"--scale\": \"calc(-1 * var(--base-scale))\",\n      \"--height\": \"var(--first-height)\"\n    });\n    if (!visible) {\n      assign({\n        \"--y\": \"calc(var(--sign) * 40%)\"\n      });\n    }\n  }\n  if (sibling && ctx.stacked && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * var(--offset) + var(--lift) * -100%)\"\n    });\n  }\n  if (ctx.frontmost && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * -100%)\"\n    });\n  }\n  return styles;\n}\nfunction getGhostBeforeStyle(ctx, visible) {\n  const styles = {\n    position: \"absolute\",\n    inset: \"0\",\n    scale: \"1 2\",\n    pointerEvents: visible ? \"none\" : \"auto\"\n  };\n  const assign = overrides => Object.assign(styles, overrides);\n  if (ctx.frontmost && !visible) {\n    assign({\n      height: \"calc(var(--initial-height) + 80%)\"\n    });\n  }\n  return styles;\n}\nfunction getGhostAfterStyle(_ctx, _visible) {\n  return {\n    position: \"absolute\",\n    left: \"0\",\n    height: \"calc(var(--gap) + 2px)\",\n    bottom: \"100%\",\n    width: \"100%\"\n  };\n}\n\n// src/toast-group.connect.ts\nfunction groupConnect(serviceOrState, send, normalize) {\n  function getState() {\n    const result = isMachine(serviceOrState) ? serviceOrState.getState() : serviceOrState;\n    return result;\n  }\n  function getToastsByPlacementImpl(placement) {\n    return getToastsByPlacement(getState().context.toasts, placement);\n  }\n  function isVisible(id) {\n    const toasts = getState().context.toasts;\n    if (!toasts.length) return false;\n    return !!toasts.find(toast => toast.id == id);\n  }\n  function create(options) {\n    const uid = `toast:${uuid()}`;\n    const id = options.id ? options.id : uid;\n    if (isVisible(id)) return id;\n    send({\n      type: \"ADD_TOAST\",\n      toast: {\n        ...options,\n        id\n      }\n    });\n    return id;\n  }\n  function update(id, options) {\n    if (!isVisible(id)) return id;\n    send({\n      type: \"UPDATE_TOAST\",\n      id,\n      toast: options\n    });\n    return id;\n  }\n  function upsert(options) {\n    const {\n      id\n    } = options;\n    const visible = id ? isVisible(id) : false;\n    if (visible && id != null) {\n      return update(id, options);\n    } else {\n      return create(options);\n    }\n  }\n  function dismiss(id) {\n    if (id == null) {\n      send(\"DISMISS_ALL\");\n    } else if (isVisible(id)) {\n      send({\n        type: \"DISMISS_TOAST\",\n        id\n      });\n    }\n  }\n  return {\n    getCount() {\n      return getState().context.count;\n    },\n    getPlacements() {\n      const toasts = getState().context.toasts;\n      const placements = toasts.map(toast => toast.state.context.placement);\n      return Array.from(new Set(placements));\n    },\n    getToastsByPlacement: getToastsByPlacementImpl,\n    isVisible,\n    create,\n    update,\n    upsert,\n    dismiss,\n    remove(id) {\n      if (id == null) {\n        send(\"REMOVE_ALL\");\n      } else if (isVisible(id)) {\n        send({\n          type: \"REMOVE_TOAST\",\n          id\n        });\n      }\n    },\n    dismissByPlacement(placement) {\n      const toasts = getToastsByPlacementImpl(placement);\n      toasts.forEach(toast => dismiss(toast.id));\n    },\n    loading(options) {\n      return upsert({\n        ...options,\n        type: \"loading\"\n      });\n    },\n    success(options) {\n      return upsert({\n        ...options,\n        type: \"success\"\n      });\n    },\n    error(options) {\n      return upsert({\n        ...options,\n        type: \"error\"\n      });\n    },\n    promise(promise, options, shared = {}) {\n      const id = upsert({\n        ...shared,\n        ...options.loading,\n        type: \"loading\"\n      });\n      runIfFn(promise).then(response => {\n        const successOptions = runIfFn(options.success, response);\n        upsert({\n          ...shared,\n          ...successOptions,\n          id,\n          type: \"success\"\n        });\n      }).catch(error => {\n        const errorOptions = runIfFn(options.error, error);\n        upsert({\n          ...shared,\n          ...errorOptions,\n          id,\n          type: \"error\"\n        });\n      }).finally(() => {\n        options.finally?.();\n      });\n      return id;\n    },\n    pause(id) {\n      if (id == null) {\n        send(\"PAUSE_ALL\");\n      } else if (isVisible(id)) {\n        send({\n          type: \"PAUSE_TOAST\",\n          id\n        });\n      }\n    },\n    resume(id) {\n      if (id == null) {\n        send(\"RESUME_ALL\");\n      } else if (isVisible(id)) {\n        send({\n          type: \"RESUME_TOAST\",\n          id\n        });\n      }\n    },\n    getGroupProps(options) {\n      const {\n        placement,\n        label = \"Notifications\"\n      } = options;\n      const state = getState();\n      const hotkeyLabel = state.context.hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\");\n      const [side, align = \"center\"] = placement.split(\"-\");\n      return normalize.element({\n        ...parts.group.attrs,\n        dir: state.context.dir,\n        tabIndex: -1,\n        \"aria-label\": `${placement} ${label} ${hotkeyLabel}`,\n        id: dom.getRegionId(placement),\n        \"data-placement\": placement,\n        \"data-side\": side,\n        \"data-align\": align,\n        \"aria-live\": \"polite\",\n        role: \"region\",\n        style: getGroupPlacementStyle(state.context, placement),\n        onMouseMove() {\n          send({\n            type: \"REGION.POINTER_ENTER\",\n            placement\n          });\n        },\n        onMouseLeave() {\n          send({\n            type: \"REGION.POINTER_LEAVE\",\n            placement\n          });\n        },\n        onFocus(event) {\n          send({\n            type: \"REGION.FOCUS\",\n            target: event.relatedTarget\n          });\n        },\n        onBlur(event) {\n          if (state.context.isFocusWithin && !contains(event.currentTarget, event.relatedTarget)) {\n            send({\n              type: \"REGION.BLUR\"\n            });\n          }\n        }\n      });\n    },\n    subscribe(fn) {\n      const state = getState();\n      return subscribe(state.context.toasts, () => {\n        const toasts = getToastsByPlacementImpl(state.context.placement);\n        const contexts = toasts.map(toast => toast.getState().context);\n        fn(contexts);\n      });\n    }\n  };\n}\nvar {\n  not,\n  and,\n  or\n} = guards;\nfunction createToastMachine(options) {\n  const {\n    type = \"info\",\n    duration,\n    id = \"1\",\n    placement = \"bottom\",\n    removeDelay = 200,\n    ...restProps\n  } = options;\n  const ctx = compact(restProps);\n  const computedDuration = getToastDuration(duration, type);\n  return createMachine({\n    id,\n    context: {\n      id,\n      type,\n      remaining: computedDuration,\n      duration: computedDuration,\n      removeDelay,\n      createdAt: Date.now(),\n      placement,\n      ...ctx,\n      height: 0,\n      offset: 0,\n      frontmost: false,\n      mounted: false,\n      index: -1,\n      zIndex: 0\n    },\n    initial: type === \"loading\" ? \"visible:persist\" : \"visible\",\n    on: {\n      UPDATE: [{\n        guard: and(\"hasTypeChanged\", \"isChangingToLoading\"),\n        target: \"visible:persist\",\n        actions: [\"setContext\"]\n      }, {\n        guard: or(\"hasDurationChanged\", \"hasTypeChanged\"),\n        target: \"visible:updating\",\n        actions: [\"setContext\"]\n      }, {\n        actions: [\"setContext\"]\n      }],\n      MEASURE: {\n        actions: [\"measureHeight\"]\n      }\n    },\n    entry: [\"invokeOnVisible\"],\n    activities: [\"trackHeight\"],\n    states: {\n      \"visible:updating\": {\n        tags: [\"visible\", \"updating\"],\n        after: {\n          0: \"visible\"\n        }\n      },\n      \"visible:persist\": {\n        tags: [\"visible\", \"paused\"],\n        on: {\n          RESUME: {\n            guard: not(\"isLoadingType\"),\n            target: \"visible\",\n            actions: [\"setCreatedAt\"]\n          },\n          DISMISS: \"dismissing\"\n        }\n      },\n      visible: {\n        tags: [\"visible\"],\n        after: {\n          VISIBLE_DURATION: \"dismissing\"\n        },\n        on: {\n          DISMISS: \"dismissing\",\n          PAUSE: {\n            target: \"visible:persist\",\n            actions: \"setRemainingDuration\"\n          }\n        }\n      },\n      dismissing: {\n        entry: \"invokeOnDismiss\",\n        after: {\n          REMOVE_DELAY: {\n            target: \"unmounted\",\n            actions: \"notifyParentToRemove\"\n          }\n        }\n      },\n      unmounted: {\n        entry: \"invokeOnUnmount\",\n        type: \"final\"\n      }\n    }\n  }, {\n    activities: {\n      trackHeight(ctx2, _evt, {\n        self\n      }) {\n        let cleanup;\n        raf(() => {\n          const rootEl = dom.getRootEl(ctx2);\n          if (!rootEl) return;\n          ctx2.mounted = true;\n          const ghosts = queryAll(rootEl, \"[data-ghost]\");\n          warn(ghosts.length !== 2, \"[toast] No ghost element found in toast. Render the `ghostBefore` and `ghostAfter` elements\");\n          const syncHeight = () => {\n            const originalHeight = rootEl.style.height;\n            rootEl.style.height = \"auto\";\n            const newHeight = rootEl.getBoundingClientRect().height;\n            rootEl.style.height = originalHeight;\n            ctx2.height = newHeight;\n            self.sendParent({\n              type: \"UPDATE_HEIGHT\",\n              id: self.id,\n              height: newHeight,\n              placement: ctx2.placement\n            });\n          };\n          syncHeight();\n          const win = dom.getWin(ctx2);\n          const observer = new win.MutationObserver(syncHeight);\n          observer.observe(rootEl, {\n            childList: true,\n            subtree: true,\n            characterData: true\n          });\n          cleanup = () => observer.disconnect();\n        });\n        return () => cleanup?.();\n      }\n    },\n    guards: {\n      isChangingToLoading: (_, evt) => evt.toast?.type === \"loading\",\n      isLoadingType: ctx2 => ctx2.type === \"loading\",\n      hasTypeChanged: (ctx2, evt) => evt.toast?.type != null && evt.toast.type !== ctx2.type,\n      hasDurationChanged: (ctx2, evt) => evt.toast?.duration != null && evt.toast.duration !== ctx2.duration\n    },\n    delays: {\n      VISIBLE_DURATION: ctx2 => ctx2.remaining,\n      REMOVE_DELAY: ctx2 => ctx2.removeDelay\n    },\n    actions: {\n      measureHeight(ctx2, _evt, {\n        self\n      }) {\n        raf(() => {\n          const rootEl = dom.getRootEl(ctx2);\n          if (!rootEl) return;\n          ctx2.mounted = true;\n          const originalHeight = rootEl.style.height;\n          rootEl.style.height = \"auto\";\n          const newHeight = rootEl.getBoundingClientRect().height;\n          rootEl.style.height = originalHeight;\n          ctx2.height = newHeight;\n          self.sendParent({\n            type: \"UPDATE_HEIGHT\",\n            id: self.id,\n            height: newHeight,\n            placement: ctx2.placement\n          });\n        });\n      },\n      setRemainingDuration(ctx2) {\n        ctx2.remaining -= Date.now() - ctx2.createdAt;\n      },\n      setCreatedAt(ctx2) {\n        ctx2.createdAt = Date.now();\n      },\n      notifyParentToRemove(_ctx, _evt, {\n        self\n      }) {\n        self.sendParent({\n          type: \"REMOVE_TOAST\",\n          id: self.id\n        });\n      },\n      invokeOnDismiss(ctx2) {\n        ctx2.onStatusChange?.({\n          status: \"dismissing\"\n        });\n      },\n      invokeOnUnmount(ctx2) {\n        ctx2.onStatusChange?.({\n          status: \"unmounted\"\n        });\n      },\n      invokeOnVisible(ctx2) {\n        ctx2.onStatusChange?.({\n          status: \"visible\"\n        });\n      },\n      setContext(ctx2, evt) {\n        const duration2 = evt.toast?.duration;\n        const type2 = evt.toast?.type ?? ctx2.type;\n        const computedDuration2 = getToastDuration(duration2, type2);\n        Object.assign(ctx2, {\n          ...evt.toast,\n          duration: computedDuration2,\n          remaining: computedDuration2\n        });\n      }\n    }\n  });\n}\n\n// src/toast-group.machine.ts\nfunction groupMachine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"toaster\",\n    initial: ctx.overlap ? \"overlap\" : \"stack\",\n    context: {\n      dir: \"ltr\",\n      max: Number.MAX_SAFE_INTEGER,\n      gap: 16,\n      pauseOnPageIdle: false,\n      hotkey: [\"altKey\", \"KeyT\"],\n      offsets: \"1rem\",\n      placement: \"bottom\",\n      removeDelay: 200,\n      ...ctx,\n      toasts: [],\n      lastFocusedEl: null,\n      isFocusWithin: false,\n      heights: []\n    },\n    computed: {\n      count: ctx2 => ctx2.toasts.length\n    },\n    activities: [\"trackDocumentVisibility\", \"trackHotKeyPress\"],\n    watch: {\n      toasts: [\"collapsedIfEmpty\", \"setDismissableBranch\"]\n    },\n    exit: [\"removeToasts\", \"clearDismissableBranch\", \"clearLastFocusedEl\"],\n    on: {\n      PAUSE_TOAST: {\n        actions: [\"pauseToast\"]\n      },\n      PAUSE_ALL: {\n        actions: [\"pauseToasts\"]\n      },\n      RESUME_TOAST: {\n        actions: [\"resumeToast\"]\n      },\n      RESUME_ALL: {\n        actions: [\"resumeToasts\"]\n      },\n      ADD_TOAST: {\n        guard: \"isWithinRange\",\n        actions: [\"createToast\", \"syncToastIndex\"]\n      },\n      UPDATE_TOAST: {\n        actions: [\"updateToast\"]\n      },\n      DISMISS_TOAST: {\n        actions: [\"dismissToast\"]\n      },\n      DISMISS_ALL: {\n        actions: [\"dismissToasts\"]\n      },\n      REMOVE_TOAST: {\n        actions: [\"removeToast\", \"syncToastIndex\", \"syncToastOffset\"]\n      },\n      REMOVE_ALL: {\n        actions: [\"removeToasts\"]\n      },\n      UPDATE_HEIGHT: {\n        actions: [\"syncHeights\", \"syncToastOffset\"]\n      },\n      \"DOC.HOTKEY\": {\n        actions: [\"focusRegionEl\"]\n      },\n      \"REGION.BLUR\": [{\n        guard: \"isOverlapping\",\n        target: \"overlap\",\n        actions: [\"resumeToasts\", \"restoreLastFocusedEl\"]\n      }, {\n        actions: [\"resumeToasts\", \"restoreLastFocusedEl\"]\n      }]\n    },\n    states: {\n      stack: {\n        entry: [\"expandToasts\"],\n        on: {\n          \"REGION.POINTER_LEAVE\": [{\n            guard: \"isOverlapping\",\n            target: \"overlap\",\n            actions: [\"resumeToasts\"]\n          }, {\n            actions: [\"resumeToasts\"]\n          }],\n          \"REGION.OVERLAP\": {\n            target: \"overlap\"\n          },\n          \"REGION.FOCUS\": {\n            actions: [\"setLastFocusedEl\", \"pauseToasts\"]\n          },\n          \"REGION.POINTER_ENTER\": {\n            actions: [\"pauseToasts\"]\n          }\n        }\n      },\n      overlap: {\n        entry: [\"collapseToasts\"],\n        on: {\n          \"REGION.STACK\": {\n            target: \"stack\"\n          },\n          \"REGION.POINTER_ENTER\": {\n            target: \"stack\",\n            actions: [\"pauseToasts\"]\n          },\n          \"REGION.FOCUS\": {\n            target: \"stack\",\n            actions: [\"setLastFocusedEl\", \"pauseToasts\"]\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      isWithinRange: ctx2 => ctx2.toasts.length < ctx2.max,\n      isOverlapping: ctx2 => !!ctx2.overlap\n    },\n    activities: {\n      trackHotKeyPress(ctx2, _evt, {\n        send\n      }) {\n        const handleKeyDown = event => {\n          const isHotkeyPressed = ctx2.hotkey.every(key => event[key] || event.code === key);\n          if (!isHotkeyPressed) return;\n          send({\n            type: \"DOC.HOTKEY\"\n          });\n        };\n        return addDomEvent(document, \"keydown\", handleKeyDown, {\n          capture: true\n        });\n      },\n      trackDocumentVisibility(ctx2, _evt, {\n        send\n      }) {\n        if (!ctx2.pauseOnPageIdle) return;\n        const doc = dom.getDoc(ctx2);\n        return addDomEvent(doc, \"visibilitychange\", () => {\n          send(doc.visibilityState === \"hidden\" ? \"PAUSE_ALL\" : \"RESUME_ALL\");\n        });\n      }\n    },\n    actions: {\n      setDismissableBranch(ctx2) {\n        const currentToasts = getToastsByPlacement(ctx2.toasts, ctx2.placement);\n        const hasToasts = currentToasts.length > 0;\n        if (!hasToasts) {\n          ctx2._cleanup?.();\n          return;\n        }\n        if (hasToasts && ctx2._cleanup) {\n          return;\n        }\n        const groupEl = () => dom.getRegionEl(ctx2, ctx2.placement);\n        ctx2._cleanup = trackDismissableBranch(groupEl, {\n          defer: true\n        });\n      },\n      clearDismissableBranch(ctx2) {\n        ctx2._cleanup?.();\n      },\n      focusRegionEl(ctx2) {\n        queueMicrotask(() => {\n          dom.getRegionEl(ctx2, ctx2.placement)?.focus();\n        });\n      },\n      expandToasts(ctx2) {\n        each(ctx2, toast => {\n          toast.state.context.stacked = true;\n        });\n      },\n      collapseToasts(ctx2) {\n        each(ctx2, toast => {\n          toast.state.context.stacked = false;\n        });\n      },\n      collapsedIfEmpty(ctx2, _evt, {\n        send\n      }) {\n        if (!ctx2.overlap || ctx2.toasts.length > 1) return;\n        send(\"REGION.OVERLAP\");\n      },\n      pauseToast(_ctx, evt, {\n        self\n      }) {\n        self.sendChild(\"PAUSE\", evt.id);\n      },\n      pauseToasts(ctx2) {\n        ctx2.toasts.forEach(toast => toast.send(\"PAUSE\"));\n      },\n      resumeToast(_ctx, evt, {\n        self\n      }) {\n        self.sendChild(\"RESUME\", evt.id);\n      },\n      resumeToasts(ctx2) {\n        ctx2.toasts.forEach(toast => toast.send(\"RESUME\"));\n      },\n      measureToasts(ctx2) {\n        ctx2.toasts.forEach(toast => toast.send(\"MEASURE\"));\n      },\n      createToast(ctx2, evt, {\n        self,\n        getState\n      }) {\n        const options = {\n          placement: ctx2.placement,\n          duration: ctx2.duration,\n          removeDelay: ctx2.removeDelay,\n          ...evt.toast,\n          dir: ctx2.dir,\n          getRootNode: ctx2.getRootNode,\n          stacked: getState().matches(\"stack\")\n        };\n        const toast = createToastMachine(options);\n        const actor = self.spawn(toast);\n        ctx2.toasts = [actor, ...ctx2.toasts];\n      },\n      updateToast(_ctx, evt, {\n        self\n      }) {\n        self.sendChild({\n          type: \"UPDATE\",\n          toast: evt.toast\n        }, evt.id);\n      },\n      dismissToast(_ctx, evt, {\n        self\n      }) {\n        self.sendChild(\"DISMISS\", evt.id);\n      },\n      dismissToasts(ctx2) {\n        ctx2.toasts.forEach(toast => toast.send(\"DISMISS\"));\n      },\n      removeToast(ctx2, evt, {\n        self\n      }) {\n        self.stopChild(evt.id);\n        ctx2.toasts = ctx2.toasts.filter(toast => toast.id !== evt.id);\n        ctx2.heights = ctx2.heights.filter(height => height.id !== evt.id);\n      },\n      removeToasts(ctx2, _evt, {\n        self\n      }) {\n        ctx2.toasts.forEach(toast => self.stopChild(toast.id));\n        ctx2.toasts = [];\n        ctx2.heights = [];\n      },\n      syncHeights(ctx2, evt) {\n        const existing = ctx2.heights.find(height => height.id === evt.id);\n        if (existing) {\n          existing.height = evt.height;\n          existing.placement = evt.placement;\n        } else {\n          const newHeight = {\n            id: evt.id,\n            height: evt.height,\n            placement: evt.placement\n          };\n          ctx2.heights = [newHeight, ...ctx2.heights];\n        }\n      },\n      syncToastIndex(ctx2) {\n        each(ctx2, (toast, index, toasts) => {\n          toast.state.context.index = index;\n          toast.state.context.frontmost = index === 0;\n          toast.state.context.zIndex = toasts.length - index;\n        });\n      },\n      syncToastOffset(ctx2, evt) {\n        const placement = evt.placement ?? ctx2.placement;\n        each({\n          ...ctx2,\n          placement\n        }, toast => {\n          const heightIndex = Math.max(ctx2.heights.findIndex(height => height.id === toast.id), 0);\n          const toastsHeightBefore = ctx2.heights.reduce((prev, curr, reducerIndex) => {\n            if (reducerIndex >= heightIndex) return prev;\n            return prev + curr.height;\n          }, 0);\n          toast.state.context.offset = heightIndex * ctx2.gap + toastsHeightBefore;\n        });\n      },\n      setLastFocusedEl(ctx2, evt) {\n        if (ctx2.isFocusWithin || !evt.target) return;\n        ctx2.isFocusWithin = true;\n        ctx2.lastFocusedEl = ref(evt.target);\n      },\n      restoreLastFocusedEl(ctx2) {\n        ctx2.isFocusWithin = false;\n        if (!ctx2.lastFocusedEl) return;\n        ctx2.lastFocusedEl.focus({\n          preventScroll: true\n        });\n        ctx2.lastFocusedEl = null;\n      },\n      clearLastFocusedEl(ctx2) {\n        if (!ctx2.lastFocusedEl) return;\n        ctx2.lastFocusedEl.focus({\n          preventScroll: true\n        });\n        ctx2.lastFocusedEl = null;\n        ctx2.isFocusWithin = false;\n      }\n    }\n  });\n}\nfunction each(ctx, fn) {\n  const currentToasts = getToastsByPlacement(ctx.toasts, ctx.placement);\n  currentToasts.forEach(fn);\n}\nfunction connect(state, send, normalize) {\n  const visible = state.hasTag(\"visible\");\n  const paused = state.hasTag(\"paused\");\n  const placement = state.context.placement;\n  const type = state.context.type;\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return {\n    type,\n    title: state.context.title,\n    description: state.context.description,\n    placement,\n    visible,\n    paused,\n    pause() {\n      send(\"PAUSE\");\n    },\n    resume() {\n      send(\"RESUME\");\n    },\n    dismiss() {\n      send(\"DISMISS\");\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        id: dom.getRootId(state.context),\n        \"data-state\": visible ? \"open\" : \"closed\",\n        \"data-type\": type,\n        \"data-placement\": placement,\n        \"data-align\": align,\n        \"data-side\": side,\n        \"data-mounted\": dataAttr(state.context.mounted),\n        \"data-paused\": dataAttr(paused),\n        \"data-first\": dataAttr(state.context.frontmost),\n        \"data-sibling\": dataAttr(!state.context.frontmost),\n        \"data-stack\": dataAttr(state.context.stacked),\n        \"data-overlap\": dataAttr(!state.context.stacked),\n        role: \"status\",\n        \"aria-atomic\": \"true\",\n        \"aria-describedby\": state.context.description ? dom.getDescriptionId(state.context) : void 0,\n        \"aria-labelledby\": state.context.title ? dom.getTitleId(state.context) : void 0,\n        tabIndex: 0,\n        style: getPlacementStyle(state.context, visible),\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (event.key == \"Escape\") {\n            send(\"DISMISS\");\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    /* Leave a ghost div to avoid setting hover to false when transitioning out */\n    getGhostBeforeProps() {\n      return normalize.element({\n        \"data-ghost\": \"before\",\n        style: getGhostBeforeStyle(state.context, visible)\n      });\n    },\n    /* Needed to avoid setting hover to false when in between toasts */\n    getGhostAfterProps() {\n      return normalize.element({\n        \"data-ghost\": \"after\",\n        style: getGhostAfterStyle()\n      });\n    },\n    getTitleProps() {\n      return normalize.element({\n        ...parts.title.attrs,\n        id: dom.getTitleId(state.context)\n      });\n    },\n    getDescriptionProps() {\n      return normalize.element({\n        ...parts.description.attrs,\n        id: dom.getDescriptionId(state.context)\n      });\n    },\n    getActionTriggerProps() {\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          state.context.action?.onClick?.();\n          send(\"DISMISS\");\n        }\n      });\n    },\n    getCloseTriggerProps() {\n      return normalize.button({\n        id: dom.getCloseTriggerId(state.context),\n        ...parts.closeTrigger.attrs,\n        type: \"button\",\n        \"aria-label\": \"Dismiss notification\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send(\"DISMISS\");\n        }\n      });\n    }\n  };\n}\n\n// src/index.ts\nvar group = {\n  connect: groupConnect,\n  machine: groupMachine\n};\nexport { anatomy, connect, createToastMachine as createMachine, group };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
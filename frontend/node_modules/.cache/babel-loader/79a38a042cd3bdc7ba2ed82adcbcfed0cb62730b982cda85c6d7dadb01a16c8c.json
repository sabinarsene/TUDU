{"ast":null,"code":"'use client';\n\nimport { clampValue, toPrecision, countDecimalPlaces } from '@chakra-ui/utils';\nimport { useState, useCallback } from 'react';\nimport { useCallbackRef } from './use-callback-ref.mjs';\nfunction useCounter(props = {}) {\n  const {\n    onChange,\n    precision: precisionProp,\n    defaultValue,\n    value: valueProp,\n    step: stepProp = 1,\n    min = Number.MIN_SAFE_INTEGER,\n    max = Number.MAX_SAFE_INTEGER,\n    keepWithinRange = true\n  } = props;\n  const onChangeProp = useCallbackRef(onChange);\n  const [valueState, setValue] = useState(() => {\n    if (defaultValue == null) return \"\";\n    return cast(defaultValue, stepProp, precisionProp) ?? \"\";\n  });\n  const isControlled = typeof valueProp !== \"undefined\";\n  const value = isControlled ? valueProp : valueState;\n  const decimalPlaces = getDecimalPlaces(parse(value), stepProp);\n  const precision = precisionProp ?? decimalPlaces;\n  const update = useCallback(next => {\n    if (next === value) return;\n    if (!isControlled) {\n      setValue(next.toString());\n    }\n    onChangeProp?.(next.toString(), parse(next));\n  }, [onChangeProp, isControlled, value]);\n  const clamp = useCallback(value2 => {\n    let nextValue = value2;\n    if (keepWithinRange) {\n      nextValue = clampValue(nextValue, min, max);\n    }\n    return toPrecision(nextValue, precision);\n  }, [precision, keepWithinRange, max, min]);\n  const increment = useCallback((step = stepProp) => {\n    let next;\n    if (value === \"\") {\n      next = parse(step);\n    } else {\n      next = parse(value) + step;\n    }\n    next = clamp(next);\n    update(next);\n  }, [clamp, stepProp, update, value]);\n  const decrement = useCallback((step = stepProp) => {\n    let next;\n    if (value === \"\") {\n      next = parse(-step);\n    } else {\n      next = parse(value) - step;\n    }\n    next = clamp(next);\n    update(next);\n  }, [clamp, stepProp, update, value]);\n  const reset = useCallback(() => {\n    let next;\n    if (defaultValue == null) {\n      next = \"\";\n    } else {\n      next = cast(defaultValue, stepProp, precisionProp) ?? min;\n    }\n    update(next);\n  }, [defaultValue, precisionProp, stepProp, update, min]);\n  const castValue = useCallback(value2 => {\n    const nextValue = cast(value2, stepProp, precision) ?? min;\n    update(nextValue);\n  }, [precision, stepProp, update, min]);\n  const valueAsNumber = parse(value);\n  const isOutOfRange = valueAsNumber > max || valueAsNumber < min;\n  const isAtMax = valueAsNumber === max;\n  const isAtMin = valueAsNumber === min;\n  return {\n    isOutOfRange,\n    isAtMax,\n    isAtMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast: castValue,\n    setValue\n  };\n}\nfunction parse(value) {\n  return parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"));\n}\nfunction getDecimalPlaces(value, step) {\n  return Math.max(countDecimalPlaces(step), countDecimalPlaces(value));\n}\nfunction cast(value, step, precision) {\n  const parsedValue = parse(value);\n  if (Number.isNaN(parsedValue)) return void 0;\n  const decimalPlaces = getDecimalPlaces(parsedValue, step);\n  return toPrecision(parsedValue, precision ?? decimalPlaces);\n}\nexport { useCounter };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
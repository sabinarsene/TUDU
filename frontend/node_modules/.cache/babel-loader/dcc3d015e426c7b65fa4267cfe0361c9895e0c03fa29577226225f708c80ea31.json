{"ast":null,"code":"\"use strict\";\n\nimport { compact } from '../utils/compact.js';\nimport { isString, isObject } from '../utils/is.js';\nimport { memo } from '../utils/memo.js';\nimport { mergeWith } from '../utils/merge.js';\nimport { walkObject } from '../utils/walk-object.js';\nimport { sortAtRules } from './sort-at-rules.js';\nconst importantRegex = /\\s*!(important)?/i;\nconst isImportant = v => isString(v) ? importantRegex.test(v) : false;\nconst withoutImportant = v => isString(v) ? v.replace(importantRegex, \"\").trim() : v;\nfunction createCssFn(context) {\n  const {\n    transform,\n    conditions,\n    normalize\n  } = context;\n  const mergeFn = mergeCss(context);\n  return memo(function cssFn(...styleArgs) {\n    const styles = mergeFn(...styleArgs);\n    const normalized = normalize(styles);\n    const result = /* @__PURE__ */Object.create(null);\n    walkObject(normalized, (value, paths) => {\n      const important = isImportant(value);\n      if (value == null) return;\n      const [prop, ...selectors] = conditions.sort(paths).map(conditions.resolve);\n      if (important) {\n        value = withoutImportant(value);\n      }\n      let transformed = transform(prop, value) ?? /* @__PURE__ */Object.create(null);\n      transformed = walkObject(transformed, v => isString(v) && important ? `${v} !important` : v, {\n        getKey: prop2 => conditions.expandAtRule(prop2)\n      });\n      mergeByPath(result, selectors.flat(), transformed);\n    });\n    return sortAtRules(result);\n  });\n}\nfunction mergeByPath(target, paths, value) {\n  let acc = target;\n  for (const path of paths) {\n    if (!path) continue;\n    if (!acc[path]) acc[path] = /* @__PURE__ */Object.create(null);\n    acc = acc[path];\n  }\n  mergeWith(acc, value);\n}\nfunction compactFn(...styles) {\n  return styles.filter(style => isObject(style) && Object.keys(compact(style)).length > 0);\n}\nfunction mergeCss(ctx) {\n  function resolve(styles) {\n    const comp = compactFn(...styles);\n    if (comp.length === 1) return comp;\n    return comp.map(style => ctx.normalize(style));\n  }\n  return memo(function mergeFn(...styles) {\n    return mergeWith({}, ...resolve(styles));\n  });\n}\nexport { createCssFn };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\sabin.arsene\\\\Desktop\\\\TUDU-app\\\\TUDU\\\\frontend\\\\src\\\\contexts\\\\MessageContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { useAuth } from './AuthContext';\nimport { useSocket } from './SocketContext';\nimport { getUnreadMessagesCount } from '../services/messageApi';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MessageContext = /*#__PURE__*/createContext();\nexport const useMessages = () => {\n  _s();\n  return useContext(MessageContext);\n};\n_s(useMessages, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const MessageProvider = ({\n  children\n}) => {\n  _s2();\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [loading, setLoading] = useState(true);\n  const {\n    user\n  } = useAuth();\n  const {\n    socket,\n    connected\n  } = useSocket();\n\n  // Încarcă numărul de mesaje necitite la inițializare și când utilizatorul se schimbă\n  useEffect(() => {\n    if (!user) {\n      setUnreadCount(0);\n      setLoading(false);\n      return;\n    }\n    const loadUnreadCount = async () => {\n      setLoading(true);\n      try {\n        const count = await getUnreadMessagesCount();\n        setUnreadCount(count);\n      } catch (error) {\n        console.error('Error loading unread messages count:', error);\n      } finally {\n        setLoading(false);\n      }\n    };\n    loadUnreadCount();\n  }, [user]);\n\n  // Actualizează numărul de mesaje necitite când primim un mesaj nou\n  useEffect(() => {\n    if (!socket || !connected || !user) return;\n    const handleMessageReceived = async message => {\n      // Dacă mesajul este pentru utilizatorul curent și nu este trimis de el\n      if (message.receiver_id === user.id && message.sender_id !== user.id) {\n        // Incrementează contorul de mesaje necitite\n        setUnreadCount(prev => prev + 1);\n      }\n    };\n    const handleMessageRead = data => {\n      if (data.count > 0) {\n        // Actualizează contorul, asigurându-ne că nu scădem sub 0\n        setUnreadCount(prev => Math.max(0, prev - data.count));\n      }\n    };\n\n    // Ascultă pentru evenimente de mesaje noi și mesaje citite\n    socket.on('message_received', handleMessageReceived);\n    socket.on('messages_read', handleMessageRead);\n    return () => {\n      socket.off('message_received', handleMessageReceived);\n      socket.off('messages_read', handleMessageRead);\n    };\n  }, [socket, connected, user]);\n\n  // Funcție pentru a reîmprospăta manual contorul de mesaje necitite\n  const refreshUnreadCount = async () => {\n    if (!user) return;\n    try {\n      const count = await getUnreadMessagesCount();\n      setUnreadCount(count);\n    } catch (error) {\n      console.error('Error refreshing unread messages count:', error);\n    }\n  };\n  const value = {\n    unreadCount,\n    loading,\n    refreshUnreadCount\n  };\n  return /*#__PURE__*/_jsxDEV(MessageContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 89,\n    columnNumber: 5\n  }, this);\n};\n_s2(MessageProvider, \"y9a+XeFTnS8s2Pz4Wd8s21i3uCc=\", false, function () {\n  return [useAuth, useSocket];\n});\n_c = MessageProvider;\nexport default MessageProvider;\nvar _c;\n$RefreshReg$(_c, \"MessageProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useAuth","useSocket","getUnreadMessagesCount","jsxDEV","_jsxDEV","MessageContext","useMessages","_s","MessageProvider","children","_s2","unreadCount","setUnreadCount","loading","setLoading","user","socket","connected","loadUnreadCount","count","error","console","handleMessageReceived","message","receiver_id","id","sender_id","prev","handleMessageRead","data","Math","max","on","off","refreshUnreadCount","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/sabin.arsene/Desktop/TUDU-app/TUDU/frontend/src/contexts/MessageContext.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\r\nimport { useAuth } from './AuthContext';\r\nimport { useSocket } from './SocketContext';\r\nimport { getUnreadMessagesCount } from '../services/messageApi';\r\n\r\nconst MessageContext = createContext();\r\n\r\nexport const useMessages = () => {\r\n  return useContext(MessageContext);\r\n};\r\n\r\nexport const MessageProvider = ({ children }) => {\r\n  const [unreadCount, setUnreadCount] = useState(0);\r\n  const [loading, setLoading] = useState(true);\r\n  const { user } = useAuth();\r\n  const { socket, connected } = useSocket();\r\n\r\n  // Încarcă numărul de mesaje necitite la inițializare și când utilizatorul se schimbă\r\n  useEffect(() => {\r\n    if (!user) {\r\n      setUnreadCount(0);\r\n      setLoading(false);\r\n      return;\r\n    }\r\n\r\n    const loadUnreadCount = async () => {\r\n      setLoading(true);\r\n      try {\r\n        const count = await getUnreadMessagesCount();\r\n        setUnreadCount(count);\r\n      } catch (error) {\r\n        console.error('Error loading unread messages count:', error);\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    loadUnreadCount();\r\n  }, [user]);\r\n\r\n  // Actualizează numărul de mesaje necitite când primim un mesaj nou\r\n  useEffect(() => {\r\n    if (!socket || !connected || !user) return;\r\n\r\n    const handleMessageReceived = async (message) => {\r\n      // Dacă mesajul este pentru utilizatorul curent și nu este trimis de el\r\n      if (message.receiver_id === user.id && message.sender_id !== user.id) {\r\n        // Incrementează contorul de mesaje necitite\r\n        setUnreadCount(prev => prev + 1);\r\n      }\r\n    };\r\n\r\n    const handleMessageRead = (data) => {\r\n      if (data.count > 0) {\r\n        // Actualizează contorul, asigurându-ne că nu scădem sub 0\r\n        setUnreadCount(prev => Math.max(0, prev - data.count));\r\n      }\r\n    };\r\n\r\n    // Ascultă pentru evenimente de mesaje noi și mesaje citite\r\n    socket.on('message_received', handleMessageReceived);\r\n    socket.on('messages_read', handleMessageRead);\r\n\r\n    return () => {\r\n      socket.off('message_received', handleMessageReceived);\r\n      socket.off('messages_read', handleMessageRead);\r\n    };\r\n  }, [socket, connected, user]);\r\n\r\n  // Funcție pentru a reîmprospăta manual contorul de mesaje necitite\r\n  const refreshUnreadCount = async () => {\r\n    if (!user) return;\r\n    \r\n    try {\r\n      const count = await getUnreadMessagesCount();\r\n      setUnreadCount(count);\r\n    } catch (error) {\r\n      console.error('Error refreshing unread messages count:', error);\r\n    }\r\n  };\r\n\r\n  const value = {\r\n    unreadCount,\r\n    loading,\r\n    refreshUnreadCount\r\n  };\r\n\r\n  return (\r\n    <MessageContext.Provider value={value}>\r\n      {children}\r\n    </MessageContext.Provider>\r\n  );\r\n};\r\n\r\nexport default MessageProvider; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, dataAttr, addDomEvent, getOverflowAncestors, isComposingEvent } from '@zag-js/dom-query';\nimport { isFocusVisible, trackFocusVisible } from '@zag-js/focus-visible';\nimport { getPlacementStyles, getPlacement } from '@zag-js/popper';\nimport { proxy, createMachine, subscribe, guards } from '@zag-js/core';\nimport { createSplitProps, compact } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/tooltip.anatomy.ts\nvar anatomy = createAnatomy(\"tooltip\").parts(\"trigger\", \"arrow\", \"arrowTip\", \"positioner\", \"content\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getTriggerId: ctx => ctx.ids?.trigger ?? `tooltip:${ctx.id}:trigger`,\n  getContentId: ctx => ctx.ids?.content ?? `tooltip:${ctx.id}:content`,\n  getArrowId: ctx => ctx.ids?.arrow ?? `tooltip:${ctx.id}:arrow`,\n  getPositionerId: ctx => ctx.ids?.positioner ?? `tooltip:${ctx.id}:popper`,\n  getTriggerEl: ctx => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getContentEl: ctx => dom.getById(ctx, dom.getContentId(ctx)),\n  getPositionerEl: ctx => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getArrowEl: ctx => dom.getById(ctx, dom.getArrowId(ctx))\n});\nvar store = proxy({\n  id: null,\n  prevId: null,\n  setId(val) {\n    this.prevId = this.id;\n    this.id = val;\n  }\n});\n\n// src/tooltip.connect.ts\nfunction connect(state, send, normalize) {\n  const id = state.context.id;\n  const hasAriaLabel = state.context.hasAriaLabel;\n  const open = state.hasTag(\"open\");\n  const triggerId = dom.getTriggerId(state.context);\n  const contentId = dom.getContentId(state.context);\n  const disabled = state.context.disabled;\n  const popperStyles = getPlacementStyles({\n    ...state.context.positioning,\n    placement: state.context.currentPlacement\n  });\n  return {\n    open,\n    setOpen(nextOpen) {\n      if (nextOpen === open) return;\n      send(nextOpen ? \"OPEN\" : \"CLOSE\");\n    },\n    reposition(options = {}) {\n      send({\n        type: \"POSITIONING.SET\",\n        options\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        id: triggerId,\n        dir: state.context.dir,\n        \"data-expanded\": dataAttr(open),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-describedby\": open ? contentId : void 0,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (!state.context.closeOnClick) return;\n          send({\n            type: \"CLOSE\",\n            src: \"trigger.click\"\n          });\n        },\n        onFocus(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (state.event.src === \"trigger.pointerdown\") return;\n          if (!isFocusVisible()) return;\n          send({\n            type: \"OPEN\",\n            src: \"trigger.focus\"\n          });\n        },\n        onBlur(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (id === store.id) {\n            send({\n              type: \"CLOSE\",\n              src: \"trigger.blur\"\n            });\n          }\n        },\n        onPointerDown(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (!state.context.closeOnPointerDown) return;\n          if (id === store.id) {\n            send({\n              type: \"CLOSE\",\n              src: \"trigger.pointerdown\"\n            });\n          }\n        },\n        onPointerMove(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (event.pointerType === \"touch\") return;\n          send(\"POINTER_MOVE\");\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send(\"POINTER_LEAVE\");\n        },\n        onPointerCancel() {\n          if (disabled) return;\n          send(\"POINTER_LEAVE\");\n        }\n      });\n    },\n    getArrowProps() {\n      return normalize.element({\n        id: dom.getArrowId(state.context),\n        ...parts.arrow.attrs,\n        dir: state.context.dir,\n        style: popperStyles.arrow\n      });\n    },\n    getArrowTipProps() {\n      return normalize.element({\n        ...parts.arrowTip.attrs,\n        dir: state.context.dir,\n        style: popperStyles.arrowTip\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        id: dom.getPositionerId(state.context),\n        ...parts.positioner.attrs,\n        dir: state.context.dir,\n        style: popperStyles.floating\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: state.context.dir,\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        role: hasAriaLabel ? void 0 : \"tooltip\",\n        id: hasAriaLabel ? void 0 : contentId,\n        \"data-placement\": state.context.currentPlacement,\n        onPointerEnter() {\n          send(\"CONTENT.POINTER_MOVE\");\n        },\n        onPointerLeave() {\n          send(\"CONTENT.POINTER_LEAVE\");\n        },\n        style: {\n          pointerEvents: state.context.interactive ? \"auto\" : \"none\"\n        }\n      });\n    }\n  };\n}\nvar {\n  and,\n  not\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"tooltip\",\n    initial: ctx.open ? \"open\" : \"closed\",\n    activities: [\"trackFocusVisible\"],\n    context: {\n      openDelay: 1e3,\n      closeDelay: 500,\n      closeOnPointerDown: true,\n      closeOnEscape: true,\n      interactive: false,\n      closeOnScroll: true,\n      closeOnClick: true,\n      disabled: false,\n      ...ctx,\n      currentPlacement: void 0,\n      hasPointerMoveOpened: false,\n      positioning: {\n        placement: \"bottom\",\n        ...ctx.positioning\n      }\n    },\n    computed: {\n      hasAriaLabel: ctx2 => !!ctx2[\"aria-label\"]\n    },\n    watch: {\n      disabled: [\"closeIfDisabled\"],\n      open: [\"toggleVisibility\"]\n    },\n    states: {\n      closed: {\n        tags: [\"closed\"],\n        entry: [\"clearGlobalId\"],\n        on: {\n          \"CONTROLLED.OPEN\": \"open\",\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\"]\n          }],\n          POINTER_LEAVE: {\n            actions: [\"clearPointerMoveOpened\"]\n          },\n          POINTER_MOVE: [{\n            guard: and(\"noVisibleTooltip\", not(\"hasPointerMoveOpened\")),\n            target: \"opening\"\n          }, {\n            guard: not(\"hasPointerMoveOpened\"),\n            target: \"open\",\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n          }]\n        }\n      },\n      opening: {\n        tags: [\"closed\"],\n        activities: [\"trackScroll\", \"trackPointerlockChange\"],\n        after: {\n          OPEN_DELAY: [{\n            guard: \"isOpenControlled\",\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n          }]\n        },\n        on: {\n          \"CONTROLLED.OPEN\": \"open\",\n          \"CONTROLLED.CLOSE\": \"closed\",\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\"]\n          }],\n          POINTER_LEAVE: [{\n            guard: \"isOpenControlled\",\n            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n            actions: [\"clearPointerMoveOpened\", \"invokeOnClose\", \"toggleVisibility\"]\n          }, {\n            target: \"closed\",\n            actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n          }],\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n            actions: [\"invokeOnClose\", \"toggleVisibility\"]\n          }, {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }]\n        }\n      },\n      open: {\n        tags: [\"open\"],\n        activities: [\"trackEscapeKey\", \"trackScroll\", \"trackPointerlockChange\", \"trackPositioning\"],\n        entry: [\"setGlobalId\"],\n        on: {\n          \"CONTROLLED.CLOSE\": \"closed\",\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }],\n          POINTER_LEAVE: [{\n            guard: \"isVisible\",\n            target: \"closing\",\n            actions: [\"clearPointerMoveOpened\"]\n          },\n          // == group ==\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n          }, {\n            target: \"closed\",\n            actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n          }],\n          \"CONTENT.POINTER_LEAVE\": {\n            guard: \"isInteractive\",\n            target: \"closing\"\n          },\n          \"POSITIONING.SET\": {\n            actions: \"reposition\"\n          }\n        }\n      },\n      closing: {\n        tags: [\"open\"],\n        activities: [\"trackStore\", \"trackPositioning\"],\n        after: {\n          CLOSE_DELAY: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }]\n        },\n        on: {\n          \"CONTROLLED.CLOSE\": \"closed\",\n          \"CONTROLLED.OPEN\": \"open\",\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }],\n          POINTER_MOVE: [{\n            guard: \"isOpenControlled\",\n            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\", \"toggleVisibility\"]\n          }, {\n            target: \"open\",\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n          }],\n          \"CONTENT.POINTER_MOVE\": {\n            guard: \"isInteractive\",\n            target: \"open\"\n          },\n          \"POSITIONING.SET\": {\n            actions: \"reposition\"\n          }\n        }\n      }\n    }\n  }, {\n    activities: {\n      trackFocusVisible(ctx2) {\n        return trackFocusVisible({\n          root: dom.getRootNode(ctx2)\n        });\n      },\n      trackPositioning(ctx2) {\n        ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);\n        const getPositionerEl = () => dom.getPositionerEl(ctx2);\n        return getPlacement(dom.getTriggerEl(ctx2), getPositionerEl, {\n          ...ctx2.positioning,\n          defer: true,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      trackPointerlockChange(ctx2, _evt, {\n        send\n      }) {\n        const onChange = () => send({\n          type: \"CLOSE\",\n          src: \"pointerlock:change\"\n        });\n        return addDomEvent(dom.getDoc(ctx2), \"pointerlockchange\", onChange, false);\n      },\n      trackScroll(ctx2, _evt, {\n        send\n      }) {\n        if (!ctx2.closeOnScroll) return;\n        const triggerEl = dom.getTriggerEl(ctx2);\n        if (!triggerEl) return;\n        const overflowParents = getOverflowAncestors(triggerEl);\n        const cleanups = overflowParents.map(overflowParent => {\n          const onScroll = () => {\n            send({\n              type: \"CLOSE\",\n              src: \"scroll\"\n            });\n          };\n          return addDomEvent(overflowParent, \"scroll\", onScroll, {\n            passive: true,\n            capture: true\n          });\n        });\n        return () => {\n          cleanups.forEach(fn => fn?.());\n        };\n      },\n      trackStore(ctx2, _evt, {\n        send\n      }) {\n        return subscribe(store, () => {\n          if (store.id !== ctx2.id) {\n            send({\n              type: \"CLOSE\",\n              src: \"id.change\"\n            });\n          }\n        });\n      },\n      trackEscapeKey(ctx2, _evt, {\n        send\n      }) {\n        if (!ctx2.closeOnEscape) return;\n        const onKeyDown = event => {\n          if (isComposingEvent(event)) return;\n          if (event.key !== \"Escape\") return;\n          event.stopPropagation();\n          send({\n            type: \"CLOSE\",\n            src: \"keydown.escape\"\n          });\n        };\n        return addDomEvent(dom.getDoc(ctx2), \"keydown\", onKeyDown, true);\n      }\n    },\n    actions: {\n      setGlobalId(ctx2) {\n        store.setId(ctx2.id);\n      },\n      clearGlobalId(ctx2) {\n        if (ctx2.id === store.id) {\n          store.setId(null);\n        }\n      },\n      invokeOnOpen(ctx2) {\n        ctx2.onOpenChange?.({\n          open: true\n        });\n      },\n      invokeOnClose(ctx2) {\n        ctx2.onOpenChange?.({\n          open: false\n        });\n      },\n      closeIfDisabled(ctx2, _evt, {\n        send\n      }) {\n        if (!ctx2.disabled) return;\n        send({\n          type: \"CLOSE\",\n          src: \"disabled.change\"\n        });\n      },\n      reposition(ctx2, evt) {\n        const getPositionerEl = () => dom.getPositionerEl(ctx2);\n        getPlacement(dom.getTriggerEl(ctx2), getPositionerEl, {\n          ...ctx2.positioning,\n          ...evt.options,\n          defer: true,\n          listeners: false,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      toggleVisibility(ctx2, evt, {\n        send\n      }) {\n        queueMicrotask(() => {\n          send({\n            type: ctx2.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n            previousEvent: evt\n          });\n        });\n      },\n      setPointerMoveOpened(ctx2) {\n        ctx2.hasPointerMoveOpened = true;\n      },\n      clearPointerMoveOpened(ctx2) {\n        ctx2.hasPointerMoveOpened = false;\n      }\n    },\n    guards: {\n      noVisibleTooltip: () => store.id === null,\n      isVisible: ctx2 => ctx2.id === store.id,\n      isInteractive: ctx2 => ctx2.interactive,\n      hasPointerMoveOpened: ctx2 => !!ctx2.hasPointerMoveOpened,\n      isOpenControlled: ctx2 => !!ctx2[\"open.controlled\"]\n    },\n    delays: {\n      OPEN_DELAY: ctx2 => ctx2.openDelay,\n      CLOSE_DELAY: ctx2 => ctx2.closeDelay\n    }\n  });\n}\nvar props = createProps()([\"aria-label\", \"closeDelay\", \"closeOnEscape\", \"closeOnPointerDown\", \"closeOnScroll\", \"closeOnClick\", \"dir\", \"disabled\", \"getRootNode\", \"id\", \"ids\", \"interactive\", \"onOpenChange\", \"open.controlled\", \"open\", \"openDelay\", \"positioning\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
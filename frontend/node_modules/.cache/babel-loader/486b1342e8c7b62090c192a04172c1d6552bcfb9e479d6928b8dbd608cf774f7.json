{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, dataAttr } from '@zag-js/dom-query';\nimport { createMachine } from '@zag-js/core';\nimport { createSplitProps, compact, isEqual } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/pagination.anatomy.ts\nvar anatomy = createAnatomy(\"pagination\").parts(\"root\", \"item\", \"ellipsis\", \"prevTrigger\", \"nextTrigger\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `pagination:${ctx.id}`,\n  getPrevTriggerId: ctx => ctx.ids?.prevTrigger ?? `pagination:${ctx.id}:prev`,\n  getNextTriggerId: ctx => ctx.ids?.nextTrigger ?? `pagination:${ctx.id}:next`,\n  getEllipsisId: (ctx, index) => ctx.ids?.ellipsis?.(index) ?? `pagination:${ctx.id}:ellipsis:${index}`,\n  getItemId: (ctx, page) => ctx.ids?.item?.(page) ?? `pagination:${ctx.id}:item:${page}`\n});\n\n// src/pagination.utils.ts\nvar range = (start, end) => {\n  let length = end - start + 1;\n  return Array.from({\n    length\n  }, (_, idx) => idx + start);\n};\nvar transform = items => {\n  return items.map(value => {\n    if (typeof value === \"number\") return {\n      type: \"page\",\n      value\n    };\n    return {\n      type: \"ellipsis\"\n    };\n  });\n};\nvar ELLIPSIS = \"ellipsis\";\nvar getRange = ctx => {\n  const totalPageNumbers = Math.min(2 * ctx.siblingCount + 5, ctx.totalPages);\n  const firstPageIndex = 1;\n  const lastPageIndex = ctx.totalPages;\n  const leftSiblingIndex = Math.max(ctx.page - ctx.siblingCount, firstPageIndex);\n  const rightSiblingIndex = Math.min(ctx.page + ctx.siblingCount, lastPageIndex);\n  const showLeftEllipsis = leftSiblingIndex > firstPageIndex + 1;\n  const showRightEllipsis = rightSiblingIndex < lastPageIndex - 1;\n  const itemCount = totalPageNumbers - 2;\n  if (!showLeftEllipsis && showRightEllipsis) {\n    const leftRange = range(1, itemCount);\n    return [...leftRange, ELLIPSIS, lastPageIndex];\n  }\n  if (showLeftEllipsis && !showRightEllipsis) {\n    const rightRange = range(lastPageIndex - itemCount + 1, lastPageIndex);\n    return [firstPageIndex, ELLIPSIS, ...rightRange];\n  }\n  if (showLeftEllipsis && showRightEllipsis) {\n    const middleRange = range(leftSiblingIndex, rightSiblingIndex);\n    return [firstPageIndex, ELLIPSIS, ...middleRange, ELLIPSIS, lastPageIndex];\n  }\n  const fullRange = range(firstPageIndex, lastPageIndex);\n  return fullRange;\n};\nvar getTransformedRange = ctx => transform(getRange(ctx));\n\n// src/pagination.connect.ts\nfunction connect(state, send, normalize) {\n  const totalPages = state.context.totalPages;\n  const page = state.context.page;\n  const translations = state.context.translations;\n  const count = state.context.count;\n  const previousPage = state.context.previousPage;\n  const nextPage = state.context.nextPage;\n  const pageRange = state.context.pageRange;\n  const type = state.context.type;\n  const isButton = type === \"button\";\n  const isFirstPage = page === 1;\n  const isLastPage = page === totalPages;\n  const pages = getTransformedRange(state.context);\n  return {\n    count,\n    page,\n    pageSize: state.context.pageSize,\n    totalPages,\n    pages,\n    previousPage,\n    nextPage,\n    pageRange,\n    slice(data) {\n      return data.slice(pageRange.start, pageRange.end);\n    },\n    setCount(count2) {\n      send({\n        type: \"SET_COUNT\",\n        count: count2\n      });\n    },\n    setPageSize(size) {\n      send({\n        type: \"SET_PAGE_SIZE\",\n        size\n      });\n    },\n    setPage(page2) {\n      send({\n        type: \"SET_PAGE\",\n        page: page2\n      });\n    },\n    goToNextPage() {\n      send({\n        type: \"NEXT_PAGE\"\n      });\n    },\n    goToPrevPage() {\n      send({\n        type: \"PREVIOUS_PAGE\"\n      });\n    },\n    goToFirstPage() {\n      send({\n        type: \"FIRST_PAGE\"\n      });\n    },\n    goToLastPage() {\n      send({\n        type: \"LAST_PAGE\"\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        id: dom.getRootId(state.context),\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        \"aria-label\": translations.rootLabel\n      });\n    },\n    getEllipsisProps(props2) {\n      return normalize.element({\n        id: dom.getEllipsisId(state.context, props2.index),\n        ...parts.ellipsis.attrs,\n        dir: state.context.dir\n      });\n    },\n    getItemProps(props2) {\n      const index = props2.value;\n      const isCurrentPage = index === state.context.page;\n      return normalize.element({\n        id: dom.getItemId(state.context, index),\n        ...parts.item.attrs,\n        dir: state.context.dir,\n        \"data-index\": index,\n        \"data-selected\": dataAttr(isCurrentPage),\n        \"aria-current\": isCurrentPage ? \"page\" : void 0,\n        \"aria-label\": translations.itemLabel?.({\n          page: index,\n          totalPages\n        }),\n        onClick() {\n          send({\n            type: \"SET_PAGE\",\n            page: index\n          });\n        },\n        ...(isButton && {\n          type: \"button\"\n        })\n      });\n    },\n    getPrevTriggerProps() {\n      return normalize.element({\n        id: dom.getPrevTriggerId(state.context),\n        ...parts.prevTrigger.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(isFirstPage),\n        \"aria-label\": translations.prevTriggerLabel,\n        onClick() {\n          send({\n            type: \"PREVIOUS_PAGE\"\n          });\n        },\n        ...(isButton && {\n          disabled: isFirstPage,\n          type: \"button\"\n        })\n      });\n    },\n    getNextTriggerProps() {\n      return normalize.element({\n        id: dom.getNextTriggerId(state.context),\n        ...parts.nextTrigger.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(isLastPage),\n        \"aria-label\": translations.nextTriggerLabel,\n        onClick() {\n          send({\n            type: \"NEXT_PAGE\"\n          });\n        },\n        ...(isButton && {\n          disabled: isLastPage,\n          type: \"button\"\n        })\n      });\n    }\n  };\n}\nvar defaultTranslations = {\n  rootLabel: \"pagination\",\n  prevTriggerLabel: \"previous page\",\n  nextTriggerLabel: \"next page\",\n  itemLabel({\n    page,\n    totalPages\n  }) {\n    const isLastPage = totalPages > 1 && page === totalPages;\n    return `${isLastPage ? \"last page, \" : \"\"}page ${page}`;\n  }\n};\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"pagination\",\n    initial: \"idle\",\n    context: {\n      pageSize: 10,\n      siblingCount: 1,\n      page: 1,\n      type: \"button\",\n      translations: {\n        ...defaultTranslations,\n        ...ctx.translations\n      },\n      ...ctx\n    },\n    watch: {\n      pageSize: [\"setPageIfNeeded\"]\n    },\n    computed: {\n      totalPages: ctx2 => Math.ceil(ctx2.count / ctx2.pageSize),\n      previousPage: ctx2 => ctx2.page === 1 ? null : ctx2.page - 1,\n      nextPage: ctx2 => ctx2.page === ctx2.totalPages ? null : ctx2.page + 1,\n      pageRange: ctx2 => {\n        const start = (ctx2.page - 1) * ctx2.pageSize;\n        const end = Math.min(start + ctx2.pageSize, ctx2.count);\n        return {\n          start,\n          end\n        };\n      },\n      isValidPage: ctx2 => ctx2.page >= 1 && ctx2.page <= ctx2.totalPages\n    },\n    on: {\n      SET_COUNT: [{\n        guard: \"isValidCount\",\n        actions: [\"setCount\", \"goToFirstPage\"]\n      }, {\n        actions: \"setCount\"\n      }],\n      SET_PAGE: {\n        guard: \"isValidPage\",\n        actions: \"setPage\"\n      },\n      SET_PAGE_SIZE: {\n        actions: \"setPageSize\"\n      },\n      FIRST_PAGE: {\n        actions: \"goToFirstPage\"\n      },\n      LAST_PAGE: {\n        actions: \"goToLastPage\"\n      },\n      PREVIOUS_PAGE: {\n        guard: \"canGoToPrevPage\",\n        actions: \"goToPrevPage\"\n      },\n      NEXT_PAGE: {\n        guard: \"canGoToNextPage\",\n        actions: \"goToNextPage\"\n      }\n    },\n    states: {\n      idle: {}\n    }\n  }, {\n    guards: {\n      isValidPage: (ctx2, evt) => evt.page >= 1 && evt.page <= ctx2.totalPages,\n      isValidCount: (ctx2, evt) => ctx2.page > evt.count,\n      canGoToNextPage: ctx2 => ctx2.page < ctx2.totalPages,\n      canGoToPrevPage: ctx2 => ctx2.page > 1\n    },\n    actions: {\n      setCount(ctx2, evt) {\n        ctx2.count = evt.count;\n      },\n      setPage(ctx2, evt) {\n        set.page(ctx2, evt.page);\n      },\n      setPageSize(ctx2, evt) {\n        set.pageSize(ctx2, evt.size);\n      },\n      goToFirstPage(ctx2) {\n        set.page(ctx2, 1);\n      },\n      goToLastPage(ctx2) {\n        set.page(ctx2, ctx2.totalPages);\n      },\n      goToPrevPage(ctx2) {\n        set.page(ctx2, ctx2.page - 1);\n      },\n      goToNextPage(ctx2) {\n        set.page(ctx2, ctx2.page + 1);\n      },\n      setPageIfNeeded(ctx2, _evt) {\n        if (ctx2.isValidPage) return;\n        set.page(ctx2, 1);\n      }\n    }\n  });\n}\nvar clampPage = (page, totalPages) => Math.min(Math.max(page, 1), totalPages);\nvar set = {\n  pageSize: (ctx, value) => {\n    if (isEqual(ctx.pageSize, value)) return;\n    ctx.pageSize = value;\n    ctx.onPageSizeChange?.({\n      pageSize: ctx.pageSize\n    });\n  },\n  page: (ctx, value) => {\n    if (isEqual(ctx.page, value)) return;\n    ctx.page = clampPage(value, ctx.totalPages);\n    ctx.onPageChange?.({\n      page: ctx.page,\n      pageSize: ctx.pageSize\n    });\n  }\n};\nvar props = createProps()([\"count\", \"dir\", \"getRootNode\", \"id\", \"ids\", \"onPageChange\", \"onPageSizeChange\", \"page\", \"pageSize\", \"siblingCount\", \"translations\", \"type\"]);\nvar splitProps = createSplitProps(props);\nvar itemProps = createProps()([\"value\", \"type\"]);\nvar splitItemProps = createSplitProps(itemProps);\nvar ellipsisProps = createProps()([\"index\"]);\nvar splitEllipsisProps = createSplitProps(ellipsisProps);\nexport { anatomy, connect, ellipsisProps, itemProps, machine, props, splitEllipsisProps, splitItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
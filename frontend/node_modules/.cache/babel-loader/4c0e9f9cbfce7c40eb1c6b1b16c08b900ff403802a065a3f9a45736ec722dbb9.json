{"ast":null,"code":"\"use strict\";\n\nimport { toRem, toPx } from './unit-conversion.js';\nconst capitalize = str => str.charAt(0).toUpperCase() + str.slice(1);\nfunction createBreakpoints(breakpoints) {\n  const sorted = sort(breakpoints);\n  const values = Object.fromEntries(sorted);\n  function get(name) {\n    return values[name];\n  }\n  function only(name) {\n    return build(get(name));\n  }\n  function getRanges() {\n    const breakpoints2 = Object.keys(values);\n    const permuations = getPermutations(breakpoints2);\n    const results = breakpoints2.flatMap(name => {\n      const value = get(name);\n      const down2 = [`${name}Down`, build({\n        max: adjust(value.min)\n      })];\n      const up2 = [name, build({\n        min: value.min\n      })];\n      const _only = [`${name}Only`, only(name)];\n      return [up2, _only, down2];\n    }).filter(([, value]) => value !== \"\").concat(permuations.map(([min, max]) => {\n      const minValue = get(min);\n      const maxValue = get(max);\n      return [`${min}To${capitalize(max)}`, build({\n        min: minValue.min,\n        max: adjust(maxValue.min)\n      })];\n    }));\n    return Object.fromEntries(results);\n  }\n  function toConditions() {\n    const ranges = getRanges();\n    return Object.fromEntries(Object.entries(ranges));\n  }\n  const conditions = toConditions();\n  const getCondition = key => {\n    return conditions[key];\n  };\n  function keys() {\n    return [\"base\", ...Object.keys(values)];\n  }\n  function up(name) {\n    return build({\n      min: get(name).min\n    });\n  }\n  function down(name) {\n    return build({\n      max: adjust(get(name).min)\n    });\n  }\n  return {\n    values: Object.values(values),\n    only,\n    keys,\n    conditions,\n    getCondition,\n    up,\n    down\n  };\n}\nfunction adjust(value) {\n  const computedMax = parseFloat(toPx(value) ?? \"\") - 0.04;\n  return toRem(`${computedMax}px`);\n}\nfunction sort(breakpoints) {\n  const entries = Object.entries(breakpoints).sort(([, minA], [, minB]) => {\n    return parseInt(minA, 10) < parseInt(minB, 10) ? -1 : 1;\n  });\n  return entries.map(([name, min], index, entries2) => {\n    let max = null;\n    if (index <= entries2.length - 1) {\n      max = entries2[index + 1]?.[1];\n    }\n    if (max != null) {\n      max = adjust(max);\n    }\n    return [name, {\n      name,\n      min: toRem(min),\n      max\n    }];\n  });\n}\nfunction getPermutations(values) {\n  const result = [];\n  values.forEach((current, index) => {\n    let idx = index;\n    idx++;\n    let next = values[idx];\n    while (next) {\n      result.push([current, next]);\n      idx++;\n      next = values[idx];\n    }\n  });\n  return result;\n}\nfunction build({\n  min,\n  max\n}) {\n  if (min == null && max == null) return \"\";\n  return [\"@media screen\", min && `(min-width: ${min})`, max && `(max-width: ${max})`].filter(Boolean).join(\" and \");\n}\nexport { createBreakpoints };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
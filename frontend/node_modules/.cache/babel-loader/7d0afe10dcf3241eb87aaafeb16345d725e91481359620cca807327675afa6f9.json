{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, isSafari, MAX_Z_INDEX, dataAttr, ariaAttr, isComposingEvent, getEventStep, isLeftClick, getEventPoint, getWindow, trackFormControl, observeAttributes, addDomEvent, requestPointerLock, raf, setElementValue, isModifierKey } from '@zag-js/dom-query';\nimport { roundToDpr, wrap, compact, isValueAtMin, isValueAtMax, isValueWithinRange, callAll, incrementValue, clampValue, decrementValue, isEqual } from '@zag-js/utils';\nimport { createMachine, choose, ref, guards } from '@zag-js/core';\nimport { NumberParser } from '@internationalized/number';\n\n// src/number-input.anatomy.ts\nvar anatomy = createAnatomy(\"numberInput\").parts(\"root\", \"label\", \"input\", \"control\", \"valueText\", \"incrementTrigger\", \"decrementTrigger\", \"scrubber\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `number-input:${ctx.id}`,\n  getInputId: ctx => ctx.ids?.input ?? `number-input:${ctx.id}:input`,\n  getIncrementTriggerId: ctx => ctx.ids?.incrementTrigger ?? `number-input:${ctx.id}:inc`,\n  getDecrementTriggerId: ctx => ctx.ids?.decrementTrigger ?? `number-input:${ctx.id}:dec`,\n  getScrubberId: ctx => ctx.ids?.scrubber ?? `number-input:${ctx.id}:scrubber`,\n  getCursorId: ctx => `number-input:${ctx.id}:cursor`,\n  getLabelId: ctx => ctx.ids?.label ?? `number-input:${ctx.id}:label`,\n  getInputEl: ctx => dom.getById(ctx, dom.getInputId(ctx)),\n  getIncrementTriggerEl: ctx => dom.getById(ctx, dom.getIncrementTriggerId(ctx)),\n  getDecrementTriggerEl: ctx => dom.getById(ctx, dom.getDecrementTriggerId(ctx)),\n  getScrubberEl: ctx => dom.getById(ctx, dom.getScrubberId(ctx)),\n  getCursorEl: ctx => dom.getDoc(ctx).getElementById(dom.getCursorId(ctx)),\n  getPressedTriggerEl: (ctx, hint = ctx.hint) => {\n    let btnEl = null;\n    if (hint === \"increment\") {\n      btnEl = dom.getIncrementTriggerEl(ctx);\n    }\n    if (hint === \"decrement\") {\n      btnEl = dom.getDecrementTriggerEl(ctx);\n    }\n    return btnEl;\n  },\n  setupVirtualCursor(ctx) {\n    if (isSafari()) return;\n    dom.createVirtualCursor(ctx);\n    return () => {\n      dom.getCursorEl(ctx)?.remove();\n    };\n  },\n  preventTextSelection(ctx) {\n    const doc = dom.getDoc(ctx);\n    const html = doc.documentElement;\n    const body = doc.body;\n    body.style.pointerEvents = \"none\";\n    html.style.userSelect = \"none\";\n    html.style.cursor = \"ew-resize\";\n    return () => {\n      body.style.pointerEvents = \"\";\n      html.style.userSelect = \"\";\n      html.style.cursor = \"\";\n      if (!html.style.length) {\n        html.removeAttribute(\"style\");\n      }\n      if (!body.style.length) {\n        body.removeAttribute(\"style\");\n      }\n    };\n  },\n  getMousemoveValue(ctx, event) {\n    const win = dom.getWin(ctx);\n    const x = roundToDpr(event.movementX, win.devicePixelRatio);\n    const y = roundToDpr(event.movementY, win.devicePixelRatio);\n    let hint = x > 0 ? \"increment\" : x < 0 ? \"decrement\" : null;\n    if (ctx.isRtl && hint === \"increment\") hint = \"decrement\";\n    if (ctx.isRtl && hint === \"decrement\") hint = \"increment\";\n    const point = {\n      x: ctx.scrubberCursorPoint.x + x,\n      y: ctx.scrubberCursorPoint.y + y\n    };\n    const width = win.innerWidth;\n    const half = roundToDpr(7.5, win.devicePixelRatio);\n    point.x = wrap(point.x + half, width) - half;\n    return {\n      hint,\n      point\n    };\n  },\n  createVirtualCursor(ctx) {\n    const doc = dom.getDoc(ctx);\n    const el = doc.createElement(\"div\");\n    el.className = \"scrubber--cursor\";\n    el.id = dom.getCursorId(ctx);\n    Object.assign(el.style, {\n      width: \"15px\",\n      height: \"15px\",\n      position: \"fixed\",\n      pointerEvents: \"none\",\n      left: \"0px\",\n      top: \"0px\",\n      zIndex: MAX_Z_INDEX,\n      transform: ctx.scrubberCursorPoint ? `translate3d(${ctx.scrubberCursorPoint.x}px, ${ctx.scrubberCursorPoint.y}px, 0px)` : void 0,\n      willChange: \"transform\"\n    });\n    el.innerHTML = `\n        <svg width=\"46\" height=\"15\" style=\"left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);\">\n          <g transform=\"translate(2 3)\">\n            <path fill-rule=\"evenodd\" d=\"M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z\" style=\"stroke-width: 2px; stroke: white;\"></path>\n            <path fill-rule=\"evenodd\" d=\"M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z\"></path>\n          </g>\n        </svg>`;\n    doc.body.appendChild(el);\n  }\n});\n\n// src/number-input.connect.ts\nfunction connect(state, send, normalize) {\n  const focused = state.hasTag(\"focus\");\n  const disabled = state.context.isDisabled;\n  const readOnly = state.context.readOnly;\n  const empty = state.context.isValueEmpty;\n  const invalid = state.context.isOutOfRange || !!state.context.invalid;\n  const isIncrementDisabled = disabled || !state.context.canIncrement || readOnly;\n  const isDecrementDisabled = disabled || !state.context.canDecrement || readOnly;\n  const translations = state.context.translations;\n  return {\n    focused,\n    invalid,\n    empty,\n    value: state.context.formattedValue,\n    valueAsNumber: state.context.valueAsNumber,\n    setValue(value) {\n      send({\n        type: \"VALUE.SET\",\n        value\n      });\n    },\n    clearValue() {\n      send(\"VALUE.CLEAR\");\n    },\n    increment() {\n      send(\"VALUE.INCREMENT\");\n    },\n    decrement() {\n      send(\"VALUE.DECREMENT\");\n    },\n    setToMax() {\n      send({\n        type: \"VALUE.SET\",\n        value: state.context.max\n      });\n    },\n    setToMin() {\n      send({\n        type: \"VALUE.SET\",\n        value: state.context.min\n      });\n    },\n    focus() {\n      dom.getInputEl(state.context)?.focus();\n    },\n    getRootProps() {\n      return normalize.element({\n        id: dom.getRootId(state.context),\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-focus\": dataAttr(focused),\n        \"data-invalid\": dataAttr(invalid)\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-focus\": dataAttr(focused),\n        \"data-invalid\": dataAttr(invalid),\n        id: dom.getLabelId(state.context),\n        htmlFor: dom.getInputId(state.context)\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        dir: state.context.dir,\n        role: \"group\",\n        \"aria-disabled\": disabled,\n        \"data-focus\": dataAttr(focused),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"aria-invalid\": ariaAttr(state.context.invalid)\n      });\n    },\n    getValueTextProps() {\n      return normalize.element({\n        ...parts.valueText.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-focus\": dataAttr(focused)\n      });\n    },\n    getInputProps() {\n      return normalize.input({\n        ...parts.input.attrs,\n        dir: state.context.dir,\n        name: state.context.name,\n        form: state.context.form,\n        id: dom.getInputId(state.context),\n        role: \"spinbutton\",\n        defaultValue: state.context.formattedValue,\n        pattern: state.context.pattern,\n        inputMode: state.context.inputMode,\n        \"aria-invalid\": ariaAttr(invalid),\n        \"data-invalid\": dataAttr(invalid),\n        disabled,\n        \"data-disabled\": dataAttr(disabled),\n        readOnly: state.context.readOnly,\n        required: state.context.required,\n        autoComplete: \"off\",\n        autoCorrect: \"off\",\n        spellCheck: \"false\",\n        type: \"text\",\n        \"aria-roledescription\": \"numberfield\",\n        \"aria-valuemin\": state.context.min,\n        \"aria-valuemax\": state.context.max,\n        \"aria-valuenow\": Number.isNaN(state.context.valueAsNumber) ? void 0 : state.context.valueAsNumber,\n        \"aria-valuetext\": state.context.valueText,\n        onFocus() {\n          send(\"INPUT.FOCUS\");\n        },\n        onBlur() {\n          send(\"INPUT.BLUR\");\n        },\n        onInput(event) {\n          send({\n            type: \"INPUT.CHANGE\",\n            target: event.currentTarget,\n            hint: \"set\"\n          });\n        },\n        onBeforeInput(event) {\n          try {\n            const {\n              selectionStart,\n              selectionEnd,\n              value\n            } = event.currentTarget;\n            const nextValue = value.slice(0, selectionStart) + (event.data ?? \"\") + value.slice(selectionEnd);\n            const isValid = state.context.parser.isValidPartialNumber(nextValue);\n            if (!isValid) {\n              event.preventDefault();\n            }\n          } catch {}\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (readOnly) return;\n          if (isComposingEvent(event)) return;\n          const step = getEventStep(event) * state.context.step;\n          const keyMap = {\n            ArrowUp() {\n              send({\n                type: \"INPUT.ARROW_UP\",\n                step\n              });\n              event.preventDefault();\n            },\n            ArrowDown() {\n              send({\n                type: \"INPUT.ARROW_DOWN\",\n                step\n              });\n              event.preventDefault();\n            },\n            Home() {\n              if (isModifierKey(event)) return;\n              send(\"INPUT.HOME\");\n              event.preventDefault();\n            },\n            End() {\n              if (isModifierKey(event)) return;\n              send(\"INPUT.END\");\n              event.preventDefault();\n            },\n            Enter() {\n              send(\"INPUT.ENTER\");\n            }\n          };\n          const exec = keyMap[event.key];\n          exec?.(event);\n        }\n      });\n    },\n    getDecrementTriggerProps() {\n      return normalize.button({\n        ...parts.decrementTrigger.attrs,\n        dir: state.context.dir,\n        id: dom.getDecrementTriggerId(state.context),\n        disabled: isDecrementDisabled,\n        \"data-disabled\": dataAttr(isDecrementDisabled),\n        \"aria-label\": translations.decrementLabel,\n        type: \"button\",\n        tabIndex: -1,\n        \"aria-controls\": dom.getInputId(state.context),\n        onPointerDown(event) {\n          if (isDecrementDisabled || !isLeftClick(event)) return;\n          send({\n            type: \"TRIGGER.PRESS_DOWN\",\n            hint: \"decrement\",\n            pointerType: event.pointerType\n          });\n          if (event.pointerType === \"mouse\") {\n            event.preventDefault();\n          }\n          if (event.pointerType === \"touch\") {\n            event.currentTarget?.focus({\n              preventScroll: true\n            });\n          }\n        },\n        onPointerUp(event) {\n          send({\n            type: \"TRIGGER.PRESS_UP\",\n            hint: \"decrement\",\n            pointerType: event.pointerType\n          });\n        },\n        onPointerLeave() {\n          if (isDecrementDisabled) return;\n          send({\n            type: \"TRIGGER.PRESS_UP\",\n            hint: \"decrement\"\n          });\n        }\n      });\n    },\n    getIncrementTriggerProps() {\n      return normalize.button({\n        ...parts.incrementTrigger.attrs,\n        dir: state.context.dir,\n        id: dom.getIncrementTriggerId(state.context),\n        disabled: isIncrementDisabled,\n        \"data-disabled\": dataAttr(isIncrementDisabled),\n        \"aria-label\": translations.incrementLabel,\n        type: \"button\",\n        tabIndex: -1,\n        \"aria-controls\": dom.getInputId(state.context),\n        onPointerDown(event) {\n          if (isIncrementDisabled || !isLeftClick(event)) return;\n          send({\n            type: \"TRIGGER.PRESS_DOWN\",\n            hint: \"increment\",\n            pointerType: event.pointerType\n          });\n          if (event.pointerType === \"mouse\") {\n            event.preventDefault();\n          }\n          if (event.pointerType === \"touch\") {\n            event.currentTarget?.focus({\n              preventScroll: true\n            });\n          }\n        },\n        onPointerUp(event) {\n          send({\n            type: \"TRIGGER.PRESS_UP\",\n            hint: \"increment\",\n            pointerType: event.pointerType\n          });\n        },\n        onPointerLeave(event) {\n          send({\n            type: \"TRIGGER.PRESS_UP\",\n            hint: \"increment\",\n            pointerType: event.pointerType\n          });\n        }\n      });\n    },\n    getScrubberProps() {\n      return normalize.element({\n        ...parts.scrubber.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled),\n        id: dom.getScrubberId(state.context),\n        role: \"presentation\",\n        onMouseDown(event) {\n          if (disabled) return;\n          const point = getEventPoint(event);\n          const win = getWindow(event.currentTarget);\n          const dpr = win.devicePixelRatio;\n          point.x = point.x - roundToDpr(7.5, dpr);\n          point.y = point.y - roundToDpr(7.5, dpr);\n          send({\n            type: \"SCRUBBER.PRESS_DOWN\",\n            point\n          });\n          event.preventDefault();\n        },\n        style: {\n          cursor: disabled ? void 0 : \"ew-resize\"\n        }\n      });\n    }\n  };\n}\n\n// src/cursor.ts\nfunction recordCursor(inputEl) {\n  if (inputEl.ownerDocument.activeElement !== inputEl) return;\n  try {\n    const {\n      selectionStart: start,\n      selectionEnd: end,\n      value\n    } = inputEl;\n    const beforeTxt = value.substring(0, start);\n    const afterTxt = value.substring(end);\n    return {\n      start,\n      end,\n      value,\n      beforeTxt,\n      afterTxt\n    };\n  } catch {}\n}\nfunction restoreCursor(inputEl, selection) {\n  if (inputEl.ownerDocument.activeElement !== inputEl) return;\n  if (!selection) {\n    inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);\n    return;\n  }\n  try {\n    const {\n      value\n    } = inputEl;\n    const {\n      beforeTxt = \"\",\n      afterTxt = \"\",\n      start\n    } = selection;\n    let startPos = value.length;\n    if (value.endsWith(afterTxt)) {\n      startPos = value.length - afterTxt.length;\n    } else if (value.startsWith(beforeTxt)) {\n      startPos = beforeTxt.length;\n    } else if (start != null) {\n      const beforeLastChar = beforeTxt[start - 1];\n      const newIndex = value.indexOf(beforeLastChar, start - 1);\n      if (newIndex !== -1) {\n        startPos = newIndex + 1;\n      }\n    }\n    inputEl.setSelectionRange(startPos, startPos);\n  } catch {}\n}\nvar createFormatter = (locale, options = {}) => {\n  return ref(new Intl.NumberFormat(locale, options));\n};\nvar createParser = (locale, options = {}) => {\n  return ref(new NumberParser(locale, options));\n};\nvar parseValue = (ctx, value) => {\n  if (!ctx.formatOptions) return parseFloat(value);\n  return ctx.parser.parse(String(value));\n};\nvar formatValue = (ctx, value) => {\n  if (Number.isNaN(value)) return \"\";\n  if (!ctx.formatOptions) return value.toString();\n  return ctx.formatter.format(value);\n};\n\n// src/number-input.machine.ts\nvar {\n  not,\n  and\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"number-input\",\n    initial: \"idle\",\n    context: {\n      dir: \"ltr\",\n      locale: \"en-US\",\n      focusInputOnChange: true,\n      clampValueOnBlur: true,\n      allowOverflow: false,\n      inputMode: \"decimal\",\n      pattern: \"[0-9]*(.[0-9]+)?\",\n      value: \"\",\n      step: 1,\n      min: Number.MIN_SAFE_INTEGER,\n      max: Number.MAX_SAFE_INTEGER,\n      invalid: false,\n      spinOnPress: true,\n      disabled: false,\n      readOnly: false,\n      ...ctx,\n      hint: null,\n      scrubberCursorPoint: null,\n      fieldsetDisabled: false,\n      formatter: createFormatter(ctx.locale || \"en-US\", ctx.formatOptions),\n      parser: createParser(ctx.locale || \"en-US\", ctx.formatOptions),\n      translations: {\n        incrementLabel: \"increment value\",\n        decrementLabel: \"decrease value\",\n        ...ctx.translations\n      }\n    },\n    computed: {\n      isRtl: ctx2 => ctx2.dir === \"rtl\",\n      valueAsNumber: ctx2 => parseValue(ctx2, ctx2.value),\n      formattedValue: ctx2 => formatValue(ctx2, ctx2.valueAsNumber),\n      isAtMin: ctx2 => isValueAtMin(ctx2.valueAsNumber, ctx2.min),\n      isAtMax: ctx2 => isValueAtMax(ctx2.valueAsNumber, ctx2.max),\n      isOutOfRange: ctx2 => !isValueWithinRange(ctx2.valueAsNumber, ctx2.min, ctx2.max),\n      isValueEmpty: ctx2 => ctx2.value === \"\",\n      isDisabled: ctx2 => !!ctx2.disabled || ctx2.fieldsetDisabled,\n      canIncrement: ctx2 => ctx2.allowOverflow || !ctx2.isAtMax,\n      canDecrement: ctx2 => ctx2.allowOverflow || !ctx2.isAtMin,\n      valueText: ctx2 => ctx2.translations.valueText?.(ctx2.value)\n    },\n    watch: {\n      formatOptions: [\"setFormatterAndParser\", \"syncInputElement\"],\n      locale: [\"setFormatterAndParser\", \"syncInputElement\"],\n      value: [\"syncInputElement\"],\n      isOutOfRange: [\"invokeOnInvalid\"],\n      scrubberCursorPoint: [\"setVirtualCursorPosition\"]\n    },\n    activities: [\"trackFormControl\"],\n    on: {\n      \"VALUE.SET\": {\n        actions: [\"setRawValue\", \"setHintToSet\"]\n      },\n      \"VALUE.CLEAR\": {\n        actions: [\"clearValue\"]\n      },\n      \"VALUE.INCREMENT\": {\n        actions: [\"increment\"]\n      },\n      \"VALUE.DECREMENT\": {\n        actions: [\"decrement\"]\n      }\n    },\n    states: {\n      idle: {\n        on: {\n          \"TRIGGER.PRESS_DOWN\": [{\n            guard: \"isTouchPointer\",\n            target: \"before:spin\",\n            actions: [\"setHint\"]\n          }, {\n            target: \"before:spin\",\n            actions: [\"focusInput\", \"invokeOnFocus\", \"setHint\"]\n          }],\n          \"SCRUBBER.PRESS_DOWN\": {\n            target: \"scrubbing\",\n            actions: [\"focusInput\", \"invokeOnFocus\", \"setHint\", \"setCursorPoint\"]\n          },\n          \"INPUT.FOCUS\": {\n            target: \"focused\",\n            actions: [\"focusInput\", \"invokeOnFocus\"]\n          }\n        }\n      },\n      focused: {\n        tags: \"focus\",\n        activities: \"attachWheelListener\",\n        on: {\n          \"TRIGGER.PRESS_DOWN\": [{\n            guard: \"isTouchPointer\",\n            target: \"before:spin\",\n            actions: [\"setHint\"]\n          }, {\n            target: \"before:spin\",\n            actions: [\"focusInput\", \"setHint\"]\n          }],\n          \"SCRUBBER.PRESS_DOWN\": {\n            target: \"scrubbing\",\n            actions: [\"focusInput\", \"setHint\", \"setCursorPoint\"]\n          },\n          \"INPUT.ARROW_UP\": {\n            actions: \"increment\"\n          },\n          \"INPUT.ARROW_DOWN\": {\n            actions: \"decrement\"\n          },\n          \"INPUT.HOME\": {\n            actions: \"decrementToMin\"\n          },\n          \"INPUT.END\": {\n            actions: \"incrementToMax\"\n          },\n          \"INPUT.CHANGE\": {\n            actions: [\"setValue\", \"setHint\"]\n          },\n          \"INPUT.BLUR\": [{\n            guard: and(\"clampValueOnBlur\", not(\"isInRange\")),\n            target: \"idle\",\n            actions: [\"setClampedValue\", \"clearHint\", \"invokeOnBlur\"]\n          }, {\n            target: \"idle\",\n            actions: [\"setFormattedValue\", \"clearHint\", \"invokeOnBlur\"]\n          }],\n          \"INPUT.ENTER\": {\n            actions: [\"setFormattedValue\", \"clearHint\", \"invokeOnBlur\"]\n          }\n        }\n      },\n      \"before:spin\": {\n        tags: \"focus\",\n        activities: \"trackButtonDisabled\",\n        entry: choose([{\n          guard: \"isIncrementHint\",\n          actions: \"increment\"\n        }, {\n          guard: \"isDecrementHint\",\n          actions: \"decrement\"\n        }]),\n        after: {\n          CHANGE_DELAY: {\n            target: \"spinning\",\n            guard: and(\"isInRange\", \"spinOnPress\")\n          }\n        },\n        on: {\n          \"TRIGGER.PRESS_UP\": [{\n            guard: \"isTouchPointer\",\n            target: \"focused\",\n            actions: \"clearHint\"\n          }, {\n            target: \"focused\",\n            actions: [\"focusInput\", \"clearHint\"]\n          }]\n        }\n      },\n      spinning: {\n        tags: \"focus\",\n        activities: \"trackButtonDisabled\",\n        every: [{\n          delay: \"CHANGE_INTERVAL\",\n          guard: and(not(\"isAtMin\"), \"isIncrementHint\"),\n          actions: \"increment\"\n        }, {\n          delay: \"CHANGE_INTERVAL\",\n          guard: and(not(\"isAtMax\"), \"isDecrementHint\"),\n          actions: \"decrement\"\n        }],\n        on: {\n          \"TRIGGER.PRESS_UP\": {\n            target: \"focused\",\n            actions: [\"focusInput\", \"clearHint\"]\n          }\n        }\n      },\n      scrubbing: {\n        tags: \"focus\",\n        activities: [\"activatePointerLock\", \"trackMousemove\", \"setupVirtualCursor\", \"preventTextSelection\"],\n        on: {\n          \"SCRUBBER.POINTER_UP\": {\n            target: \"focused\",\n            actions: [\"focusInput\", \"clearCursorPoint\"]\n          },\n          \"SCRUBBER.POINTER_MOVE\": [{\n            guard: \"isIncrementHint\",\n            actions: [\"increment\", \"setCursorPoint\"]\n          }, {\n            guard: \"isDecrementHint\",\n            actions: [\"decrement\", \"setCursorPoint\"]\n          }]\n        }\n      }\n    }\n  }, {\n    delays: {\n      CHANGE_INTERVAL: 50,\n      CHANGE_DELAY: 300\n    },\n    guards: {\n      clampValueOnBlur: ctx2 => ctx2.clampValueOnBlur,\n      isAtMin: ctx2 => ctx2.isAtMin,\n      spinOnPress: ctx2 => !!ctx2.spinOnPress,\n      isAtMax: ctx2 => ctx2.isAtMax,\n      isInRange: ctx2 => !ctx2.isOutOfRange,\n      isDecrementHint: (ctx2, evt) => (evt.hint ?? ctx2.hint) === \"decrement\",\n      isIncrementHint: (ctx2, evt) => (evt.hint ?? ctx2.hint) === \"increment\",\n      isTouchPointer: (_ctx, evt) => evt.pointerType === \"touch\"\n    },\n    activities: {\n      trackFormControl(ctx2, _evt, {\n        initialContext\n      }) {\n        const inputEl = dom.getInputEl(ctx2);\n        return trackFormControl(inputEl, {\n          onFieldsetDisabledChange(disabled) {\n            ctx2.fieldsetDisabled = disabled;\n          },\n          onFormReset() {\n            set.value(ctx2, initialContext.value);\n          }\n        });\n      },\n      setupVirtualCursor(ctx2) {\n        return dom.setupVirtualCursor(ctx2);\n      },\n      preventTextSelection(ctx2) {\n        return dom.preventTextSelection(ctx2);\n      },\n      trackButtonDisabled(ctx2, _evt, {\n        send\n      }) {\n        const btn = dom.getPressedTriggerEl(ctx2, ctx2.hint);\n        return observeAttributes(btn, {\n          attributes: [\"disabled\"],\n          callback() {\n            send({\n              type: \"TRIGGER.PRESS_UP\",\n              src: \"attr\"\n            });\n          }\n        });\n      },\n      attachWheelListener(ctx2, _evt, {\n        send\n      }) {\n        const inputEl = dom.getInputEl(ctx2);\n        if (!inputEl || !dom.isActiveElement(ctx2, inputEl) || !ctx2.allowMouseWheel) return;\n        function onWheel(event) {\n          event.preventDefault();\n          const dir = Math.sign(event.deltaY) * -1;\n          if (dir === 1) {\n            send(\"VALUE.INCREMENT\");\n          } else if (dir === -1) {\n            send(\"VALUE.DECREMENT\");\n          }\n        }\n        return addDomEvent(inputEl, \"wheel\", onWheel, {\n          passive: false\n        });\n      },\n      activatePointerLock(ctx2) {\n        if (isSafari()) return;\n        return requestPointerLock(dom.getDoc(ctx2));\n      },\n      trackMousemove(ctx2, _evt, {\n        send\n      }) {\n        const doc = dom.getDoc(ctx2);\n        function onMousemove(event) {\n          if (!ctx2.scrubberCursorPoint) return;\n          const value = dom.getMousemoveValue(ctx2, event);\n          if (!value.hint) return;\n          send({\n            type: \"SCRUBBER.POINTER_MOVE\",\n            hint: value.hint,\n            point: value.point\n          });\n        }\n        function onMouseup() {\n          send(\"SCRUBBER.POINTER_UP\");\n        }\n        return callAll(addDomEvent(doc, \"mousemove\", onMousemove, false), addDomEvent(doc, \"mouseup\", onMouseup, false));\n      }\n    },\n    actions: {\n      focusInput(ctx2) {\n        if (!ctx2.focusInputOnChange) return;\n        const inputEl = dom.getInputEl(ctx2);\n        if (dom.isActiveElement(ctx2, inputEl)) return;\n        raf(() => inputEl?.focus({\n          preventScroll: true\n        }));\n      },\n      increment(ctx2, evt) {\n        const nextValue = incrementValue(ctx2.valueAsNumber, evt.step ?? ctx2.step);\n        const value = formatValue(ctx2, clampValue(nextValue, ctx2.min, ctx2.max));\n        set.value(ctx2, value);\n      },\n      decrement(ctx2, evt) {\n        const nextValue = decrementValue(ctx2.valueAsNumber, evt.step ?? ctx2.step);\n        const value = formatValue(ctx2, clampValue(nextValue, ctx2.min, ctx2.max));\n        set.value(ctx2, value);\n      },\n      setClampedValue(ctx2) {\n        const nextValue = clampValue(ctx2.valueAsNumber, ctx2.min, ctx2.max);\n        set.value(ctx2, formatValue(ctx2, nextValue));\n      },\n      setRawValue(ctx2, evt) {\n        const parsedValue = parseValue(ctx2, evt.value);\n        const value = formatValue(ctx2, clampValue(parsedValue, ctx2.min, ctx2.max));\n        set.value(ctx2, value);\n      },\n      setValue(ctx2, evt) {\n        const value = evt.target?.value ?? evt.value;\n        set.value(ctx2, value);\n      },\n      clearValue(ctx2) {\n        set.value(ctx2, \"\");\n      },\n      incrementToMax(ctx2) {\n        const value = formatValue(ctx2, ctx2.max);\n        set.value(ctx2, value);\n      },\n      decrementToMin(ctx2) {\n        const value = formatValue(ctx2, ctx2.min);\n        set.value(ctx2, value);\n      },\n      setHint(ctx2, evt) {\n        ctx2.hint = evt.hint;\n      },\n      clearHint(ctx2) {\n        ctx2.hint = null;\n      },\n      setHintToSet(ctx2) {\n        ctx2.hint = \"set\";\n      },\n      invokeOnFocus(ctx2) {\n        ctx2.onFocusChange?.({\n          focused: true,\n          value: ctx2.formattedValue,\n          valueAsNumber: ctx2.valueAsNumber\n        });\n      },\n      invokeOnBlur(ctx2) {\n        ctx2.onFocusChange?.({\n          focused: false,\n          value: ctx2.formattedValue,\n          valueAsNumber: ctx2.valueAsNumber\n        });\n      },\n      invokeOnInvalid(ctx2) {\n        if (!ctx2.isOutOfRange) return;\n        const reason = ctx2.valueAsNumber > ctx2.max ? \"rangeOverflow\" : \"rangeUnderflow\";\n        ctx2.onValueInvalid?.({\n          reason,\n          value: ctx2.formattedValue,\n          valueAsNumber: ctx2.valueAsNumber\n        });\n      },\n      syncInputElement(ctx2, evt) {\n        const value = evt.type.endsWith(\"CHANGE\") ? ctx2.value : ctx2.formattedValue;\n        sync.input(ctx2, value);\n      },\n      setFormattedValue(ctx2) {\n        set.value(ctx2, ctx2.formattedValue);\n      },\n      setCursorPoint(ctx2, evt) {\n        ctx2.scrubberCursorPoint = evt.point;\n      },\n      clearCursorPoint(ctx2) {\n        ctx2.scrubberCursorPoint = null;\n      },\n      setVirtualCursorPosition(ctx2) {\n        const cursorEl = dom.getCursorEl(ctx2);\n        if (!cursorEl || !ctx2.scrubberCursorPoint) return;\n        const {\n          x,\n          y\n        } = ctx2.scrubberCursorPoint;\n        cursorEl.style.transform = `translate3d(${x}px, ${y}px, 0px)`;\n      },\n      setFormatterAndParser(ctx2) {\n        if (!ctx2.locale) return;\n        ctx2.formatter = createFormatter(ctx2.locale, ctx2.formatOptions);\n        ctx2.parser = createParser(ctx2.locale, ctx2.formatOptions);\n      }\n    },\n    compareFns: {\n      formatOptions: (a, b) => isEqual(a, b),\n      scrubberCursorPoint: (a, b) => isEqual(a, b)\n    }\n  });\n}\nvar sync = {\n  input(ctx, value) {\n    const inputEl = dom.getInputEl(ctx);\n    if (!inputEl) return;\n    const sel = recordCursor(inputEl);\n    raf(() => {\n      setElementValue(inputEl, value);\n      restoreCursor(inputEl, sel);\n    });\n  }\n};\nvar invoke = {\n  onChange: ctx => {\n    ctx.onValueChange?.({\n      value: ctx.value,\n      valueAsNumber: ctx.valueAsNumber\n    });\n  }\n};\nvar set = {\n  value: (ctx, value) => {\n    if (isEqual(ctx.value, value)) return;\n    ctx.value = value;\n    invoke.onChange(ctx);\n  }\n};\nexport { anatomy, connect, machine };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, dataAttr, getEventTarget, visuallyHiddenStyle, trackPress, trackFormControl, dispatchInputCheckedEvent } from '@zag-js/dom-query';\nimport { isFocusVisible, trackFocusVisible } from '@zag-js/focus-visible';\nimport { createMachine, guards } from '@zag-js/core';\nimport { createSplitProps, compact, isEqual } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/switch.anatomy.ts\nvar anatomy = createAnatomy(\"switch\").parts(\"root\", \"label\", \"control\", \"thumb\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `switch:${ctx.id}`,\n  getLabelId: ctx => ctx.ids?.label ?? `switch:${ctx.id}:label`,\n  getThumbId: ctx => ctx.ids?.thumb ?? `switch:${ctx.id}:thumb`,\n  getControlId: ctx => ctx.ids?.control ?? `switch:${ctx.id}:control`,\n  getHiddenInputId: ctx => ctx.ids?.hiddenInput ?? `switch:${ctx.id}:input`,\n  getRootEl: ctx => dom.getById(ctx, dom.getRootId(ctx)),\n  getHiddenInputEl: ctx => dom.getById(ctx, dom.getHiddenInputId(ctx))\n});\n\n// src/switch.connect.ts\nfunction connect(state, send, normalize) {\n  const disabled = state.context.isDisabled;\n  const readOnly = state.context.readOnly;\n  const checked = state.context.checked;\n  const focused = !disabled && state.context.focused;\n  const focusVisible = !disabled && state.context.focusVisible;\n  const dataAttrs = {\n    \"data-active\": dataAttr(state.context.active),\n    \"data-focus\": dataAttr(focused),\n    \"data-focus-visible\": dataAttr(focusVisible),\n    \"data-readonly\": dataAttr(readOnly),\n    \"data-hover\": dataAttr(state.context.hovered),\n    \"data-disabled\": dataAttr(disabled),\n    \"data-state\": state.context.checked ? \"checked\" : \"unchecked\",\n    \"data-invalid\": dataAttr(state.context.invalid)\n  };\n  return {\n    checked,\n    disabled,\n    focused,\n    setChecked(checked2) {\n      send({\n        type: \"CHECKED.SET\",\n        checked: checked2,\n        isTrusted: false\n      });\n    },\n    toggleChecked() {\n      send({\n        type: \"CHECKED.TOGGLE\",\n        checked,\n        isTrusted: false\n      });\n    },\n    getRootProps() {\n      return normalize.label({\n        ...parts.root.attrs,\n        ...dataAttrs,\n        dir: state.context.dir,\n        id: dom.getRootId(state.context),\n        htmlFor: dom.getHiddenInputId(state.context),\n        onPointerMove() {\n          if (disabled) return;\n          send({\n            type: \"CONTEXT.SET\",\n            context: {\n              hovered: true\n            }\n          });\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send({\n            type: \"CONTEXT.SET\",\n            context: {\n              hovered: false\n            }\n          });\n        },\n        onClick(event) {\n          if (disabled) return;\n          const target = getEventTarget(event);\n          if (target === dom.getHiddenInputEl(state.context)) {\n            event.stopPropagation();\n          }\n        }\n      });\n    },\n    getLabelProps() {\n      return normalize.element({\n        ...parts.label.attrs,\n        ...dataAttrs,\n        dir: state.context.dir,\n        id: dom.getLabelId(state.context)\n      });\n    },\n    getThumbProps() {\n      return normalize.element({\n        ...parts.thumb.attrs,\n        ...dataAttrs,\n        dir: state.context.dir,\n        id: dom.getThumbId(state.context),\n        \"aria-hidden\": true\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        ...dataAttrs,\n        dir: state.context.dir,\n        id: dom.getControlId(state.context),\n        \"aria-hidden\": true\n      });\n    },\n    getHiddenInputProps() {\n      return normalize.input({\n        id: dom.getHiddenInputId(state.context),\n        type: \"checkbox\",\n        required: state.context.required,\n        defaultChecked: checked,\n        disabled,\n        \"aria-labelledby\": dom.getLabelId(state.context),\n        \"aria-invalid\": state.context.invalid,\n        name: state.context.name,\n        form: state.context.form,\n        value: state.context.value,\n        style: visuallyHiddenStyle,\n        onFocus() {\n          const focusVisible2 = isFocusVisible();\n          send({\n            type: \"CONTEXT.SET\",\n            context: {\n              focused: true,\n              focusVisible: focusVisible2\n            }\n          });\n        },\n        onBlur() {\n          send({\n            type: \"CONTEXT.SET\",\n            context: {\n              focused: false,\n              focusVisible: false\n            }\n          });\n        },\n        onClick(event) {\n          if (readOnly) {\n            event.preventDefault();\n            return;\n          }\n          const checked2 = event.currentTarget.checked;\n          send({\n            type: \"CHECKED.SET\",\n            checked: checked2,\n            isTrusted: true\n          });\n        }\n      });\n    }\n  };\n}\nvar {\n  not\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"switch\",\n    initial: \"ready\",\n    context: {\n      checked: false,\n      label: \"switch\",\n      value: \"on\",\n      disabled: false,\n      ...ctx,\n      fieldsetDisabled: false,\n      focusVisible: false\n    },\n    computed: {\n      isDisabled: ctx2 => ctx2.disabled || ctx2.fieldsetDisabled\n    },\n    watch: {\n      disabled: \"removeFocusIfNeeded\",\n      checked: \"syncInputElement\"\n    },\n    activities: [\"trackFormControlState\", \"trackPressEvent\", \"trackFocusVisible\"],\n    on: {\n      \"CHECKED.TOGGLE\": [{\n        guard: not(\"isTrusted\"),\n        actions: [\"toggleChecked\", \"dispatchChangeEvent\"]\n      }, {\n        actions: [\"toggleChecked\"]\n      }],\n      \"CHECKED.SET\": [{\n        guard: not(\"isTrusted\"),\n        actions: [\"setChecked\", \"dispatchChangeEvent\"]\n      }, {\n        actions: [\"setChecked\"]\n      }],\n      \"CONTEXT.SET\": {\n        actions: [\"setContext\"]\n      }\n    },\n    states: {\n      ready: {}\n    }\n  }, {\n    guards: {\n      isTrusted: (_ctx, evt) => !!evt.isTrusted\n    },\n    activities: {\n      trackPressEvent(ctx2) {\n        if (ctx2.isDisabled) return;\n        return trackPress({\n          pointerNode: dom.getRootEl(ctx2),\n          keyboardNode: dom.getHiddenInputEl(ctx2),\n          isValidKey: event => event.key === \" \",\n          onPress: () => ctx2.active = false,\n          onPressStart: () => ctx2.active = true,\n          onPressEnd: () => ctx2.active = false\n        });\n      },\n      trackFocusVisible(ctx2) {\n        if (ctx2.isDisabled) return;\n        return trackFocusVisible({\n          root: dom.getRootNode(ctx2)\n        });\n      },\n      trackFormControlState(ctx2, _evt, {\n        send,\n        initialContext\n      }) {\n        return trackFormControl(dom.getHiddenInputEl(ctx2), {\n          onFieldsetDisabledChange(disabled) {\n            ctx2.fieldsetDisabled = disabled;\n          },\n          onFormReset() {\n            send({\n              type: \"CHECKED.SET\",\n              checked: !!initialContext.checked,\n              src: \"form-reset\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      setContext(ctx2, evt) {\n        Object.assign(ctx2, evt.context);\n      },\n      syncInputElement(ctx2) {\n        const inputEl = dom.getHiddenInputEl(ctx2);\n        if (!inputEl) return;\n        inputEl.checked = !!ctx2.checked;\n      },\n      removeFocusIfNeeded(ctx2) {\n        if (ctx2.disabled && ctx2.focused) {\n          ctx2.focused = false;\n        }\n      },\n      setChecked(ctx2, evt) {\n        set.checked(ctx2, evt.checked);\n      },\n      toggleChecked(ctx2, _evt) {\n        set.checked(ctx2, !ctx2.checked);\n      },\n      dispatchChangeEvent(ctx2) {\n        const inputEl = dom.getHiddenInputEl(ctx2);\n        dispatchInputCheckedEvent(inputEl, {\n          checked: ctx2.checked\n        });\n      }\n    }\n  });\n}\nvar invoke = {\n  change: ctx => {\n    ctx.onCheckedChange?.({\n      checked: ctx.checked\n    });\n  }\n};\nvar set = {\n  checked: (ctx, checked) => {\n    if (isEqual(ctx.checked, checked)) return;\n    ctx.checked = checked;\n    invoke.change(ctx);\n  }\n};\nvar props = createProps()([\"checked\", \"dir\", \"disabled\", \"form\", \"getRootNode\", \"id\", \"ids\", \"invalid\", \"label\", \"name\", \"onCheckedChange\", \"readOnly\", \"required\", \"value\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, query, queryAll, dataAttr, isComposingEvent, getEventKey, ariaAttr, raf } from '@zag-js/dom-query';\nimport { getPlacementStyles, getPlacement } from '@zag-js/popper';\nimport { Time } from '@internationalized/date';\nimport { createMachine, guards } from '@zag-js/core';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { createSplitProps, compact, match, prev, next, isEqual } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/time-picker.anatomy.ts\nvar anatomy = createAnatomy(\"time-picker\").parts(\"cell\", \"clearTrigger\", \"column\", \"content\", \"control\", \"input\", \"label\", \"positioner\", \"root\", \"spacer\", \"trigger\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getContentId: ctx => ctx.ids?.content ?? `time-picker:${ctx.id}:content`,\n  getColumnId: (ctx, unit) => ctx.ids?.column?.(unit) ?? `time-picker:${ctx.id}:column:${unit}`,\n  getControlId: ctx => ctx.ids?.control ?? `time-picker:${ctx.id}:control`,\n  getClearTriggerId: ctx => ctx.ids?.clearTrigger ?? `time-picker:${ctx.id}:clear-trigger`,\n  getPositionerId: ctx => ctx.ids?.positioner ?? `time-picker:${ctx.id}:positioner`,\n  getInputId: ctx => ctx.ids?.input ?? `time-picker:${ctx.id}:input`,\n  getTriggerId: ctx => ctx.ids?.trigger ?? `time-picker:${ctx.id}:trigger`,\n  getContentEl: ctx => dom.getById(ctx, dom.getContentId(ctx)),\n  getColumnEl: (ctx, unit) => query(dom.getContentEl(ctx), `[data-part=column][data-unit=${unit}]`),\n  getColumnEls: ctx => queryAll(dom.getContentEl(ctx), `[data-part=column]:not([hidden])`),\n  getColumnCellEls: (ctx, unit) => queryAll(dom.getColumnEl(ctx, unit), `[data-part=cell]`),\n  getControlEl: ctx => dom.getById(ctx, dom.getControlId(ctx)),\n  getClearTriggerEl: ctx => dom.getById(ctx, dom.getClearTriggerId(ctx)),\n  getPositionerEl: ctx => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getInputEl: ctx => dom.getById(ctx, dom.getInputId(ctx)),\n  getTriggerEl: ctx => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getFocusedCell: ctx => query(dom.getContentEl(ctx), `[data-part=cell][data-focus]`),\n  getInitialFocusCell: (ctx, unit) => {\n    const contentEl = dom.getContentEl(ctx);\n    let cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}][aria-current]`);\n    cellEl || (cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}][data-now]`));\n    cellEl || (cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}]`));\n    return cellEl;\n  },\n  getColumnUnit: el => el.dataset.unit,\n  getCellValue: el => {\n    const value = el?.dataset.value;\n    return el?.dataset.unit === \"period\" ? value : Number(value ?? \"0\");\n  }\n});\nfunction getCurrentTime() {\n  const now = /* @__PURE__ */new Date();\n  return new Time(now.getHours(), now.getMinutes(), now.getSeconds());\n}\nvar padStart = value => value.toString().padStart(2, \"0\");\nfunction getStringifiedValue(ctx) {\n  if (!ctx.value) return \"\";\n  let hourValue = ctx.value.hour;\n  if (ctx.hour12 && hourValue === 0) {\n    hourValue = 12;\n  } else if (ctx.hour12 && hourValue > 12) {\n    hourValue -= 12;\n  }\n  let result = `${padStart(hourValue)}:${padStart(ctx.value.minute)}`;\n  if (ctx.allowSeconds) {\n    const second = padStart(ctx.value.second);\n    result += `:${second}`;\n  }\n  if (ctx.hour12 && ctx.period) {\n    result += ` ${ctx.period.toUpperCase()}`;\n  }\n  return result;\n}\nvar TIME_REX = /(\\d{1,2}):(\\d{1,2})(?::(\\d{1,2}))?\\s?(AM|PM|am|pm)?/;\nfunction getTimeValue(ctx, value) {\n  const match2 = value.match(TIME_REX);\n  if (!match2) return;\n  let [, hourString, minuteString, secondString, periodString] = match2;\n  let hour = parseInt(hourString);\n  const minute = parseInt(minuteString);\n  const second = secondString ? parseInt(secondString) : void 0;\n  if (!is12HourFormat(ctx.locale) && ctx.period) {\n    return {\n      time: new Time(hour, minute, second),\n      period: ctx.period\n    };\n  }\n  let period = periodString ? periodString.toLowerCase() : \"am\";\n  if (hour > 11) {\n    period = \"pm\";\n  } else if (period === \"pm\") {\n    hour += 12;\n  }\n  return {\n    time: new Time(hour, minute, second),\n    period\n  };\n}\nfunction get12HourFormatPeriodHour(hour, period) {\n  if (!period) return hour;\n  return period === \"pm\" ? hour + 12 : hour;\n}\nfunction getHourPeriod(hour, locale) {\n  if (hour === void 0 || !is12HourFormat(locale)) return null;\n  return hour > 11 ? \"pm\" : \"am\";\n}\nfunction is12HourFormat(locale) {\n  return new Intl.DateTimeFormat(locale, {\n    hour: \"numeric\"\n  }).formatToParts(/* @__PURE__ */new Date()).some(part => part.type === \"dayPeriod\");\n}\nfunction getInputPlaceholder(ctx) {\n  if (ctx.placeholder) return ctx.placeholder;\n  const secondsPart = ctx.allowSeconds ? \":ss\" : \"\";\n  const periodPart = is12HourFormat(ctx.locale) ? \" aa\" : \"\";\n  return `hh:mm${secondsPart}${periodPart}`;\n}\nfunction clampTime(value, min, max) {\n  let time = value;\n  if (min && min.compare(value) > 0) {\n    time = min.copy();\n  } else if (max && max.compare(value) < 0) {\n    time = max.copy();\n  }\n  return time;\n}\n\n// src/time-picker.connect.ts\nfunction connect(state, send, normalize) {\n  const disabled = state.context.disabled;\n  const readOnly = state.context.readOnly;\n  const locale = state.context.locale;\n  const hour12 = is12HourFormat(locale);\n  const min = state.context.min;\n  const max = state.context.max;\n  const steps = state.context.steps;\n  const focused = state.matches(\"focused\");\n  const open = state.hasTag(\"open\");\n  const value = state.context.value;\n  const valueAsString = state.context.valueAsString;\n  const currentTime = state.context.currentTime;\n  const currentPlacement = state.context.currentPlacement;\n  const popperStyles = getPlacementStyles({\n    ...state.context.positioning,\n    placement: state.context.currentPlacement\n  });\n  return {\n    focused,\n    open,\n    value,\n    valueAsString,\n    hour12,\n    reposition(options = {}) {\n      send({\n        type: \"POSITIONING.SET\",\n        options\n      });\n    },\n    setOpen(nextOpen) {\n      if (nextOpen === open) return;\n      send(nextOpen ? \"OPEN\" : \"CLOSE\");\n    },\n    setUnitValue(unit, value2) {\n      send({\n        type: \"UNIT.SET\",\n        unit,\n        value: value2\n      });\n    },\n    setValue(value2) {\n      send({\n        type: \"VALUE.SET\",\n        value: value2\n      });\n    },\n    clearValue() {\n      send(\"VALUE.CLEAR\");\n    },\n    getHours() {\n      const length = hour12 ? 12 : 24;\n      const arr = Array.from({\n        length\n      }, (_, i) => i);\n      const step = steps?.hour;\n      const hours = step != null ? arr.filter(hour => hour % step === 0) : arr;\n      return hours.map(value2 => ({\n        label: hour12 && value2 === 0 ? \"12\" : padStart(value2),\n        value: value2\n      }));\n    },\n    getMinutes() {\n      const arr = Array.from({\n        length: 60\n      }, (_, i) => i);\n      const step = steps?.minute;\n      const minutes = step != null ? arr.filter(minute => minute % step === 0) : arr;\n      return minutes.map(value2 => ({\n        label: padStart(value2),\n        value: value2\n      }));\n    },\n    getSeconds() {\n      const arr = Array.from({\n        length: 60\n      }, (_, i) => i);\n      const step = steps?.second;\n      const seconds = step != null ? arr.filter(second => second % step === 0) : arr;\n      return seconds.map(value2 => ({\n        label: padStart(value2),\n        value: value2\n      }));\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(readOnly)\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        dir: state.context.dir,\n        htmlFor: dom.getInputId(state.context),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(readOnly)\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        dir: state.context.dir,\n        id: dom.getControlId(state.context),\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getInputProps() {\n      return normalize.input({\n        ...parts.input.attrs,\n        dir: state.context.dir,\n        autoComplete: \"off\",\n        autoCorrect: \"off\",\n        spellCheck: \"false\",\n        id: dom.getInputId(state.context),\n        name: state.context.name,\n        defaultValue: valueAsString,\n        placeholder: getInputPlaceholder(state.context),\n        disabled,\n        readOnly,\n        onFocus() {\n          send(\"INPUT.FOCUS\");\n        },\n        onBlur(event) {\n          send({\n            type: \"INPUT.BLUR\",\n            value: event.currentTarget.value\n          });\n        },\n        onKeyDown(event) {\n          if (isComposingEvent(event)) return;\n          if (event.key !== \"Enter\") return;\n          send({\n            type: \"INPUT.ENTER\",\n            value: event.currentTarget.value\n          });\n          event.preventDefault();\n        }\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        id: dom.getTriggerId(state.context),\n        type: \"button\",\n        \"data-placement\": state.context.currentPlacement,\n        disabled,\n        \"data-readonly\": dataAttr(readOnly),\n        \"aria-label\": open ? \"Close calendar\" : \"Open calendar\",\n        \"aria-controls\": dom.getContentId(state.context),\n        \"data-state\": open ? \"open\" : \"closed\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send(\"TRIGGER.CLICK\");\n        }\n      });\n    },\n    getClearTriggerProps() {\n      return normalize.button({\n        ...parts.clearTrigger.attrs,\n        id: dom.getClearTriggerId(state.context),\n        type: \"button\",\n        hidden: !state.context.value,\n        disabled,\n        \"data-readonly\": dataAttr(readOnly),\n        \"aria-label\": \"Clear time\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send(\"VALUE.CLEAR\");\n        }\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        ...parts.positioner.attrs,\n        dir: state.context.dir,\n        id: dom.getPositionerId(state.context),\n        style: popperStyles.floating\n      });\n    },\n    getSpacerProps() {\n      return normalize.element({\n        ...parts.spacer.attrs\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: state.context.dir,\n        id: dom.getContentId(state.context),\n        hidden: !open,\n        tabIndex: 0,\n        role: \"application\",\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-placement\": currentPlacement,\n        \"aria-roledescription\": \"timepicker\",\n        \"aria-label\": \"timepicker\",\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (isComposingEvent(event)) return;\n          const keyMap = {\n            ArrowUp() {\n              send({\n                type: \"CONTENT.ARROW_UP\"\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"CONTENT.ARROW_DOWN\"\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"CONTENT.ARROW_LEFT\"\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"CONTENT.ARROW_RIGHT\"\n              });\n            },\n            Enter() {\n              send({\n                type: \"CONTENT.ENTER\"\n              });\n            },\n            // prevent tabbing out of the time picker\n            Tab() {},\n            Escape() {\n              if (!state.context.disableLayer) return;\n              send({\n                type: \"CONTENT.ESCAPE\"\n              });\n            }\n          };\n          const exec = keyMap[getEventKey(event, state.context)];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    getColumnProps(props2) {\n      const hidden = props2.unit === \"second\" && !state.context.allowSeconds || props2.unit === \"period\" && !hour12;\n      return normalize.element({\n        ...parts.column.attrs,\n        id: dom.getColumnId(state.context, props2.unit),\n        \"data-unit\": props2.unit,\n        \"data-focus\": dataAttr(state.context.focusedColumn === props2.unit),\n        hidden\n      });\n    },\n    getHourCellProps(props2) {\n      const hour = props2.value;\n      const isSelectable = !(min && get12HourFormatPeriodHour(hour, state.context.period) < min.hour || max && get12HourFormatPeriodHour(hour, state.context.period) > max.hour);\n      const isSelected = state.context.value?.hour === get12HourFormatPeriodHour(hour, state.context.period);\n      const isFocused = state.context.focusedColumn === \"hour\" && state.context.focusedValue === hour;\n      const currentHour = hour12 && currentTime ? currentTime?.hour % 12 : currentTime?.hour;\n      const isCurrent = currentHour === hour || hour === 12 && currentHour === 0;\n      return normalize.button({\n        ...parts.cell.attrs,\n        type: \"button\",\n        \"aria-disabled\": ariaAttr(!isSelectable),\n        \"data-disabled\": dataAttr(!isSelectable),\n        \"aria-current\": ariaAttr(isSelected),\n        \"data-selected\": dataAttr(isSelected),\n        \"data-now\": dataAttr(isCurrent),\n        \"data-focus\": dataAttr(isFocused),\n        \"aria-label\": `${hour} hours`,\n        \"data-value\": hour,\n        \"data-unit\": \"hour\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!isSelectable) return;\n          send({\n            type: \"UNIT.CLICK\",\n            unit: \"hour\",\n            value: hour\n          });\n        }\n      });\n    },\n    getMinuteCellProps(props2) {\n      const minute = props2.value;\n      const {\n        value: value2\n      } = state.context;\n      const minMinute = min?.set({\n        second: 0\n      });\n      const maxMinute = max?.set({\n        second: 0\n      });\n      const isSelectable = !(minMinute && value2 && minMinute.compare(value2.set({\n        minute\n      })) > 0 || maxMinute && value2 && maxMinute.compare(value2.set({\n        minute\n      })) < 0);\n      const isSelected = state.context.value?.minute === minute;\n      const isCurrent = currentTime?.minute === minute;\n      const isFocused = state.context.focusedColumn === \"minute\" && state.context.focusedValue === minute;\n      return normalize.button({\n        ...parts.cell.attrs,\n        type: \"button\",\n        \"aria-disabled\": ariaAttr(!isSelectable),\n        \"data-disabled\": dataAttr(!isSelectable),\n        \"aria-current\": ariaAttr(isSelected),\n        \"data-selected\": dataAttr(isSelected),\n        \"aria-label\": `${minute} minutes`,\n        \"data-value\": minute,\n        \"data-now\": dataAttr(isCurrent),\n        \"data-focus\": dataAttr(isFocused),\n        \"data-unit\": \"minute\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!isSelectable) return;\n          send({\n            type: \"UNIT.CLICK\",\n            unit: \"minute\",\n            value: minute\n          });\n        }\n      });\n    },\n    getSecondCellProps(props2) {\n      const second = props2.value;\n      const isSelectable = !(min && value?.minute && min.compare(value.set({\n        second\n      })) > 0 || max && value?.minute && max.compare(value.set({\n        second\n      })) < 0);\n      const isSelected = state.context.value?.second === second;\n      const isCurrent = currentTime?.second === second;\n      const isFocused = state.context.focusedColumn === \"second\" && state.context.focusedValue === second;\n      return normalize.button({\n        ...parts.cell.attrs,\n        type: \"button\",\n        \"aria-disabled\": ariaAttr(!isSelectable),\n        \"data-disabled\": dataAttr(!isSelectable),\n        \"aria-current\": ariaAttr(isSelected),\n        \"data-selected\": dataAttr(isSelected),\n        \"aria-label\": `${second} seconds`,\n        \"data-value\": second,\n        \"data-unit\": \"second\",\n        \"data-focus\": dataAttr(isFocused),\n        \"data-now\": dataAttr(isCurrent),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!isSelectable) return;\n          send({\n            type: \"UNIT.CLICK\",\n            unit: \"second\",\n            value: second\n          });\n        }\n      });\n    },\n    getPeriodCellProps(props2) {\n      const isSelected = state.context.period === props2.value;\n      const currentPeriod = getHourPeriod(currentTime?.hour, state.context.locale);\n      const isCurrent = currentPeriod === props2.value;\n      const isFocused = state.context.focusedColumn === \"period\" && state.context.focusedValue === props2.value;\n      return normalize.button({\n        ...parts.cell.attrs,\n        type: \"button\",\n        \"aria-current\": ariaAttr(isSelected),\n        \"data-selected\": dataAttr(isSelected),\n        \"data-focus\": dataAttr(isFocused),\n        \"data-now\": dataAttr(isCurrent),\n        \"aria-label\": props2.value,\n        \"data-value\": props2.value,\n        \"data-unit\": \"period\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"UNIT.CLICK\",\n            unit: \"period\",\n            value: props2.value\n          });\n        }\n      });\n    }\n  };\n}\nvar {\n  and\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"time-picker\",\n    initial: ctx.open ? \"open\" : \"idle\",\n    context: {\n      value: null,\n      locale: \"en-US\",\n      ...ctx,\n      focusedColumn: \"hour\",\n      focusedValue: null,\n      currentTime: null,\n      positioning: {\n        placement: \"bottom-start\",\n        gutter: 8,\n        ...ctx.positioning\n      }\n    },\n    computed: {\n      valueAsString: ctx2 => getStringifiedValue(ctx2),\n      hour12: ctx2 => is12HourFormat(ctx2.locale),\n      period: ctx2 => getHourPeriod(ctx2.value?.hour, ctx2.locale)\n    },\n    watch: {\n      open: [\"toggleVisibility\"],\n      value: [\"syncInputElement\"],\n      period: [\"syncInputElement\"],\n      focusedColumn: [\"syncFocusedValue\"],\n      focusedValue: [\"focusCell\"]\n    },\n    on: {\n      \"VALUE.CLEAR\": {\n        actions: [\"clearValue\"]\n      },\n      \"VALUE.SET\": {\n        actions: [\"setValue\"]\n      },\n      \"UNIT.SET\": {\n        actions: [\"setUnitValue\"]\n      }\n    },\n    states: {\n      idle: {\n        tags: [\"closed\"],\n        on: {\n          \"INPUT.FOCUS\": {\n            target: \"focused\"\n          },\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\"]\n          }],\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\"]\n          }],\n          \"CONTROLLED.OPEN\": {\n            target: \"open\",\n            actions: [\"invokeOnOpen\"]\n          }\n        }\n      },\n      focused: {\n        tags: [\"closed\"],\n        on: {\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\"]\n          }],\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\"]\n          }],\n          \"INPUT.ENTER\": {\n            actions: [\"setInputValue\", \"clampTimeValue\"]\n          },\n          \"INPUT.BLUR\": {\n            target: \"idle\",\n            actions: [\"setInputValue\", \"clampTimeValue\"]\n          },\n          \"CONTROLLED.OPEN\": {\n            target: \"open\",\n            actions: [\"invokeOnOpen\"]\n          }\n        }\n      },\n      open: {\n        tags: [\"open\"],\n        entry: [\"setCurrentTime\", \"scrollColumnsToTop\", \"focusHourColumn\"],\n        exit: [\"resetFocusedCell\"],\n        activities: [\"computePlacement\", \"trackDismissableElement\"],\n        on: {\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"focused\",\n            actions: [\"invokeOnClose\"]\n          }],\n          \"INPUT.ENTER\": {\n            actions: [\"setInputValue\", \"clampTimeValue\"]\n          },\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"idle\",\n            actions: [\"invokeOnClose\"]\n          }],\n          \"CONTROLLED.CLOSE\": [{\n            guard: and(\"shouldRestoreFocus\", \"isInteractOutsideEvent\"),\n            target: \"focused\",\n            actions: [\"focusTriggerElement\"]\n          }, {\n            guard: \"shouldRestoreFocus\",\n            target: \"focused\",\n            actions: [\"focusInputElement\"]\n          }, {\n            target: \"idle\"\n          }],\n          \"CONTENT.ESCAPE\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"focused\",\n            actions: [\"invokeOnClose\", \"focusInputElement\"]\n          }],\n          INTERACT_OUTSIDE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            guard: \"shouldRestoreFocus\",\n            target: \"focused\",\n            actions: [\"invokeOnClose\", \"focusTriggerElement\"]\n          }, {\n            target: \"idle\",\n            actions: [\"invokeOnClose\"]\n          }],\n          \"POSITIONING.SET\": {\n            actions: [\"reposition\"]\n          },\n          \"UNIT.CLICK\": {\n            actions: [\"setFocusedValue\", \"setFocusedColumn\", \"setUnitValue\"]\n          },\n          \"CONTENT.ARROW_UP\": {\n            actions: [\"focusPreviousCell\"]\n          },\n          \"CONTENT.ARROW_DOWN\": {\n            actions: [\"focusNextCell\"]\n          },\n          \"CONTENT.ARROW_LEFT\": {\n            actions: [\"focusPreviousColumnCell\"]\n          },\n          \"CONTENT.ARROW_RIGHT\": {\n            actions: [\"focusNextColumnCell\"]\n          },\n          \"CONTENT.ENTER\": {\n            actions: [\"selectFocusedCell\", \"focusNextColumnCell\"]\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      shouldRestoreFocus: ctx2 => !!ctx2.restoreFocus,\n      isOpenControlled: ctx2 => !!ctx2[\"open.controlled\"],\n      isInteractOutsideEvent: (_ctx, evt) => evt.previousEvent?.type === \"INTERACT_OUTSIDE\"\n    },\n    activities: {\n      computePlacement(ctx2) {\n        ctx2.currentPlacement = ctx2.positioning.placement;\n        const anchorEl = () => dom.getControlEl(ctx2);\n        const positionerEl = () => dom.getPositionerEl(ctx2);\n        return getPlacement(anchorEl, positionerEl, {\n          defer: true,\n          ...ctx2.positioning,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      trackDismissableElement(ctx2, _evt, {\n        send\n      }) {\n        if (ctx2.disableLayer) return;\n        return trackDismissableElement(dom.getContentEl(ctx2), {\n          defer: true,\n          exclude: [dom.getTriggerEl(ctx2), dom.getClearTriggerEl(ctx2)],\n          onEscapeKeyDown(event) {\n            event.preventDefault();\n            ctx2.restoreFocus = true;\n            send({\n              type: \"CONTENT.ESCAPE\"\n            });\n          },\n          onInteractOutside(event) {\n            ctx2.restoreFocus = !event.detail.focusable;\n          },\n          onDismiss() {\n            send({\n              type: \"INTERACT_OUTSIDE\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      reposition(ctx2, evt) {\n        const positionerEl = () => dom.getPositionerEl(ctx2);\n        getPlacement(dom.getTriggerEl(ctx2), positionerEl, {\n          ...ctx2.positioning,\n          ...evt.options,\n          defer: true,\n          listeners: false,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      toggleVisibility(ctx2, evt, {\n        send\n      }) {\n        send({\n          type: ctx2.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: evt\n        });\n      },\n      invokeOnOpen(ctx2) {\n        ctx2.onOpenChange?.({\n          open: true\n        });\n      },\n      invokeOnClose(ctx2) {\n        ctx2.onOpenChange?.({\n          open: false\n        });\n      },\n      setInputValue(ctx2, evt) {\n        const timeValue = getTimeValue(ctx2, evt.value);\n        if (!timeValue) return;\n        set.value(ctx2, timeValue.time);\n      },\n      syncInputElement(ctx2) {\n        const inputEl = dom.getInputEl(ctx2);\n        if (!inputEl) return;\n        inputEl.value = ctx2.valueAsString;\n      },\n      setUnitValue(ctx2, evt) {\n        const {\n          unit,\n          value\n        } = evt;\n        const current = ctx2.value ?? ctx2.currentTime ?? new Time(0);\n        const nextTime = match(unit, {\n          hour: () => current.set({\n            hour: ctx2.hour12 ? value + 12 : value\n          }),\n          minute: () => current.set({\n            minute: value\n          }),\n          second: () => current.set({\n            second: value\n          }),\n          period: () => {\n            if (!ctx2.value) return;\n            const diff = value === \"pm\" ? 12 : 0;\n            return ctx2.value.set({\n              hour: ctx2.value.hour % 12 + diff\n            });\n          }\n        });\n        if (!nextTime) return;\n        set.value(ctx2, nextTime);\n      },\n      setValue(ctx2, evt) {\n        if (!(evt.value instanceof Time)) return;\n        set.value(ctx2, evt.value);\n      },\n      clearValue(ctx2) {\n        set.value(ctx2, null);\n      },\n      setFocusedValue(ctx2, evt) {\n        set.focusedValue(ctx2, evt.value);\n      },\n      setFocusedColumn(ctx2, evt) {\n        set.focusedColumn(ctx2, evt.unit);\n      },\n      resetFocusedCell(ctx2) {\n        set.focusedColumn(ctx2, \"hour\");\n        set.focusedValue(ctx2, null);\n      },\n      clampTimeValue(ctx2) {\n        if (!ctx2.value) return;\n        const nextTime = clampTime(ctx2.value, ctx2.min, ctx2.max);\n        set.value(ctx2, nextTime);\n      },\n      setCurrentTime(ctx2) {\n        ctx2.currentTime = getCurrentTime();\n      },\n      scrollColumnsToTop(ctx2) {\n        raf(() => {\n          const columnEls = dom.getColumnEls(ctx2);\n          for (const columnEl of columnEls) {\n            const cellEl = dom.getInitialFocusCell(ctx2, columnEl.dataset.unit);\n            if (!cellEl) continue;\n            columnEl.scrollTop = cellEl.offsetTop - 4;\n          }\n        });\n      },\n      focusTriggerElement(ctx2) {\n        dom.getTriggerEl(ctx2)?.focus({\n          preventScroll: true\n        });\n      },\n      focusInputElement(ctx2) {\n        dom.getInputEl(ctx2)?.focus({\n          preventScroll: true\n        });\n      },\n      focusHourColumn(ctx2) {\n        raf(() => {\n          const hourEl = dom.getInitialFocusCell(ctx2, \"hour\");\n          if (!hourEl) return;\n          set.focusedValue(ctx2, dom.getCellValue(hourEl));\n        });\n      },\n      focusPreviousCell(ctx2) {\n        raf(() => {\n          const cells = dom.getColumnCellEls(ctx2, ctx2.focusedColumn);\n          const focusedEl = dom.getFocusedCell(ctx2);\n          const focusedIndex = focusedEl ? cells.indexOf(focusedEl) : -1;\n          const prevCell = prev(cells, focusedIndex, {\n            loop: false\n          });\n          if (!prevCell) return;\n          set.focusedValue(ctx2, dom.getCellValue(prevCell));\n        });\n      },\n      focusNextCell(ctx2) {\n        raf(() => {\n          const cells = dom.getColumnCellEls(ctx2, ctx2.focusedColumn);\n          const focusedEl = dom.getFocusedCell(ctx2);\n          const focusedIndex = focusedEl ? cells.indexOf(focusedEl) : -1;\n          const nextCell = next(cells, focusedIndex, {\n            loop: false\n          });\n          if (!nextCell) return;\n          set.focusedValue(ctx2, dom.getCellValue(nextCell));\n        });\n      },\n      selectFocusedCell(ctx2) {\n        const current = ctx2.value ?? ctx2.currentTime ?? new Time(0);\n        let value = ctx2.focusedValue;\n        let column = ctx2.focusedColumn;\n        if (column === \"hour\" && ctx2.hour12) {\n          value = ctx2.hour12 ? value + 12 : value;\n        } else if (ctx2.focusedColumn === \"period\") {\n          column = \"hour\";\n          const diff = value === \"pm\" ? 12 : 0;\n          value = current.hour % 12 + diff;\n        }\n        const nextTime = current.set({\n          [column]: value\n        });\n        set.value(ctx2, nextTime);\n      },\n      focusPreviousColumnCell(ctx2) {\n        raf(() => {\n          const columns = dom.getColumnEls(ctx2);\n          const currentColumnEl = dom.getColumnEl(ctx2, ctx2.focusedColumn);\n          const focusedIndex = columns.indexOf(currentColumnEl);\n          const prevColumnEl = prev(columns, focusedIndex, {\n            loop: false\n          });\n          if (!prevColumnEl) return;\n          set.focusedColumn(ctx2, dom.getColumnUnit(prevColumnEl));\n        });\n      },\n      focusNextColumnCell(ctx2) {\n        raf(() => {\n          const columns = dom.getColumnEls(ctx2);\n          const currentColumnEl = dom.getColumnEl(ctx2, ctx2.focusedColumn);\n          const focusedIndex = columns.indexOf(currentColumnEl);\n          const nextColumnEl = next(columns, focusedIndex, {\n            loop: false\n          });\n          if (!nextColumnEl) return;\n          set.focusedColumn(ctx2, dom.getColumnUnit(nextColumnEl));\n        });\n      },\n      focusCell(ctx2) {\n        queueMicrotask(() => {\n          const cellEl = dom.getFocusedCell(ctx2);\n          cellEl?.focus();\n        });\n      },\n      syncFocusedValue(ctx2) {\n        if (ctx2.focusedValue === null) return;\n        queueMicrotask(() => {\n          const cellEl = dom.getInitialFocusCell(ctx2, ctx2.focusedColumn);\n          set.focusedValue(ctx2, dom.getCellValue(cellEl));\n        });\n      }\n    },\n    compareFns: {\n      value: isTimeEqual\n    }\n  });\n}\nvar isTimeEqual = (a, b) => {\n  return a?.toString() === b?.toString();\n};\nvar invoke = {\n  change(ctx) {\n    ctx.onValueChange?.({\n      value: ctx.value,\n      valueAsString: ctx.valueAsString\n    });\n  },\n  focusChange(ctx) {\n    ctx.onFocusChange?.({\n      value: ctx.value,\n      valueAsString: ctx.valueAsString,\n      focusedValue: ctx.focusedValue,\n      focusedUnit: ctx.focusedColumn\n    });\n  }\n};\nvar set = {\n  value(ctx, value) {\n    if (isTimeEqual(ctx.value, value)) return;\n    ctx.value = value;\n    invoke.change(ctx);\n  },\n  focusedValue(ctx, value) {\n    if (isEqual(ctx.focusedValue, value)) return;\n    ctx.focusedValue = value;\n    invoke.focusChange(ctx);\n  },\n  focusedColumn(ctx, column) {\n    if (ctx.focusedColumn === column) return;\n    ctx.focusedColumn = column;\n  }\n};\nfunction parse(value) {\n  return new Time(value.hour, value.minute, value.second, value.millisecond);\n}\nvar props = createProps()([\"dir\", \"disabled\", \"disableLayer\", \"getRootNode\", \"id\", \"ids\", \"locale\", \"max\", \"min\", \"name\", \"onFocusChange\", \"onOpenChange\", \"onValueChange\", \"open.controlled\", \"open\", \"placeholder\", \"positioning\", \"readOnly\", \"steps\", \"value\", \"allowSeconds\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, parse, props, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
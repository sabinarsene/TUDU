{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, queryAll, dataAttr, visuallyHiddenStyle, trackFormControl, nextTick, dispatchInputCheckedEvent } from '@zag-js/dom-query';\nimport { isFocusVisible, trackFocusVisible } from '@zag-js/focus-visible';\nimport { createMachine, guards } from '@zag-js/core';\nimport { trackElementRect } from '@zag-js/element-rect';\nimport { createSplitProps, compact, isString, isEqual } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/radio-group.anatomy.ts\nvar anatomy = createAnatomy(\"radio-group\").parts(\"root\", \"label\", \"item\", \"itemText\", \"itemControl\", \"indicator\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `radio-group:${ctx.id}`,\n  getLabelId: ctx => ctx.ids?.label ?? `radio-group:${ctx.id}:label`,\n  getItemId: (ctx, value) => ctx.ids?.item?.(value) ?? `radio-group:${ctx.id}:radio:${value}`,\n  getItemHiddenInputId: (ctx, value) => ctx.ids?.itemHiddenInput?.(value) ?? `radio-group:${ctx.id}:radio:input:${value}`,\n  getItemControlId: (ctx, value) => ctx.ids?.itemControl?.(value) ?? `radio-group:${ctx.id}:radio:control:${value}`,\n  getItemLabelId: (ctx, value) => ctx.ids?.itemLabel?.(value) ?? `radio-group:${ctx.id}:radio:label:${value}`,\n  getIndicatorId: ctx => ctx.ids?.indicator ?? `radio-group:${ctx.id}:indicator`,\n  getRootEl: ctx => dom.getById(ctx, dom.getRootId(ctx)),\n  getItemHiddenInputEl: (ctx, value) => dom.getById(ctx, dom.getItemHiddenInputId(ctx, value)),\n  getIndicatorEl: ctx => dom.getById(ctx, dom.getIndicatorId(ctx)),\n  getFirstEnabledInputEl: ctx => dom.getRootEl(ctx)?.querySelector(\"input:not(:disabled)\"),\n  getFirstEnabledAndCheckedInputEl: ctx => dom.getRootEl(ctx)?.querySelector(\"input:not(:disabled):checked\"),\n  getInputEls: ctx => {\n    const ownerId = CSS.escape(dom.getRootId(ctx));\n    const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;\n    return queryAll(dom.getRootEl(ctx), selector);\n  },\n  getActiveRadioEl: ctx => {\n    if (!ctx.value) return;\n    return dom.getById(ctx, dom.getItemId(ctx, ctx.value));\n  },\n  getOffsetRect: el => ({\n    left: el?.offsetLeft ?? 0,\n    top: el?.offsetTop ?? 0,\n    width: el?.offsetWidth ?? 0,\n    height: el?.offsetHeight ?? 0\n  }),\n  getRectById: (ctx, id) => {\n    const radioEl = dom.getById(ctx, dom.getItemId(ctx, id));\n    if (!radioEl) return;\n    return dom.resolveRect(dom.getOffsetRect(radioEl));\n  },\n  resolveRect: rect => ({\n    width: `${rect.width}px`,\n    height: `${rect.height}px`,\n    left: `${rect.left}px`,\n    top: `${rect.top}px`\n  })\n});\n\n// src/radio-group.connect.ts\nfunction connect(state, send, normalize) {\n  const groupDisabled = state.context.isDisabled;\n  const readOnly = state.context.readOnly;\n  function getItemState(props2) {\n    return {\n      invalid: !!props2.invalid,\n      disabled: !!props2.disabled || groupDisabled,\n      checked: state.context.value === props2.value,\n      focused: state.context.focusedValue === props2.value,\n      hovered: state.context.hoveredValue === props2.value,\n      active: state.context.activeValue === props2.value\n    };\n  }\n  function getItemDataAttrs(props2) {\n    const radioState = getItemState(props2);\n    return {\n      \"data-focus\": dataAttr(radioState.focused),\n      \"data-focus-visible\": dataAttr(radioState.focused && state.context.focusVisible),\n      \"data-disabled\": dataAttr(radioState.disabled),\n      \"data-readonly\": dataAttr(readOnly),\n      \"data-state\": radioState.checked ? \"checked\" : \"unchecked\",\n      \"data-hover\": dataAttr(radioState.hovered),\n      \"data-invalid\": dataAttr(radioState.invalid),\n      \"data-orientation\": state.context.orientation,\n      \"data-ssr\": dataAttr(state.context.ssr)\n    };\n  }\n  const focus = () => {\n    const firstEnabledAndCheckedInput = dom.getFirstEnabledAndCheckedInputEl(state.context);\n    if (firstEnabledAndCheckedInput) {\n      firstEnabledAndCheckedInput.focus();\n      return;\n    }\n    const firstEnabledInput = dom.getFirstEnabledInputEl(state.context);\n    firstEnabledInput?.focus();\n  };\n  return {\n    focus,\n    value: state.context.value,\n    setValue(value) {\n      send({\n        type: \"SET_VALUE\",\n        value,\n        isTrusted: false\n      });\n    },\n    clearValue() {\n      send({\n        type: \"SET_VALUE\",\n        value: null,\n        isTrusted: false\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        role: \"radiogroup\",\n        id: dom.getRootId(state.context),\n        \"aria-labelledby\": dom.getLabelId(state.context),\n        \"data-orientation\": state.context.orientation,\n        \"data-disabled\": dataAttr(groupDisabled),\n        \"aria-orientation\": state.context.orientation,\n        dir: state.context.dir,\n        style: {\n          position: \"relative\"\n        }\n      });\n    },\n    getLabelProps() {\n      return normalize.element({\n        ...parts.label.attrs,\n        dir: state.context.dir,\n        \"data-orientation\": state.context.orientation,\n        \"data-disabled\": dataAttr(groupDisabled),\n        id: dom.getLabelId(state.context),\n        onClick: focus\n      });\n    },\n    getItemState,\n    getItemProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.label({\n        ...parts.item.attrs,\n        dir: state.context.dir,\n        id: dom.getItemId(state.context, props2.value),\n        htmlFor: dom.getItemHiddenInputId(state.context, props2.value),\n        ...getItemDataAttrs(props2),\n        onPointerMove() {\n          if (itemState.disabled) return;\n          if (itemState.hovered) return;\n          send({\n            type: \"SET_HOVERED\",\n            value: props2.value,\n            hovered: true\n          });\n        },\n        onPointerLeave() {\n          if (itemState.disabled) return;\n          send({\n            type: \"SET_HOVERED\",\n            value: null\n          });\n        },\n        onPointerDown(event) {\n          if (itemState.disabled) return;\n          if (itemState.focused && event.pointerType === \"mouse\") {\n            event.preventDefault();\n          }\n          send({\n            type: \"SET_ACTIVE\",\n            value: props2.value,\n            active: true\n          });\n        },\n        onPointerUp() {\n          if (itemState.disabled) return;\n          send({\n            type: \"SET_ACTIVE\",\n            value: null\n          });\n        }\n      });\n    },\n    getItemTextProps(props2) {\n      return normalize.element({\n        ...parts.itemText.attrs,\n        dir: state.context.dir,\n        id: dom.getItemLabelId(state.context, props2.value),\n        ...getItemDataAttrs(props2)\n      });\n    },\n    getItemControlProps(props2) {\n      const controlState = getItemState(props2);\n      return normalize.element({\n        ...parts.itemControl.attrs,\n        dir: state.context.dir,\n        id: dom.getItemControlId(state.context, props2.value),\n        \"data-active\": dataAttr(controlState.active),\n        \"aria-hidden\": true,\n        ...getItemDataAttrs(props2)\n      });\n    },\n    getItemHiddenInputProps(props2) {\n      const inputState = getItemState(props2);\n      return normalize.input({\n        \"data-ownedby\": dom.getRootId(state.context),\n        id: dom.getItemHiddenInputId(state.context, props2.value),\n        type: \"radio\",\n        name: state.context.name || state.context.id,\n        form: state.context.form,\n        value: props2.value,\n        onClick(event) {\n          if (readOnly) {\n            event.preventDefault();\n            return;\n          }\n          if (event.currentTarget.checked) {\n            send({\n              type: \"SET_VALUE\",\n              value: props2.value,\n              isTrusted: true\n            });\n          }\n        },\n        onBlur() {\n          send({\n            type: \"SET_FOCUSED\",\n            value: null,\n            focused: false,\n            focusVisible: false\n          });\n        },\n        onFocus() {\n          const focusVisible = isFocusVisible();\n          send({\n            type: \"SET_FOCUSED\",\n            value: props2.value,\n            focused: true,\n            focusVisible\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (event.key === \" \") {\n            send({\n              type: \"SET_ACTIVE\",\n              value: props2.value,\n              active: true\n            });\n          }\n        },\n        onKeyUp(event) {\n          if (event.defaultPrevented) return;\n          if (event.key === \" \") {\n            send({\n              type: \"SET_ACTIVE\",\n              value: null\n            });\n          }\n        },\n        disabled: inputState.disabled,\n        defaultChecked: inputState.checked,\n        style: visuallyHiddenStyle\n      });\n    },\n    getIndicatorProps() {\n      return normalize.element({\n        id: dom.getIndicatorId(state.context),\n        ...parts.indicator.attrs,\n        dir: state.context.dir,\n        hidden: state.context.value == null,\n        \"data-disabled\": dataAttr(groupDisabled),\n        \"data-orientation\": state.context.orientation,\n        style: {\n          \"--transition-property\": \"left, top, width, height\",\n          \"--left\": state.context.indicatorRect?.left,\n          \"--top\": state.context.indicatorRect?.top,\n          \"--width\": state.context.indicatorRect?.width,\n          \"--height\": state.context.indicatorRect?.height,\n          position: \"absolute\",\n          willChange: \"var(--transition-property)\",\n          transitionProperty: \"var(--transition-property)\",\n          transitionDuration: state.context.canIndicatorTransition ? \"var(--transition-duration, 150ms)\" : \"0ms\",\n          transitionTimingFunction: \"var(--transition-timing-function)\",\n          [state.context.orientation === \"horizontal\" ? \"left\" : \"top\"]: state.context.orientation === \"horizontal\" ? \"var(--left)\" : \"var(--top)\"\n        }\n      });\n    }\n  };\n}\nvar {\n  not\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"radio\",\n    initial: \"idle\",\n    context: {\n      value: null,\n      activeValue: null,\n      focusedValue: null,\n      hoveredValue: null,\n      disabled: false,\n      orientation: \"vertical\",\n      ...ctx,\n      indicatorRect: {},\n      canIndicatorTransition: false,\n      fieldsetDisabled: false,\n      focusVisible: false,\n      ssr: true\n    },\n    computed: {\n      isDisabled: ctx2 => !!ctx2.disabled || ctx2.fieldsetDisabled\n    },\n    entry: [\"syncIndicatorRect\", \"syncSsr\"],\n    exit: [\"cleanupObserver\"],\n    activities: [\"trackFormControlState\", \"trackFocusVisible\"],\n    watch: {\n      value: [\"setIndicatorTransition\", \"syncIndicatorRect\", \"syncInputElements\"]\n    },\n    on: {\n      SET_VALUE: [{\n        guard: not(\"isTrusted\"),\n        actions: [\"setValue\", \"dispatchChangeEvent\"]\n      }, {\n        actions: [\"setValue\"]\n      }],\n      SET_HOVERED: {\n        actions: \"setHovered\"\n      },\n      SET_ACTIVE: {\n        actions: \"setActive\"\n      },\n      SET_FOCUSED: {\n        actions: \"setFocused\"\n      }\n    },\n    states: {\n      idle: {}\n    }\n  }, {\n    guards: {\n      isTrusted: (_ctx, evt) => !!evt.isTrusted\n    },\n    activities: {\n      trackFormControlState(ctx2, _evt, {\n        send,\n        initialContext\n      }) {\n        return trackFormControl(dom.getRootEl(ctx2), {\n          onFieldsetDisabledChange(disabled) {\n            ctx2.fieldsetDisabled = disabled;\n          },\n          onFormReset() {\n            send({\n              type: \"SET_VALUE\",\n              value: initialContext.value\n            });\n          }\n        });\n      },\n      trackFocusVisible(ctx2) {\n        return trackFocusVisible({\n          root: dom.getRootNode(ctx2)\n        });\n      }\n    },\n    actions: {\n      setValue(ctx2, evt) {\n        set.value(ctx2, evt.value);\n      },\n      setHovered(ctx2, evt) {\n        ctx2.hoveredValue = evt.value;\n      },\n      setActive(ctx2, evt) {\n        ctx2.activeValue = evt.value;\n      },\n      setFocused(ctx2, evt) {\n        ctx2.focusedValue = evt.value;\n        ctx2.focusVisible = evt.focusVisible;\n      },\n      syncInputElements(ctx2) {\n        const inputs = dom.getInputEls(ctx2);\n        inputs.forEach(input => {\n          input.checked = input.value === ctx2.value;\n        });\n      },\n      setIndicatorTransition(ctx2) {\n        ctx2.canIndicatorTransition = isString(ctx2.value);\n      },\n      cleanupObserver(ctx2) {\n        ctx2.indicatorCleanup?.();\n      },\n      syncSsr(ctx2) {\n        ctx2.ssr = false;\n      },\n      syncIndicatorRect(ctx2) {\n        ctx2.indicatorCleanup?.();\n        if (!dom.getIndicatorEl(ctx2)) return;\n        const value = ctx2.value;\n        const radioEl = dom.getActiveRadioEl(ctx2);\n        if (value == null || !radioEl) {\n          ctx2.indicatorRect = {};\n          return;\n        }\n        ctx2.indicatorCleanup = trackElementRect(radioEl, {\n          getRect(el) {\n            return dom.getOffsetRect(el);\n          },\n          onChange(rect) {\n            ctx2.indicatorRect = dom.resolveRect(rect);\n            nextTick(() => {\n              ctx2.canIndicatorTransition = false;\n            });\n          }\n        });\n      },\n      dispatchChangeEvent(ctx2) {\n        const inputEls = dom.getInputEls(ctx2);\n        inputEls.forEach(inputEl => {\n          const checked = inputEl.value === ctx2.value;\n          if (checked === inputEl.checked) return;\n          dispatchInputCheckedEvent(inputEl, {\n            checked\n          });\n        });\n      }\n    }\n  });\n}\nvar invoke = {\n  change: ctx => {\n    if (ctx.value == null) return;\n    ctx.onValueChange?.({\n      value: ctx.value\n    });\n  }\n};\nvar set = {\n  value: (ctx, value) => {\n    if (isEqual(ctx.value, value)) return;\n    ctx.value = value;\n    invoke.change(ctx);\n  }\n};\nvar props = createProps()([\"dir\", \"disabled\", \"form\", \"getRootNode\", \"id\", \"ids\", \"name\", \"onValueChange\", \"orientation\", \"readOnly\", \"value\"]);\nvar splitProps = createSplitProps(props);\nvar itemProps = createProps()([\"value\", \"disabled\", \"invalid\"]);\nvar splitItemProps = createSplitProps(itemProps);\nexport { anatomy, connect, itemProps, machine, props, splitItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
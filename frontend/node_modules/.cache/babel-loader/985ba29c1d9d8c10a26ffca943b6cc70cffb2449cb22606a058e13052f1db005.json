{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, dataAttr, ariaAttr, isComposingEvent, contains, raf, isApple } from '@zag-js/dom-query';\nimport { createMachine } from '@zag-js/core';\nimport { trackInteractOutside } from '@zag-js/interact-outside';\nimport { createSplitProps, compact, isEqual } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/editable.anatomy.ts\nvar anatomy = createAnatomy(\"editable\").parts(\"root\", \"area\", \"label\", \"preview\", \"input\", \"editTrigger\", \"submitTrigger\", \"cancelTrigger\", \"control\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `editable:${ctx.id}`,\n  getAreaId: ctx => ctx.ids?.area ?? `editable:${ctx.id}:area`,\n  getLabelId: ctx => ctx.ids?.label ?? `editable:${ctx.id}:label`,\n  getPreviewId: ctx => ctx.ids?.preview ?? `editable:${ctx.id}:preview`,\n  getInputId: ctx => ctx.ids?.input ?? `editable:${ctx.id}:input`,\n  getControlId: ctx => ctx.ids?.control ?? `editable:${ctx.id}:control`,\n  getSubmitTriggerId: ctx => ctx.ids?.submitTrigger ?? `editable:${ctx.id}:submit`,\n  getCancelTriggerId: ctx => ctx.ids?.cancelTrigger ?? `editable:${ctx.id}:cancel`,\n  getEditTriggerId: ctx => ctx.ids?.editTrigger ?? `editable:${ctx.id}:edit`,\n  getInputEl: ctx => dom.getById(ctx, dom.getInputId(ctx)),\n  getPreviewEl: ctx => dom.getById(ctx, dom.getPreviewId(ctx)),\n  getSubmitTriggerEl: ctx => dom.getById(ctx, dom.getSubmitTriggerId(ctx)),\n  getCancelTriggerEl: ctx => dom.getById(ctx, dom.getCancelTriggerId(ctx)),\n  getEditTriggerEl: ctx => dom.getById(ctx, dom.getEditTriggerId(ctx))\n});\n\n// src/editable.connect.ts\nfunction connect(state, send, normalize) {\n  const disabled = state.context.disabled;\n  const interactive = state.context.isInteractive;\n  const readOnly = state.context.readOnly;\n  const invalid = state.context.invalid;\n  const autoResize = state.context.autoResize;\n  const translations = state.context.translations;\n  const editing = state.matches(\"edit\");\n  const placeholderProp = state.context.placeholder;\n  const placeholder = typeof placeholderProp === \"string\" ? {\n    edit: placeholderProp,\n    preview: placeholderProp\n  } : placeholderProp;\n  const value = state.context.value;\n  const empty = value.trim() === \"\";\n  const valueText = empty ? placeholder?.preview ?? \"\" : value;\n  return {\n    editing,\n    empty,\n    value,\n    valueText,\n    setValue(value2) {\n      send({\n        type: \"VALUE.SET\",\n        value: value2,\n        src: \"setValue\"\n      });\n    },\n    clearValue() {\n      send({\n        type: \"VALUE.SET\",\n        value: \"\",\n        src: \"clearValue\"\n      });\n    },\n    edit() {\n      if (!interactive) return;\n      send(\"EDIT\");\n    },\n    cancel() {\n      if (!interactive) return;\n      send(\"CANCEL\");\n    },\n    submit() {\n      if (!interactive) return;\n      send(\"SUBMIT\");\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: dom.getRootId(state.context),\n        dir: state.context.dir\n      });\n    },\n    getAreaProps() {\n      return normalize.element({\n        ...parts.area.attrs,\n        id: dom.getAreaId(state.context),\n        dir: state.context.dir,\n        style: autoResize ? {\n          display: \"inline-grid\"\n        } : void 0,\n        \"data-focus\": dataAttr(editing),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-placeholder-shown\": dataAttr(empty)\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        id: dom.getLabelId(state.context),\n        dir: state.context.dir,\n        htmlFor: dom.getInputId(state.context),\n        \"data-focus\": dataAttr(editing),\n        \"data-invalid\": dataAttr(invalid),\n        onClick() {\n          if (editing) return;\n          const previewEl = dom.getPreviewEl(state.context);\n          previewEl?.focus({\n            preventScroll: true\n          });\n        }\n      });\n    },\n    getInputProps() {\n      return normalize.input({\n        ...parts.input.attrs,\n        dir: state.context.dir,\n        \"aria-label\": translations.input,\n        name: state.context.name,\n        form: state.context.form,\n        id: dom.getInputId(state.context),\n        hidden: autoResize ? void 0 : !editing,\n        placeholder: placeholder?.edit,\n        maxLength: state.context.maxLength,\n        required: state.context.required,\n        disabled,\n        \"data-disabled\": dataAttr(disabled),\n        readOnly,\n        \"data-readonly\": dataAttr(readOnly),\n        \"aria-invalid\": ariaAttr(invalid),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-autoresize\": dataAttr(autoResize),\n        defaultValue: value,\n        size: autoResize ? 1 : void 0,\n        onChange(event) {\n          send({\n            type: \"VALUE.SET\",\n            src: \"input.change\",\n            value: event.currentTarget.value\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (isComposingEvent(event)) return;\n          const keyMap = {\n            Escape() {\n              send(\"CANCEL\");\n              event.preventDefault();\n            },\n            Enter(event2) {\n              if (!state.context.submitOnEnter) return;\n              const {\n                localName\n              } = event2.currentTarget;\n              if (localName === \"textarea\") {\n                const submitMod = isApple() ? event2.metaKey : event2.ctrlKey;\n                if (!submitMod) return;\n                send({\n                  type: \"SUBMIT\",\n                  src: \"keydown.enter\"\n                });\n                return;\n              }\n              if (localName === \"input\" && !event2.shiftKey && !event2.metaKey) {\n                send({\n                  type: \"SUBMIT\",\n                  src: \"keydown.enter\"\n                });\n                event2.preventDefault();\n              }\n            }\n          };\n          const exec = keyMap[event.key];\n          if (exec) {\n            exec(event);\n          }\n        },\n        style: autoResize ? {\n          gridArea: \"1 / 1 / auto / auto\",\n          visibility: !editing ? \"hidden\" : void 0\n        } : void 0\n      });\n    },\n    getPreviewProps() {\n      return normalize.element({\n        id: dom.getPreviewId(state.context),\n        ...parts.preview.attrs,\n        dir: state.context.dir,\n        \"data-placeholder-shown\": dataAttr(empty),\n        \"aria-readonly\": ariaAttr(readOnly),\n        \"data-readonly\": dataAttr(disabled),\n        \"data-disabled\": dataAttr(disabled),\n        \"aria-disabled\": ariaAttr(disabled),\n        \"aria-invalid\": ariaAttr(invalid),\n        \"data-invalid\": dataAttr(invalid),\n        \"aria-label\": translations.edit,\n        \"data-autoresize\": dataAttr(autoResize),\n        children: valueText,\n        hidden: autoResize ? void 0 : editing,\n        tabIndex: interactive ? 0 : void 0,\n        onClick() {\n          if (!interactive) return;\n          if (state.context.activationMode !== \"click\") return;\n          send({\n            type: \"EDIT\",\n            src: \"click\"\n          });\n        },\n        onFocus() {\n          if (!interactive) return;\n          if (state.context.activationMode !== \"focus\") return;\n          send({\n            type: \"EDIT\",\n            src: \"focus\"\n          });\n        },\n        onDoubleClick(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          if (state.context.activationMode !== \"dblclick\") return;\n          send({\n            type: \"EDIT\",\n            src: \"dblclick\"\n          });\n        },\n        style: autoResize ? {\n          whiteSpace: \"pre\",\n          userSelect: \"none\",\n          gridArea: \"1 / 1 / auto / auto\",\n          visibility: editing ? \"hidden\" : void 0,\n          // in event the preview overflow's the parent element\n          overflow: \"hidden\",\n          textOverflow: \"ellipsis\"\n        } : void 0\n      });\n    },\n    getEditTriggerProps() {\n      return normalize.button({\n        ...parts.editTrigger.attrs,\n        id: dom.getEditTriggerId(state.context),\n        dir: state.context.dir,\n        \"aria-label\": translations.edit,\n        hidden: editing,\n        type: \"button\",\n        disabled,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          send({\n            type: \"EDIT\",\n            src: \"edit.click\"\n          });\n        }\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        id: dom.getControlId(state.context),\n        ...parts.control.attrs,\n        dir: state.context.dir\n      });\n    },\n    getSubmitTriggerProps() {\n      return normalize.button({\n        ...parts.submitTrigger.attrs,\n        dir: state.context.dir,\n        id: dom.getSubmitTriggerId(state.context),\n        \"aria-label\": translations.submit,\n        hidden: !editing,\n        disabled,\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          send({\n            type: \"SUBMIT\",\n            src: \"submit.click\"\n          });\n        }\n      });\n    },\n    getCancelTriggerProps() {\n      return normalize.button({\n        ...parts.cancelTrigger.attrs,\n        dir: state.context.dir,\n        \"aria-label\": translations.cancel,\n        id: dom.getCancelTriggerId(state.context),\n        hidden: !editing,\n        type: \"button\",\n        disabled,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          send({\n            type: \"CANCEL\",\n            src: \"cancel.click\"\n          });\n        }\n      });\n    }\n  };\n}\nvar submitOnEnter = ctx => [\"both\", \"enter\"].includes(ctx.submitMode);\nvar submitOnBlur = ctx => [\"both\", \"blur\"].includes(ctx.submitMode);\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"editable\",\n    initial: ctx.edit ? \"edit\" : \"preview\",\n    entry: ctx.edit ? [\"focusInput\"] : void 0,\n    context: {\n      activationMode: \"focus\",\n      submitMode: \"both\",\n      value: \"\",\n      previousValue: \"\",\n      selectOnFocus: true,\n      disabled: false,\n      readOnly: false,\n      ...ctx,\n      translations: {\n        input: \"editable input\",\n        edit: \"edit\",\n        submit: \"submit\",\n        cancel: \"cancel\",\n        ...ctx.translations\n      }\n    },\n    watch: {\n      value: [\"syncInputValue\"],\n      edit: [\"toggleEditing\"]\n    },\n    computed: {\n      submitOnEnter,\n      submitOnBlur,\n      isInteractive: ctx2 => !(ctx2.disabled || ctx2.readOnly)\n    },\n    on: {\n      \"VALUE.SET\": {\n        actions: \"setValue\"\n      }\n    },\n    states: {\n      preview: {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=559561\n        entry: [\"blurInputIfNeeded\"],\n        on: {\n          \"CONTROLLED.EDIT\": {\n            target: \"edit\",\n            actions: [\"setPreviousValue\", \"focusInput\"]\n          },\n          EDIT: [{\n            guard: \"isEditControlled\",\n            actions: [\"invokeOnEdit\"]\n          }, {\n            target: \"edit\",\n            actions: [\"setPreviousValue\", \"focusInput\", \"invokeOnEdit\"]\n          }]\n        }\n      },\n      edit: {\n        activities: [\"trackInteractOutside\"],\n        on: {\n          \"CONTROLLED.PREVIEW\": [{\n            guard: \"isSubmitEvent\",\n            target: \"preview\",\n            actions: [\"setPreviousValue\", \"restoreFocus\", \"invokeOnSubmit\"]\n          }, {\n            target: \"preview\",\n            actions: [\"revertValue\", \"restoreFocus\", \"invokeOnCancel\"]\n          }],\n          CANCEL: [{\n            guard: \"isEditControlled\",\n            actions: [\"invokeOnPreview\"]\n          }, {\n            target: \"preview\",\n            actions: [\"revertValue\", \"restoreFocus\", \"invokeOnCancel\", \"invokeOnPreview\"]\n          }],\n          SUBMIT: [{\n            guard: \"isEditControlled\",\n            actions: [\"invokeOnPreview\"]\n          }, {\n            target: \"preview\",\n            actions: [\"setPreviousValue\", \"restoreFocus\", \"invokeOnSubmit\", \"invokeOnPreview\"]\n          }]\n        }\n      }\n    }\n  }, {\n    guards: {\n      isEditControlled: ctx2 => !!ctx2[\"edit.controlled\"],\n      isSubmitEvent: (_ctx, evt) => evt.previousEvent?.type === \"SUBMIT\"\n    },\n    activities: {\n      trackInteractOutside(ctx2, _evt, {\n        send\n      }) {\n        return trackInteractOutside(dom.getInputEl(ctx2), {\n          exclude(target) {\n            const ignore = [dom.getCancelTriggerEl(ctx2), dom.getSubmitTriggerEl(ctx2)];\n            return ignore.some(el => contains(el, target));\n          },\n          onFocusOutside: ctx2.onFocusOutside,\n          onPointerDownOutside: ctx2.onPointerDownOutside,\n          onInteractOutside(event) {\n            ctx2.onInteractOutside?.(event);\n            if (event.defaultPrevented) return;\n            const {\n              focusable\n            } = event.detail;\n            send({\n              type: submitOnBlur(ctx2) ? \"SUBMIT\" : \"CANCEL\",\n              src: \"interact-outside\",\n              focusable\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      restoreFocus(ctx2, evt) {\n        if (evt.focusable) return;\n        raf(() => {\n          const finalEl = ctx2.finalFocusEl?.() ?? dom.getEditTriggerEl(ctx2);\n          finalEl?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      focusInput(ctx2) {\n        raf(() => {\n          const inputEl = dom.getInputEl(ctx2);\n          if (!inputEl) return;\n          if (ctx2.selectOnFocus) {\n            inputEl.select();\n          } else {\n            inputEl.focus({\n              preventScroll: true\n            });\n          }\n        });\n      },\n      invokeOnCancel(ctx2) {\n        ctx2.onValueRevert?.({\n          value: ctx2.previousValue\n        });\n      },\n      invokeOnSubmit(ctx2) {\n        ctx2.onValueCommit?.({\n          value: ctx2.value\n        });\n      },\n      invokeOnEdit(ctx2) {\n        ctx2.onEditChange?.({\n          edit: true\n        });\n      },\n      invokeOnPreview(ctx2) {\n        ctx2.onEditChange?.({\n          edit: false\n        });\n      },\n      toggleEditing(ctx2, evt, {\n        send\n      }) {\n        send({\n          type: ctx2.edit ? \"CONTROLLED.EDIT\" : \"CONTROLLED.PREVIEW\",\n          previousEvent: evt\n        });\n      },\n      syncInputValue(ctx2) {\n        sync.value(ctx2);\n      },\n      setValue(ctx2, evt) {\n        const value = ctx2.maxLength != null ? evt.value.slice(0, ctx2.maxLength) : evt.value;\n        set.value(ctx2, value);\n      },\n      setPreviousValue(ctx2) {\n        ctx2.previousValue = ctx2.value;\n      },\n      revertValue(ctx2) {\n        set.value(ctx2, ctx2.previousValue);\n      },\n      blurInputIfNeeded(ctx2) {\n        dom.getInputEl(ctx2)?.blur();\n      }\n    }\n  });\n}\nvar sync = {\n  value: ctx => {\n    const inputEl = dom.getInputEl(ctx);\n    dom.setValue(inputEl, ctx.value);\n  }\n};\nvar invoke = {\n  change(ctx) {\n    ctx.onValueChange?.({\n      value: ctx.value\n    });\n    sync.value(ctx);\n  }\n};\nvar set = {\n  value(ctx, value) {\n    if (isEqual(ctx.value, value)) return;\n    ctx.value = value;\n    invoke.change(ctx);\n  }\n};\nvar props = createProps()([\"activationMode\", \"autoResize\", \"dir\", \"disabled\", \"finalFocusEl\", \"form\", \"getRootNode\", \"id\", \"ids\", \"invalid\", \"maxLength\", \"name\", \"onEditChange\", \"onFocusOutside\", \"onInteractOutside\", \"onPointerDownOutside\", \"onValueChange\", \"onValueCommit\", \"onValueRevert\", \"placeholder\", \"readOnly\", \"required\", \"selectOnFocus\", \"edit\", \"edit.controlled\", \"submitMode\", \"translations\", \"value\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
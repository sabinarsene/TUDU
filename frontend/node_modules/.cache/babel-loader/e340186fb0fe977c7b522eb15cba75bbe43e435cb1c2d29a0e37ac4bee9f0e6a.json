{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { normalizeColor, getColorAreaGradient, parseColor } from '@zag-js/color-utils';\nimport { createScope, queryAll, getRelativePoint, dataAttr, query, isLeftClick, isModifierKey, getEventPoint, getEventStep, getEventKey, visuallyHiddenStyle, trackFormControl, trackPointerMove, disableTextSelection, raf, getInitialFocus, dispatchInputValueEvent } from '@zag-js/dom-query';\nimport { getPlacementStyles, getPlacement } from '@zag-js/popper';\nimport { createMachine, guards } from '@zag-js/core';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { compact, tryCatch } from '@zag-js/utils';\n\n// src/color-picker.anatomy.ts\nvar anatomy = createAnatomy(\"color-picker\", [\"root\", \"label\", \"control\", \"trigger\", \"positioner\", \"content\", \"area\", \"areaThumb\", \"valueText\", \"areaBackground\", \"channelSlider\", \"channelSliderLabel\", \"channelSliderTrack\", \"channelSliderThumb\", \"channelSliderValueText\", \"channelInput\", \"transparencyGrid\", \"swatchGroup\", \"swatchTrigger\", \"swatchIndicator\", \"swatch\", \"eyeDropperTrigger\", \"formatTrigger\", \"formatSelect\"]);\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `color-picker:${ctx.id}`,\n  getLabelId: ctx => ctx.ids?.label ?? `color-picker:${ctx.id}:label`,\n  getHiddenInputId: ctx => ctx.ids?.hiddenInput ?? `color-picker:${ctx.id}:hidden-input`,\n  getControlId: ctx => ctx.ids?.control ?? `color-picker:${ctx.id}:control`,\n  getTriggerId: ctx => ctx.ids?.trigger ?? `color-picker:${ctx.id}:trigger`,\n  getContentId: ctx => ctx.ids?.content ?? `color-picker:${ctx.id}:content`,\n  getPositionerId: ctx => ctx.ids?.positioner ?? `color-picker:${ctx.id}:positioner`,\n  getFormatSelectId: ctx => ctx.ids?.formatSelect ?? `color-picker:${ctx.id}:format-select`,\n  getAreaId: ctx => ctx.ids?.area ?? `color-picker:${ctx.id}:area`,\n  getAreaGradientId: ctx => ctx.ids?.areaGradient ?? `color-picker:${ctx.id}:area-gradient`,\n  getAreaThumbId: ctx => ctx.ids?.areaThumb ?? `color-picker:${ctx.id}:area-thumb`,\n  getChannelSliderTrackId: (ctx, channel) => ctx.ids?.channelSliderTrack?.(channel) ?? `color-picker:${ctx.id}:slider-track:${channel}`,\n  getChannelSliderThumbId: (ctx, channel) => ctx.ids?.channelSliderThumb?.(channel) ?? `color-picker:${ctx.id}:slider-thumb:${channel}`,\n  getContentEl: ctx => dom.getById(ctx, dom.getContentId(ctx)),\n  getAreaThumbEl: ctx => dom.getById(ctx, dom.getAreaThumbId(ctx)),\n  getChannelSliderThumbEl: (ctx, channel) => dom.getById(ctx, dom.getChannelSliderThumbId(ctx, channel)),\n  getChannelInputEl: (ctx, channel) => {\n    const selector = `input[data-channel=\"${channel}\"]`;\n    return [...queryAll(dom.getContentEl(ctx), selector), ...queryAll(dom.getControlEl(ctx), selector)];\n  },\n  getFormatSelectEl: ctx => dom.getById(ctx, dom.getFormatSelectId(ctx)),\n  getHiddenInputEl: ctx => dom.getById(ctx, dom.getHiddenInputId(ctx)),\n  getAreaEl: ctx => dom.getById(ctx, dom.getAreaId(ctx)),\n  getAreaValueFromPoint(ctx, point) {\n    const areaEl = dom.getAreaEl(ctx);\n    if (!areaEl) return;\n    const {\n      percent\n    } = getRelativePoint(point, areaEl);\n    return percent;\n  },\n  getControlEl: ctx => dom.getById(ctx, dom.getControlId(ctx)),\n  getTriggerEl: ctx => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getPositionerEl: ctx => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getChannelSliderTrackEl: (ctx, channel) => {\n    return dom.getById(ctx, dom.getChannelSliderTrackId(ctx, channel));\n  },\n  getChannelSliderValueFromPoint(ctx, point, channel) {\n    const trackEl = dom.getChannelSliderTrackEl(ctx, channel);\n    if (!trackEl) return;\n    const {\n      percent\n    } = getRelativePoint(point, trackEl);\n    return percent;\n  },\n  getChannelInputEls: ctx => {\n    return [...queryAll(dom.getContentEl(ctx), \"input[data-channel]\"), ...queryAll(dom.getControlEl(ctx), \"input[data-channel]\")];\n  }\n});\nfunction getChannelDisplayColor(color, channel) {\n  switch (channel) {\n    case \"hue\":\n      return parseColor(`hsl(${color.getChannelValue(\"hue\")}, 100%, 50%)`);\n    case \"lightness\":\n    case \"brightness\":\n    case \"saturation\":\n    case \"red\":\n    case \"green\":\n    case \"blue\":\n      return color.withChannelValue(\"alpha\", 1);\n    case \"alpha\":\n      {\n        return color;\n      }\n    default:\n      throw new Error(\"Unknown color channel: \" + channel);\n  }\n}\nfunction getChannelValue(color, channel) {\n  if (channel == null) return \"\";\n  if (channel === \"hex\") {\n    return color.toString(\"hex\");\n  }\n  if (channel === \"css\") {\n    return color.toString(\"css\");\n  }\n  if (channel in color) {\n    return color.getChannelValue(channel).toString();\n  }\n  const isHSL = color.getFormat() === \"hsla\";\n  switch (channel) {\n    case \"hue\":\n      return isHSL ? color.toFormat(\"hsla\").getChannelValue(\"hue\").toString() : color.toFormat(\"hsba\").getChannelValue(\"hue\").toString();\n    case \"saturation\":\n      return isHSL ? color.toFormat(\"hsla\").getChannelValue(\"saturation\").toString() : color.toFormat(\"hsba\").getChannelValue(\"saturation\").toString();\n    case \"lightness\":\n      return color.toFormat(\"hsla\").getChannelValue(\"lightness\").toString();\n    case \"brightness\":\n      return color.toFormat(\"hsba\").getChannelValue(\"brightness\").toString();\n    case \"red\":\n    case \"green\":\n    case \"blue\":\n      return color.toFormat(\"rgba\").getChannelValue(channel).toString();\n    default:\n      return color.getChannelValue(channel).toString();\n  }\n}\nfunction getChannelRange(color, channel) {\n  switch (channel) {\n    case \"hex\":\n      const minColor = parseColor(\"#000000\");\n      const maxColor = parseColor(\"#FFFFFF\");\n      return {\n        minValue: minColor.toHexInt(),\n        maxValue: maxColor.toHexInt(),\n        pageSize: 10,\n        step: 1\n      };\n    case \"css\":\n      return void 0;\n    case \"hue\":\n    case \"saturation\":\n    case \"lightness\":\n      return color.toFormat(\"hsla\").getChannelRange(channel);\n    case \"brightness\":\n      return color.toFormat(\"hsba\").getChannelRange(channel);\n    case \"red\":\n    case \"green\":\n    case \"blue\":\n      return color.toFormat(\"rgba\").getChannelRange(channel);\n    default:\n      return color.getChannelRange(channel);\n  }\n}\n\n// src/utils/get-slider-background.ts\nfunction getSliderBackgroundDirection(orientation, dir) {\n  if (orientation === \"vertical\") {\n    return \"top\";\n  } else if (dir === \"ltr\") {\n    return \"right\";\n  } else {\n    return \"left\";\n  }\n}\nvar getSliderBackground = props => {\n  const {\n    channel,\n    value,\n    dir,\n    orientation\n  } = props;\n  const bgDirection = getSliderBackgroundDirection(orientation, dir);\n  const {\n    minValue,\n    maxValue\n  } = value.getChannelRange(channel);\n  switch (channel) {\n    case \"hue\":\n      return `linear-gradient(to ${bgDirection}, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)`;\n    case \"lightness\":\n      {\n        let start = value.withChannelValue(channel, minValue).toString(\"css\");\n        let middle = value.withChannelValue(channel, (maxValue - minValue) / 2).toString(\"css\");\n        let end = value.withChannelValue(channel, maxValue).toString(\"css\");\n        return `linear-gradient(to ${bgDirection}, ${start}, ${middle}, ${end})`;\n      }\n    case \"saturation\":\n    case \"brightness\":\n    case \"red\":\n    case \"green\":\n    case \"blue\":\n    case \"alpha\":\n      {\n        let start = value.withChannelValue(channel, minValue).toString(\"css\");\n        let end = value.withChannelValue(channel, maxValue).toString(\"css\");\n        return `linear-gradient(to ${bgDirection}, ${start}, ${end})`;\n      }\n    default:\n      throw new Error(\"Unknown color channel: \" + channel);\n  }\n};\n\n// src/color-picker.connect.ts\nfunction connect(state, send, normalize) {\n  const value = state.context.value;\n  const areaValue = state.context.areaValue;\n  const valueAsString = state.context.valueAsString;\n  const disabled = state.context.isDisabled;\n  const interactive = state.context.isInteractive;\n  const dragging = state.hasTag(\"dragging\");\n  const open = state.hasTag(\"open\");\n  const focused = state.hasTag(\"focused\");\n  const getAreaChannels = props => {\n    const channels = areaValue.getChannels();\n    return {\n      xChannel: props.xChannel ?? channels[1],\n      yChannel: props.yChannel ?? channels[2]\n    };\n  };\n  const currentPlacement = state.context.currentPlacement;\n  const popperStyles = getPlacementStyles({\n    ...state.context.positioning,\n    placement: currentPlacement\n  });\n  function getSwatchTriggerState(props) {\n    const color = normalizeColor(props.value).toFormat(state.context.format);\n    return {\n      value: color,\n      valueAsString: color.toString(\"hex\"),\n      checked: color.isEqual(value),\n      disabled: props.disabled || !interactive\n    };\n  }\n  return {\n    dragging,\n    open,\n    valueAsString,\n    value,\n    setOpen(nextOpen) {\n      if (nextOpen === open) return;\n      send({\n        type: nextOpen ? \"OPEN\" : \"CLOSE\"\n      });\n    },\n    setValue(value2) {\n      send({\n        type: \"VALUE.SET\",\n        value: normalizeColor(value2),\n        src: \"set-color\"\n      });\n    },\n    getChannelValue(channel) {\n      return getChannelValue(value, channel);\n    },\n    getChannelValueText(channel, locale) {\n      return value.formatChannelValue(channel, locale);\n    },\n    setChannelValue(channel, channelValue) {\n      const color = value.withChannelValue(channel, channelValue);\n      send({\n        type: \"VALUE.SET\",\n        value: color,\n        src: \"set-channel\"\n      });\n    },\n    format: state.context.format,\n    setFormat(format) {\n      const formatValue = value.toFormat(format);\n      send({\n        type: \"VALUE.SET\",\n        value: formatValue,\n        src: \"set-format\"\n      });\n    },\n    alpha: value.getChannelValue(\"alpha\"),\n    setAlpha(alphaValue) {\n      const color = value.withChannelValue(\"alpha\", alphaValue);\n      send({\n        type: \"VALUE.SET\",\n        value: color,\n        src: \"set-alpha\"\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        id: dom.getRootId(state.context),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        \"data-invalid\": dataAttr(state.context.invalid),\n        style: {\n          \"--value\": value.toString(\"css\")\n        }\n      });\n    },\n    getLabelProps() {\n      return normalize.element({\n        ...parts.label.attrs,\n        dir: state.context.dir,\n        id: dom.getLabelId(state.context),\n        htmlFor: dom.getHiddenInputId(state.context),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        \"data-invalid\": dataAttr(state.context.invalid),\n        \"data-focus\": dataAttr(focused),\n        onClick(event) {\n          event.preventDefault();\n          const inputEl = query(dom.getControlEl(state.context), \"[data-channel=hex]\");\n          inputEl?.focus({\n            preventScroll: true\n          });\n        }\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        id: dom.getControlId(state.context),\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        \"data-invalid\": dataAttr(state.context.invalid),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-focus\": dataAttr(focused)\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        id: dom.getTriggerId(state.context),\n        dir: state.context.dir,\n        disabled,\n        \"aria-label\": `select color. current color is ${valueAsString}`,\n        \"aria-controls\": dom.getContentId(state.context),\n        \"aria-labelledby\": dom.getLabelId(state.context),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        \"data-invalid\": dataAttr(state.context.invalid),\n        \"data-placement\": currentPlacement,\n        \"aria-expanded\": dataAttr(open),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-focus\": dataAttr(focused),\n        type: \"button\",\n        onClick() {\n          if (!interactive) return;\n          send({\n            type: \"TRIGGER.CLICK\"\n          });\n        },\n        onBlur() {\n          if (!interactive) return;\n          send({\n            type: \"TRIGGER.BLUR\"\n          });\n        },\n        style: {\n          position: \"relative\"\n        }\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        ...parts.positioner.attrs,\n        id: dom.getPositionerId(state.context),\n        dir: state.context.dir,\n        style: popperStyles.floating\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        id: dom.getContentId(state.context),\n        dir: state.context.dir,\n        \"data-placement\": currentPlacement,\n        \"data-state\": open ? \"open\" : \"closed\",\n        hidden: !open\n      });\n    },\n    getValueTextProps() {\n      return normalize.element({\n        ...parts.valueText.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-focus\": dataAttr(focused)\n      });\n    },\n    getAreaProps(props = {}) {\n      const {\n        xChannel,\n        yChannel\n      } = getAreaChannels(props);\n      const {\n        areaStyles\n      } = getColorAreaGradient(areaValue, {\n        xChannel,\n        yChannel,\n        dir: state.context.dir\n      });\n      return normalize.element({\n        ...parts.area.attrs,\n        id: dom.getAreaId(state.context),\n        role: \"group\",\n        \"data-invalid\": dataAttr(state.context.invalid),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        onPointerDown(event) {\n          if (!interactive) return;\n          if (!isLeftClick(event)) return;\n          if (isModifierKey(event)) return;\n          const point = getEventPoint(event);\n          const channel = {\n            xChannel,\n            yChannel\n          };\n          send({\n            type: \"AREA.POINTER_DOWN\",\n            point,\n            channel,\n            id: \"area\"\n          });\n          event.preventDefault();\n        },\n        style: {\n          position: \"relative\",\n          touchAction: \"none\",\n          forcedColorAdjust: \"none\",\n          ...areaStyles\n        }\n      });\n    },\n    getAreaBackgroundProps(props = {}) {\n      const {\n        xChannel,\n        yChannel\n      } = getAreaChannels(props);\n      const {\n        areaGradientStyles\n      } = getColorAreaGradient(areaValue, {\n        xChannel,\n        yChannel,\n        dir: state.context.dir\n      });\n      return normalize.element({\n        ...parts.areaBackground.attrs,\n        id: dom.getAreaGradientId(state.context),\n        \"data-invalid\": dataAttr(state.context.invalid),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        style: {\n          position: \"relative\",\n          touchAction: \"none\",\n          forcedColorAdjust: \"none\",\n          ...areaGradientStyles\n        }\n      });\n    },\n    getAreaThumbProps(props = {}) {\n      const {\n        xChannel,\n        yChannel\n      } = getAreaChannels(props);\n      const channel = {\n        xChannel,\n        yChannel\n      };\n      const xPercent = areaValue.getChannelValuePercent(xChannel);\n      const yPercent = 1 - areaValue.getChannelValuePercent(yChannel);\n      const xValue = areaValue.getChannelValue(xChannel);\n      const yValue = areaValue.getChannelValue(yChannel);\n      const color = areaValue.withChannelValue(\"alpha\", 1).toString(\"css\");\n      return normalize.element({\n        ...parts.areaThumb.attrs,\n        id: dom.getAreaThumbId(state.context),\n        dir: state.context.dir,\n        tabIndex: disabled ? void 0 : 0,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(state.context.invalid),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        role: \"slider\",\n        \"aria-valuemin\": 0,\n        \"aria-valuemax\": 100,\n        \"aria-valuenow\": xValue,\n        \"aria-label\": `${xChannel} and ${yChannel}`,\n        \"aria-roledescription\": \"2d slider\",\n        \"aria-valuetext\": `${xChannel} ${xValue}, ${yChannel} ${yValue}`,\n        style: {\n          position: \"absolute\",\n          left: `${xPercent * 100}%`,\n          top: `${yPercent * 100}%`,\n          transform: \"translate(-50%, -50%)\",\n          touchAction: \"none\",\n          forcedColorAdjust: \"none\",\n          \"--color\": color,\n          background: color\n        },\n        onFocus() {\n          if (!interactive) return;\n          send({\n            type: \"AREA.FOCUS\",\n            id: \"area\",\n            channel\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          const step = getEventStep(event);\n          const keyMap = {\n            ArrowUp() {\n              send({\n                type: \"AREA.ARROW_UP\",\n                channel,\n                step\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"AREA.ARROW_DOWN\",\n                channel,\n                step\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"AREA.ARROW_LEFT\",\n                channel,\n                step\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"AREA.ARROW_RIGHT\",\n                channel,\n                step\n              });\n            },\n            PageUp() {\n              send({\n                type: \"AREA.PAGE_UP\",\n                channel,\n                step\n              });\n            },\n            PageDown() {\n              send({\n                type: \"AREA.PAGE_DOWN\",\n                channel,\n                step\n              });\n            },\n            Escape(event2) {\n              event2.stopPropagation();\n            }\n          };\n          const exec = keyMap[getEventKey(event, state.context)];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    getTransparencyGridProps(props = {}) {\n      const {\n        size = \"12px\"\n      } = props;\n      return normalize.element({\n        ...parts.transparencyGrid.attrs,\n        style: {\n          \"--size\": size,\n          width: \"100%\",\n          height: \"100%\",\n          position: \"absolute\",\n          backgroundColor: \"#fff\",\n          backgroundImage: \"conic-gradient(#eeeeee 0 25%, transparent 0 50%, #eeeeee 0 75%, transparent 0)\",\n          backgroundSize: \"var(--size) var(--size)\",\n          inset: \"0px\",\n          zIndex: \"auto\",\n          pointerEvents: \"none\"\n        }\n      });\n    },\n    getChannelSliderProps(props) {\n      const {\n        orientation = \"horizontal\",\n        channel,\n        format\n      } = props;\n      return normalize.element({\n        ...parts.channelSlider.attrs,\n        \"data-channel\": channel,\n        \"data-orientation\": orientation,\n        role: \"presentation\",\n        onPointerDown(event) {\n          if (!interactive) return;\n          if (!isLeftClick(event)) return;\n          if (isModifierKey(event)) return;\n          const point = getEventPoint(event);\n          send({\n            type: \"CHANNEL_SLIDER.POINTER_DOWN\",\n            channel,\n            format,\n            point,\n            id: channel,\n            orientation\n          });\n          event.preventDefault();\n        },\n        style: {\n          position: \"relative\",\n          touchAction: \"none\"\n        }\n      });\n    },\n    getChannelSliderTrackProps(props) {\n      const {\n        orientation = \"horizontal\",\n        channel,\n        format\n      } = props;\n      const normalizedValue = format ? value.toFormat(format) : areaValue;\n      return normalize.element({\n        ...parts.channelSliderTrack.attrs,\n        id: dom.getChannelSliderTrackId(state.context, channel),\n        role: \"group\",\n        \"data-channel\": channel,\n        \"data-orientation\": orientation,\n        style: {\n          position: \"relative\",\n          forcedColorAdjust: \"none\",\n          backgroundImage: getSliderBackground({\n            orientation,\n            channel,\n            dir: state.context.dir,\n            value: normalizedValue\n          })\n        }\n      });\n    },\n    getChannelSliderLabelProps(props) {\n      const {\n        channel\n      } = props;\n      return normalize.element({\n        ...parts.channelSliderLabel.attrs,\n        \"data-channel\": channel,\n        onClick(event) {\n          if (!interactive) return;\n          event.preventDefault();\n          const thumbId = dom.getChannelSliderThumbId(state.context, channel);\n          dom.getById(state.context, thumbId)?.focus({\n            preventScroll: true\n          });\n        },\n        style: {\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\"\n        }\n      });\n    },\n    getChannelSliderValueTextProps(props) {\n      return normalize.element({\n        ...parts.channelSliderValueText.attrs,\n        \"data-channel\": props.channel\n      });\n    },\n    getChannelSliderThumbProps(props) {\n      const {\n        orientation = \"horizontal\",\n        channel,\n        format\n      } = props;\n      const normalizedValue = format ? value.toFormat(format) : areaValue;\n      const channelRange = normalizedValue.getChannelRange(channel);\n      const channelValue = normalizedValue.getChannelValue(channel);\n      const offset = (channelValue - channelRange.minValue) / (channelRange.maxValue - channelRange.minValue);\n      const placementStyles = orientation === \"horizontal\" ? {\n        left: `${offset * 100}%`,\n        top: \"50%\"\n      } : {\n        top: `${offset * 100}%`,\n        left: \"50%\"\n      };\n      return normalize.element({\n        ...parts.channelSliderThumb.attrs,\n        id: dom.getChannelSliderThumbId(state.context, channel),\n        role: \"slider\",\n        \"aria-label\": channel,\n        tabIndex: disabled ? void 0 : 0,\n        \"data-channel\": channel,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-orientation\": orientation,\n        \"aria-disabled\": dataAttr(disabled),\n        \"aria-orientation\": orientation,\n        \"aria-valuemax\": channelRange.maxValue,\n        \"aria-valuemin\": channelRange.minValue,\n        \"aria-valuenow\": channelValue,\n        \"aria-valuetext\": `${channel} ${channelValue}`,\n        style: {\n          forcedColorAdjust: \"none\",\n          position: \"absolute\",\n          background: getChannelDisplayColor(areaValue, channel).toString(\"css\"),\n          ...placementStyles\n        },\n        onFocus() {\n          if (!interactive) return;\n          send({\n            type: \"CHANNEL_SLIDER.FOCUS\",\n            channel\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          const step = getEventStep(event) * channelRange.step;\n          const keyMap = {\n            ArrowUp() {\n              send({\n                type: \"CHANNEL_SLIDER.ARROW_UP\",\n                channel,\n                step\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"CHANNEL_SLIDER.ARROW_DOWN\",\n                channel,\n                step\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"CHANNEL_SLIDER.ARROW_LEFT\",\n                channel,\n                step\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"CHANNEL_SLIDER.ARROW_RIGHT\",\n                channel,\n                step\n              });\n            },\n            PageUp() {\n              send({\n                type: \"CHANNEL_SLIDER.PAGE_UP\",\n                channel\n              });\n            },\n            PageDown() {\n              send({\n                type: \"CHANNEL_SLIDER.PAGE_DOWN\",\n                channel\n              });\n            },\n            Home() {\n              send({\n                type: \"CHANNEL_SLIDER.HOME\",\n                channel\n              });\n            },\n            End() {\n              send({\n                type: \"CHANNEL_SLIDER.END\",\n                channel\n              });\n            },\n            Escape(event2) {\n              event2.stopPropagation();\n            }\n          };\n          const exec = keyMap[getEventKey(event, state.context)];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    getChannelInputProps(props) {\n      const {\n        channel\n      } = props;\n      const isTextField = channel === \"hex\" || channel === \"css\";\n      const channelRange = getChannelRange(value, channel);\n      return normalize.input({\n        ...parts.channelInput.attrs,\n        dir: state.context.dir,\n        type: isTextField ? \"text\" : \"number\",\n        \"data-channel\": channel,\n        \"aria-label\": channel,\n        spellCheck: false,\n        autoComplete: \"off\",\n        disabled,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(state.context.invalid),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        readOnly: state.context.readOnly,\n        defaultValue: getChannelValue(value, channel),\n        min: channelRange?.minValue,\n        max: channelRange?.maxValue,\n        step: channelRange?.step,\n        onBeforeInput(event) {\n          if (isTextField || !interactive) return;\n          const value2 = event.currentTarget.value;\n          if (value2.match(/[^0-9.]/g)) {\n            event.preventDefault();\n          }\n        },\n        onFocus(event) {\n          if (!interactive) return;\n          send({\n            type: \"CHANNEL_INPUT.FOCUS\",\n            channel\n          });\n          event.currentTarget.select();\n        },\n        onBlur(event) {\n          if (!interactive) return;\n          const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;\n          send({\n            type: \"CHANNEL_INPUT.BLUR\",\n            channel,\n            value: value2,\n            isTextField\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          if (event.key === \"Enter\") {\n            const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;\n            send({\n              type: \"CHANNEL_INPUT.CHANGE\",\n              channel,\n              value: value2,\n              isTextField\n            });\n            event.preventDefault();\n          }\n        },\n        style: {\n          appearance: \"none\",\n          WebkitAppearance: \"none\",\n          MozAppearance: \"textfield\"\n        }\n      });\n    },\n    getHiddenInputProps() {\n      return normalize.input({\n        type: \"text\",\n        disabled,\n        name: state.context.name,\n        tabIndex: -1,\n        readOnly: state.context.readOnly,\n        required: state.context.required,\n        id: dom.getHiddenInputId(state.context),\n        style: visuallyHiddenStyle,\n        defaultValue: valueAsString\n      });\n    },\n    getEyeDropperTriggerProps() {\n      return normalize.button({\n        ...parts.eyeDropperTrigger.attrs,\n        type: \"button\",\n        dir: state.context.dir,\n        disabled,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(state.context.invalid),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        \"aria-label\": \"Pick a color from the screen\",\n        onClick() {\n          if (!interactive) return;\n          send(\"EYEDROPPER.CLICK\");\n        }\n      });\n    },\n    getSwatchGroupProps() {\n      return normalize.element({\n        ...parts.swatchGroup.attrs,\n        role: \"group\"\n      });\n    },\n    getSwatchTriggerState,\n    getSwatchTriggerProps(props) {\n      const swatchState = getSwatchTriggerState(props);\n      return normalize.button({\n        ...parts.swatchTrigger.attrs,\n        disabled: swatchState.disabled,\n        dir: state.context.dir,\n        type: \"button\",\n        \"aria-label\": `select ${swatchState.valueAsString} as the color`,\n        \"data-state\": swatchState.checked ? \"checked\" : \"unchecked\",\n        \"data-value\": swatchState.valueAsString,\n        \"data-disabled\": dataAttr(swatchState.disabled),\n        onClick() {\n          if (swatchState.disabled) return;\n          send({\n            type: \"SWATCH_TRIGGER.CLICK\",\n            value: swatchState.value\n          });\n        },\n        style: {\n          \"--color\": swatchState.valueAsString,\n          position: \"relative\"\n        }\n      });\n    },\n    getSwatchIndicatorProps(props) {\n      const swatchState = getSwatchTriggerState(props);\n      return normalize.element({\n        ...parts.swatchIndicator.attrs,\n        dir: state.context.dir,\n        hidden: !swatchState.checked\n      });\n    },\n    getSwatchProps(props) {\n      const {\n        respectAlpha = true\n      } = props;\n      const swatchState = getSwatchTriggerState(props);\n      const color = swatchState.value.toString(respectAlpha ? \"css\" : \"hex\");\n      return normalize.element({\n        ...parts.swatch.attrs,\n        dir: state.context.dir,\n        \"data-state\": swatchState.checked ? \"checked\" : \"unchecked\",\n        \"data-value\": swatchState.valueAsString,\n        style: {\n          \"--color\": color,\n          position: \"relative\",\n          background: color\n        }\n      });\n    },\n    getFormatTriggerProps() {\n      return normalize.button({\n        ...parts.formatTrigger.attrs,\n        dir: state.context.dir,\n        type: \"button\",\n        \"aria-label\": `change color format to ${getNextFormat(state.context.format)}`,\n        onClick(event) {\n          if (event.currentTarget.disabled) return;\n          const nextFormat = getNextFormat(state.context.format);\n          send({\n            type: \"FORMAT.SET\",\n            format: nextFormat,\n            src: \"format-trigger\"\n          });\n        }\n      });\n    },\n    getFormatSelectProps() {\n      return normalize.select({\n        ...parts.formatSelect.attrs,\n        \"aria-label\": \"change color format\",\n        dir: state.context.dir,\n        defaultValue: state.context.format,\n        disabled,\n        onChange(event) {\n          const format = assertFormat(event.currentTarget.value);\n          send({\n            type: \"FORMAT.SET\",\n            format,\n            src: \"format-select\"\n          });\n        }\n      });\n    }\n  };\n}\nvar formats = [\"hsba\", \"hsla\", \"rgba\"];\nvar formatRegex = new RegExp(`^(${formats.join(\"|\")})$`);\nfunction getNextFormat(format) {\n  const index = formats.indexOf(format);\n  return formats[index + 1] ?? formats[0];\n}\nfunction assertFormat(format) {\n  if (formatRegex.test(format)) return format;\n  throw new Error(`Unsupported color format: ${format}`);\n}\nvar parse = colorString => {\n  return parseColor(colorString);\n};\n\n// src/color-picker.machine.ts\nvar {\n  and\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"color-picker\",\n    initial: ctx.open ? \"open\" : \"idle\",\n    context: {\n      dir: \"ltr\",\n      value: parse(\"#000000\"),\n      format: \"rgba\",\n      disabled: false,\n      closeOnSelect: false,\n      openAutoFocus: true,\n      ...ctx,\n      activeId: null,\n      activeChannel: null,\n      activeOrientation: null,\n      fieldsetDisabled: false,\n      restoreFocus: true,\n      positioning: {\n        ...ctx.positioning,\n        placement: \"bottom\"\n      }\n    },\n    computed: {\n      isRtl: ctx2 => ctx2.dir === \"rtl\",\n      isDisabled: ctx2 => !!ctx2.disabled || ctx2.fieldsetDisabled,\n      isInteractive: ctx2 => !(ctx2.isDisabled || ctx2.readOnly),\n      valueAsString: ctx2 => ctx2.value.toString(ctx2.format),\n      areaValue: ctx2 => {\n        const format = ctx2.format.startsWith(\"hsl\") ? \"hsla\" : \"hsba\";\n        return ctx2.value.toFormat(format);\n      }\n    },\n    activities: [\"trackFormControl\"],\n    watch: {\n      value: [\"syncInputElements\"],\n      format: [\"syncFormatSelectElement\"],\n      open: [\"toggleVisibility\"]\n    },\n    on: {\n      \"VALUE.SET\": {\n        actions: [\"setValue\"]\n      },\n      \"FORMAT.SET\": {\n        actions: [\"setFormat\"]\n      },\n      \"CHANNEL_INPUT.CHANGE\": {\n        actions: [\"setChannelColorFromInput\"]\n      },\n      \"EYEDROPPER.CLICK\": {\n        actions: [\"openEyeDropper\"]\n      },\n      \"SWATCH_TRIGGER.CLICK\": {\n        actions: [\"setValue\"]\n      }\n    },\n    states: {\n      idle: {\n        tags: [\"closed\"],\n        on: {\n          \"CONTROLLED.OPEN\": {\n            target: \"open\",\n            actions: [\"setInitialFocus\"]\n          },\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\", \"setInitialFocus\"]\n          }],\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\", \"setInitialFocus\"]\n          }],\n          \"CHANNEL_INPUT.FOCUS\": {\n            target: \"focused\",\n            actions: [\"setActiveChannel\"]\n          }\n        }\n      },\n      focused: {\n        tags: [\"closed\", \"focused\"],\n        on: {\n          \"CONTROLLED.OPEN\": {\n            target: \"open\",\n            actions: [\"setInitialFocus\"]\n          },\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\", \"setInitialFocus\"]\n          }],\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\", \"setInitialFocus\"]\n          }],\n          \"CHANNEL_INPUT.FOCUS\": {\n            actions: [\"setActiveChannel\"]\n          },\n          \"CHANNEL_INPUT.BLUR\": {\n            target: \"idle\",\n            actions: [\"setChannelColorFromInput\"]\n          },\n          \"TRIGGER.BLUR\": {\n            target: \"idle\"\n          }\n        }\n      },\n      open: {\n        tags: [\"open\"],\n        activities: [\"trackPositioning\", \"trackDismissableElement\"],\n        on: {\n          \"CONTROLLED.CLOSE\": [{\n            guard: \"shouldRestoreFocus\",\n            target: \"focused\",\n            actions: [\"setReturnFocus\"]\n          }, {\n            target: \"idle\"\n          }],\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"idle\",\n            actions: [\"invokeOnClose\"]\n          }],\n          \"AREA.POINTER_DOWN\": {\n            target: \"open:dragging\",\n            actions: [\"setActiveChannel\", \"setAreaColorFromPoint\", \"focusAreaThumb\"]\n          },\n          \"AREA.FOCUS\": {\n            actions: [\"setActiveChannel\"]\n          },\n          \"CHANNEL_SLIDER.POINTER_DOWN\": {\n            target: \"open:dragging\",\n            actions: [\"setActiveChannel\", \"setChannelColorFromPoint\", \"focusChannelThumb\"]\n          },\n          \"CHANNEL_SLIDER.FOCUS\": {\n            actions: [\"setActiveChannel\"]\n          },\n          \"AREA.ARROW_LEFT\": {\n            actions: [\"decrementAreaXChannel\"]\n          },\n          \"AREA.ARROW_RIGHT\": {\n            actions: [\"incrementAreaXChannel\"]\n          },\n          \"AREA.ARROW_UP\": {\n            actions: [\"incrementAreaYChannel\"]\n          },\n          \"AREA.ARROW_DOWN\": {\n            actions: [\"decrementAreaYChannel\"]\n          },\n          \"AREA.PAGE_UP\": {\n            actions: [\"incrementAreaXChannel\"]\n          },\n          \"AREA.PAGE_DOWN\": {\n            actions: [\"decrementAreaXChannel\"]\n          },\n          \"CHANNEL_SLIDER.ARROW_LEFT\": {\n            actions: [\"decrementChannel\"]\n          },\n          \"CHANNEL_SLIDER.ARROW_RIGHT\": {\n            actions: [\"incrementChannel\"]\n          },\n          \"CHANNEL_SLIDER.ARROW_UP\": {\n            actions: [\"incrementChannel\"]\n          },\n          \"CHANNEL_SLIDER.ARROW_DOWN\": {\n            actions: [\"decrementChannel\"]\n          },\n          \"CHANNEL_SLIDER.PAGE_UP\": {\n            actions: [\"incrementChannel\"]\n          },\n          \"CHANNEL_SLIDER.PAGE_DOWN\": {\n            actions: [\"decrementChannel\"]\n          },\n          \"CHANNEL_SLIDER.HOME\": {\n            actions: [\"setChannelToMin\"]\n          },\n          \"CHANNEL_SLIDER.END\": {\n            actions: [\"setChannelToMax\"]\n          },\n          \"CHANNEL_INPUT.BLUR\": {\n            actions: [\"setChannelColorFromInput\"]\n          },\n          INTERACT_OUTSIDE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            guard: \"shouldRestoreFocus\",\n            target: \"focused\",\n            actions: [\"invokeOnClose\", \"setReturnFocus\"]\n          }, {\n            target: \"idle\",\n            actions: [\"invokeOnClose\"]\n          }],\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"idle\",\n            actions: [\"invokeOnClose\"]\n          }],\n          \"SWATCH_TRIGGER.CLICK\": [{\n            guard: and(\"isOpenControlled\", \"closeOnSelect\"),\n            actions: [\"setValue\", \"invokeOnClose\"]\n          }, {\n            guard: \"closeOnSelect\",\n            target: \"focused\",\n            actions: [\"setValue\", \"invokeOnClose\", \"setReturnFocus\"]\n          }, {\n            actions: [\"setValue\"]\n          }]\n        }\n      },\n      \"open:dragging\": {\n        tags: [\"open\"],\n        exit: [\"clearActiveChannel\"],\n        activities: [\"trackPointerMove\", \"disableTextSelection\", \"trackPositioning\", \"trackDismissableElement\"],\n        on: {\n          \"CONTROLLED.CLOSE\": [{\n            guard: \"shouldRestoreFocus\",\n            target: \"focused\",\n            actions: [\"setReturnFocus\"]\n          }, {\n            target: \"idle\"\n          }],\n          \"AREA.POINTER_MOVE\": {\n            actions: [\"setAreaColorFromPoint\", \"focusAreaThumb\"]\n          },\n          \"AREA.POINTER_UP\": {\n            target: \"open\",\n            actions: [\"invokeOnChangeEnd\"]\n          },\n          \"CHANNEL_SLIDER.POINTER_MOVE\": {\n            actions: [\"setChannelColorFromPoint\", \"focusChannelThumb\"]\n          },\n          \"CHANNEL_SLIDER.POINTER_UP\": {\n            target: \"open\",\n            actions: [\"invokeOnChangeEnd\"]\n          },\n          INTERACT_OUTSIDE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            guard: \"shouldRestoreFocus\",\n            target: \"focused\",\n            actions: [\"invokeOnClose\", \"setReturnFocus\"]\n          }, {\n            target: \"idle\",\n            actions: [\"invokeOnClose\"]\n          }],\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"idle\",\n            actions: [\"invokeOnClose\"]\n          }]\n        }\n      }\n    }\n  }, {\n    guards: {\n      closeOnSelect: ctx2 => !!ctx2.closeOnSelect,\n      isOpenControlled: ctx2 => !!ctx2[\"open.controlled\"],\n      shouldRestoreFocus: ctx2 => !!ctx2.restoreFocus\n    },\n    activities: {\n      trackPositioning(ctx2) {\n        ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);\n        const anchorEl = dom.getTriggerEl(ctx2);\n        const getPositionerEl = () => dom.getPositionerEl(ctx2);\n        return getPlacement(anchorEl, getPositionerEl, {\n          ...ctx2.positioning,\n          defer: true,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      trackDismissableElement(ctx2, _evt, {\n        send\n      }) {\n        const getContentEl = () => dom.getContentEl(ctx2);\n        return trackDismissableElement(getContentEl, {\n          exclude: dom.getTriggerEl(ctx2),\n          defer: true,\n          onInteractOutside(event) {\n            ctx2.onInteractOutside?.(event);\n            if (event.defaultPrevented) return;\n            ctx2.restoreFocus = !(event.detail.focusable || event.detail.contextmenu);\n          },\n          onPointerDownOutside: ctx2.onPointerDownOutside,\n          onFocusOutside: ctx2.onFocusOutside,\n          onDismiss() {\n            send({\n              type: \"INTERACT_OUTSIDE\"\n            });\n          }\n        });\n      },\n      trackFormControl(ctx2, _evt, {\n        send,\n        initialContext\n      }) {\n        const inputEl = dom.getHiddenInputEl(ctx2);\n        return trackFormControl(inputEl, {\n          onFieldsetDisabledChange(disabled) {\n            ctx2.fieldsetDisabled = disabled;\n          },\n          onFormReset() {\n            send({\n              type: \"VALUE.SET\",\n              value: initialContext.value,\n              src: \"form.reset\"\n            });\n          }\n        });\n      },\n      trackPointerMove(ctx2, evt, {\n        send\n      }) {\n        return trackPointerMove(dom.getDoc(ctx2), {\n          onPointerMove({\n            point\n          }) {\n            const type = ctx2.activeId === \"area\" ? \"AREA.POINTER_MOVE\" : \"CHANNEL_SLIDER.POINTER_MOVE\";\n            send({\n              type,\n              point,\n              format: evt.format\n            });\n          },\n          onPointerUp() {\n            const type = ctx2.activeId === \"area\" ? \"AREA.POINTER_UP\" : \"CHANNEL_SLIDER.POINTER_UP\";\n            send({\n              type\n            });\n          }\n        });\n      },\n      disableTextSelection(ctx2) {\n        return disableTextSelection({\n          doc: dom.getDoc(ctx2),\n          target: dom.getContentEl(ctx2)\n        });\n      }\n    },\n    actions: {\n      openEyeDropper(ctx2) {\n        const isSupported = \"EyeDropper\" in dom.getWin(ctx2);\n        if (!isSupported) return;\n        const win = dom.getWin(ctx2);\n        const picker = new win.EyeDropper();\n        picker.open().then(({\n          sRGBHex\n        }) => {\n          const format = ctx2.value.getFormat();\n          const color = parseColor(sRGBHex).toFormat(format);\n          set.value(ctx2, color);\n          ctx2.onValueChangeEnd?.({\n            value: ctx2.value,\n            valueAsString: ctx2.valueAsString\n          });\n        }).catch(() => void 0);\n      },\n      setActiveChannel(ctx2, evt) {\n        ctx2.activeId = evt.id;\n        if (evt.channel) ctx2.activeChannel = evt.channel;\n        if (evt.orientation) ctx2.activeOrientation = evt.orientation;\n      },\n      clearActiveChannel(ctx2) {\n        ctx2.activeChannel = null;\n        ctx2.activeId = null;\n        ctx2.activeOrientation = null;\n      },\n      setAreaColorFromPoint(ctx2, evt) {\n        const normalizedValue = evt.format ? ctx2.value.toFormat(evt.format) : ctx2.areaValue;\n        const {\n          xChannel,\n          yChannel\n        } = evt.channel || ctx2.activeChannel;\n        const percent = dom.getAreaValueFromPoint(ctx2, evt.point);\n        if (!percent) return;\n        const xValue = normalizedValue.getChannelPercentValue(xChannel, percent.x);\n        const yValue = normalizedValue.getChannelPercentValue(yChannel, 1 - percent.y);\n        const color = normalizedValue.withChannelValue(xChannel, xValue).withChannelValue(yChannel, yValue);\n        set.value(ctx2, color);\n      },\n      setChannelColorFromPoint(ctx2, evt) {\n        const channel = evt.channel || ctx2.activeId;\n        const normalizedValue = evt.format ? ctx2.value.toFormat(evt.format) : ctx2.areaValue;\n        const percent = dom.getChannelSliderValueFromPoint(ctx2, evt.point, channel);\n        if (!percent) return;\n        const orientation = ctx2.activeOrientation || \"horizontal\";\n        const channelPercent = orientation === \"horizontal\" ? percent.x : percent.y;\n        const value = normalizedValue.getChannelPercentValue(channel, channelPercent);\n        const color = normalizedValue.withChannelValue(channel, value);\n        set.value(ctx2, color);\n      },\n      setValue(ctx2, evt) {\n        set.value(ctx2, evt.value);\n      },\n      setFormat(ctx2, evt) {\n        set.format(ctx2, evt.format);\n      },\n      syncInputElements(ctx2) {\n        sync.inputs(ctx2);\n      },\n      invokeOnChangeEnd(ctx2) {\n        invoke.changeEnd(ctx2);\n      },\n      setChannelColorFromInput(ctx2, evt) {\n        const {\n          channel,\n          isTextField,\n          value\n        } = evt;\n        const currentAlpha = ctx2.value.getChannelValue(\"alpha\");\n        let color;\n        if (channel === \"alpha\") {\n          let valueAsNumber = parseFloat(value);\n          valueAsNumber = Number.isNaN(valueAsNumber) ? currentAlpha : valueAsNumber;\n          color = ctx2.value.withChannelValue(\"alpha\", valueAsNumber);\n        } else if (isTextField) {\n          color = tryCatch(() => parse(value).withChannelValue(\"alpha\", currentAlpha), () => ctx2.value);\n        } else {\n          const current = ctx2.value.toFormat(ctx2.format);\n          const valueAsNumber = Number.isNaN(value) ? current.getChannelValue(channel) : value;\n          color = current.withChannelValue(channel, valueAsNumber);\n        }\n        sync.inputs(ctx2, color);\n        set.value(ctx2, color);\n      },\n      incrementChannel(ctx2, evt) {\n        const color = ctx2.value.incrementChannel(evt.channel, evt.step);\n        set.value(ctx2, color);\n      },\n      decrementChannel(ctx2, evt) {\n        const color = ctx2.value.decrementChannel(evt.channel, evt.step);\n        set.value(ctx2, color);\n      },\n      incrementAreaXChannel(ctx2, evt) {\n        const {\n          xChannel\n        } = evt.channel;\n        const color = ctx2.areaValue.incrementChannel(xChannel, evt.step);\n        set.value(ctx2, color);\n      },\n      decrementAreaXChannel(ctx2, evt) {\n        const {\n          xChannel\n        } = evt.channel;\n        const color = ctx2.areaValue.decrementChannel(xChannel, evt.step);\n        set.value(ctx2, color);\n      },\n      incrementAreaYChannel(ctx2, evt) {\n        const {\n          yChannel\n        } = evt.channel;\n        const color = ctx2.areaValue.incrementChannel(yChannel, evt.step);\n        set.value(ctx2, color);\n      },\n      decrementAreaYChannel(ctx2, evt) {\n        const {\n          yChannel\n        } = evt.channel;\n        const color = ctx2.areaValue.decrementChannel(yChannel, evt.step);\n        set.value(ctx2, color);\n      },\n      setChannelToMax(ctx2, evt) {\n        const range = ctx2.value.getChannelRange(evt.channel);\n        const color = ctx2.value.withChannelValue(evt.channel, range.maxValue);\n        set.value(ctx2, color);\n      },\n      setChannelToMin(ctx2, evt) {\n        const range = ctx2.value.getChannelRange(evt.channel);\n        const color = ctx2.value.withChannelValue(evt.channel, range.minValue);\n        set.value(ctx2, color);\n      },\n      focusAreaThumb(ctx2) {\n        raf(() => {\n          dom.getAreaThumbEl(ctx2)?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      focusChannelThumb(ctx2, evt) {\n        raf(() => {\n          dom.getChannelSliderThumbEl(ctx2, evt.channel)?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      setInitialFocus(ctx2) {\n        if (!ctx2.openAutoFocus) return;\n        raf(() => {\n          const element = getInitialFocus({\n            root: dom.getContentEl(ctx2),\n            getInitialEl: ctx2.initialFocusEl\n          });\n          element?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      setReturnFocus(ctx2) {\n        raf(() => {\n          dom.getTriggerEl(ctx2)?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      syncFormatSelectElement(ctx2) {\n        sync.formatSelect(ctx2);\n      },\n      invokeOnOpen(ctx2) {\n        ctx2.onOpenChange?.({\n          open: true\n        });\n      },\n      invokeOnClose(ctx2) {\n        ctx2.onOpenChange?.({\n          open: false\n        });\n      },\n      toggleVisibility(ctx2, evt, {\n        send\n      }) {\n        send({\n          type: ctx2.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: evt\n        });\n      }\n    },\n    compareFns: {\n      value: (a, b) => a.isEqual(b)\n    }\n  });\n}\nvar sync = {\n  // sync channel inputs\n  inputs(ctx, color) {\n    const channelInputs = dom.getChannelInputEls(ctx);\n    raf(() => {\n      channelInputs.forEach(inputEl => {\n        const channel = inputEl.dataset.channel;\n        dom.setValue(inputEl, getChannelValue(color || ctx.value, channel));\n      });\n    });\n  },\n  // sync format select\n  formatSelect(ctx) {\n    const selectEl = dom.getFormatSelectEl(ctx);\n    raf(() => {\n      dom.setValue(selectEl, ctx.format);\n    });\n  }\n};\nvar invoke = {\n  changeEnd(ctx) {\n    const value = ctx.value.toFormat(ctx.format);\n    ctx.onValueChangeEnd?.({\n      value,\n      valueAsString: ctx.valueAsString\n    });\n  },\n  change(ctx) {\n    const value = ctx.value.toFormat(ctx.format);\n    ctx.onValueChange?.({\n      value,\n      valueAsString: ctx.valueAsString\n    });\n    dispatchInputValueEvent(dom.getHiddenInputEl(ctx), {\n      value: ctx.valueAsString\n    });\n  },\n  formatChange(ctx) {\n    ctx.onFormatChange?.({\n      format: ctx.format\n    });\n  }\n};\nvar set = {\n  value(ctx, color) {\n    if (!color || ctx.value.isEqual(color)) return;\n    ctx.value = color;\n    invoke.change(ctx);\n  },\n  format(ctx, format) {\n    if (ctx.format === format) return;\n    ctx.format = format;\n    invoke.formatChange(ctx);\n  }\n};\nexport { anatomy, connect, machine, parse };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
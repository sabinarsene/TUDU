{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, queryAll, dataAttr, visuallyHiddenStyle, ariaAttr, getBeforeInputValue, getNativeEvent, isComposingEvent, isModifierKey, getEventKey, raf, dispatchInputValueEvent } from '@zag-js/dom-query';\nimport { invariant, compact, isEqual } from '@zag-js/utils';\nimport { createMachine, choose } from '@zag-js/core';\n\n// src/pin-input.anatomy.ts\nvar anatomy = createAnatomy(\"pinInput\").parts(\"root\", \"label\", \"input\", \"control\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `pin-input:${ctx.id}`,\n  getInputId: (ctx, id) => ctx.ids?.input?.(id) ?? `pin-input:${ctx.id}:${id}`,\n  getHiddenInputId: ctx => ctx.ids?.hiddenInput ?? `pin-input:${ctx.id}:hidden`,\n  getLabelId: ctx => ctx.ids?.label ?? `pin-input:${ctx.id}:label`,\n  getControlId: ctx => ctx.ids?.control ?? `pin-input:${ctx.id}:control`,\n  getRootEl: ctx => dom.getById(ctx, dom.getRootId(ctx)),\n  getInputEls: ctx => {\n    const ownerId = CSS.escape(dom.getRootId(ctx));\n    const selector = `input[data-ownedby=${ownerId}]`;\n    return queryAll(dom.getRootEl(ctx), selector);\n  },\n  getInputEl: (ctx, id) => dom.getById(ctx, dom.getInputId(ctx, id)),\n  getFocusedInputEl: ctx => dom.getInputEls(ctx)[ctx.focusedIndex],\n  getFirstInputEl: ctx => dom.getInputEls(ctx)[0],\n  getHiddenInputEl: ctx => dom.getById(ctx, dom.getHiddenInputId(ctx))\n});\n\n// src/pin-input.utils.ts\nvar REGEX = {\n  numeric: /^[0-9]+$/,\n  alphabetic: /^[A-Za-z]+$/,\n  alphanumeric: /^[a-zA-Z0-9]+$/i\n};\nfunction isValidType(ctx, value) {\n  if (!ctx.type) return true;\n  return !!REGEX[ctx.type]?.test(value);\n}\nfunction isValidValue(ctx, value) {\n  if (!ctx.pattern) return isValidType(ctx, value);\n  const regex = new RegExp(ctx.pattern, \"g\");\n  return regex.test(value);\n}\n\n// src/pin-input.connect.ts\nfunction connect(state, send, normalize) {\n  const complete = state.context.isValueComplete;\n  const invalid = state.context.invalid;\n  const focusedIndex = state.context.focusedIndex;\n  const translations = state.context.translations;\n  function focus() {\n    dom.getFirstInputEl(state.context)?.focus();\n  }\n  return {\n    focus,\n    value: state.context.value,\n    valueAsString: state.context.valueAsString,\n    complete,\n    setValue(value) {\n      if (!Array.isArray(value)) {\n        invariant(\"[pin-input/setValue] value must be an array\");\n      }\n      send({\n        type: \"VALUE.SET\",\n        value\n      });\n    },\n    clearValue() {\n      send({\n        type: \"VALUE.CLEAR\"\n      });\n    },\n    setValueAtIndex(index, value) {\n      send({\n        type: \"VALUE.SET\",\n        value,\n        index\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        dir: state.context.dir,\n        ...parts.root.attrs,\n        id: dom.getRootId(state.context),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-disabled\": dataAttr(state.context.disabled),\n        \"data-complete\": dataAttr(complete),\n        \"data-readonly\": dataAttr(state.context.readOnly)\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        dir: state.context.dir,\n        htmlFor: dom.getHiddenInputId(state.context),\n        id: dom.getLabelId(state.context),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-disabled\": dataAttr(state.context.disabled),\n        \"data-complete\": dataAttr(complete),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        onClick(event) {\n          event.preventDefault();\n          focus();\n        }\n      });\n    },\n    getHiddenInputProps() {\n      return normalize.input({\n        \"aria-hidden\": true,\n        type: \"text\",\n        tabIndex: -1,\n        id: dom.getHiddenInputId(state.context),\n        readOnly: state.context.readOnly,\n        disabled: state.context.disabled,\n        required: state.context.required,\n        name: state.context.name,\n        form: state.context.form,\n        style: visuallyHiddenStyle,\n        maxLength: state.context.valueLength,\n        defaultValue: state.context.valueAsString\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        dir: state.context.dir,\n        id: dom.getControlId(state.context)\n      });\n    },\n    getInputProps(props) {\n      const {\n        index\n      } = props;\n      const inputType = state.context.type === \"numeric\" ? \"tel\" : \"text\";\n      return normalize.input({\n        ...parts.input.attrs,\n        dir: state.context.dir,\n        disabled: state.context.disabled,\n        \"data-disabled\": dataAttr(state.context.disabled),\n        \"data-complete\": dataAttr(complete),\n        id: dom.getInputId(state.context, index.toString()),\n        \"data-ownedby\": dom.getRootId(state.context),\n        \"aria-label\": translations.inputLabel(index, state.context.valueLength),\n        inputMode: state.context.otp || state.context.type === \"numeric\" ? \"numeric\" : \"text\",\n        \"aria-invalid\": ariaAttr(invalid),\n        \"data-invalid\": dataAttr(invalid),\n        type: state.context.mask ? \"password\" : inputType,\n        defaultValue: state.context.value[index] || \"\",\n        readOnly: state.context.readOnly,\n        autoCapitalize: \"none\",\n        autoComplete: state.context.otp ? \"one-time-code\" : \"off\",\n        placeholder: focusedIndex === index ? \"\" : state.context.placeholder,\n        onBeforeInput(event) {\n          try {\n            const value = getBeforeInputValue(event);\n            const isValid = isValidValue(state.context, value);\n            if (!isValid) {\n              send({\n                type: \"VALUE.INVALID\",\n                value\n              });\n              event.preventDefault();\n            }\n            if (value.length > 2) {\n              event.currentTarget.setSelectionRange(0, 1, \"forward\");\n            }\n          } catch {}\n        },\n        onChange(event) {\n          const evt = getNativeEvent(event);\n          const {\n            value\n          } = event.currentTarget;\n          if (evt.inputType === \"insertFromPaste\" || value.length > 2) {\n            send({\n              type: \"INPUT.PASTE\",\n              value\n            });\n            event.currentTarget.value = value[0];\n            event.preventDefault();\n            return;\n          }\n          if (evt.inputType === \"deleteContentBackward\") {\n            send(\"INPUT.BACKSPACE\");\n            return;\n          }\n          send({\n            type: \"INPUT.CHANGE\",\n            value,\n            index\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (isComposingEvent(event)) return;\n          if (isModifierKey(event)) return;\n          const keyMap = {\n            Backspace() {\n              send(\"INPUT.BACKSPACE\");\n            },\n            Delete() {\n              send(\"INPUT.DELETE\");\n            },\n            ArrowLeft() {\n              send(\"INPUT.ARROW_LEFT\");\n            },\n            ArrowRight() {\n              send(\"INPUT.ARROW_RIGHT\");\n            },\n            Enter() {\n              send(\"INPUT.ENTER\");\n            }\n          };\n          const exec = keyMap[getEventKey(event, state.context)];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        },\n        onFocus() {\n          send({\n            type: \"INPUT.FOCUS\",\n            index\n          });\n        },\n        onBlur() {\n          send({\n            type: \"INPUT.BLUR\",\n            index\n          });\n        }\n      });\n    }\n  };\n}\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"pin-input\",\n    initial: \"idle\",\n    context: {\n      value: [],\n      placeholder: \"\\u25CB\",\n      otp: false,\n      type: \"numeric\",\n      ...ctx,\n      focusedIndex: -1,\n      translations: {\n        inputLabel: (index, length) => `pin code ${index + 1} of ${length}`,\n        ...ctx.translations\n      }\n    },\n    computed: {\n      valueLength: ctx2 => ctx2.value.length,\n      filledValueLength: ctx2 => ctx2.value.filter(v => v?.trim() !== \"\").length,\n      isValueComplete: ctx2 => ctx2.valueLength === ctx2.filledValueLength,\n      valueAsString: ctx2 => ctx2.value.join(\"\"),\n      focusedValue: ctx2 => ctx2.value[ctx2.focusedIndex] || \"\"\n    },\n    entry: choose([{\n      guard: \"autoFocus\",\n      actions: [\"setupValue\", \"setFocusIndexToFirst\"]\n    }, {\n      actions: [\"setupValue\"]\n    }]),\n    watch: {\n      focusedIndex: [\"focusInput\", \"selectInputIfNeeded\"],\n      value: [\"syncInputElements\"],\n      isValueComplete: [\"invokeOnComplete\", \"blurFocusedInputIfNeeded\"]\n    },\n    on: {\n      \"VALUE.SET\": [{\n        guard: \"hasIndex\",\n        actions: [\"setValueAtIndex\"]\n      }, {\n        actions: [\"setValue\"]\n      }],\n      \"VALUE.CLEAR\": {\n        actions: [\"clearValue\", \"setFocusIndexToFirst\"]\n      }\n    },\n    states: {\n      idle: {\n        on: {\n          \"INPUT.FOCUS\": {\n            target: \"focused\",\n            actions: \"setFocusedIndex\"\n          }\n        }\n      },\n      focused: {\n        on: {\n          \"INPUT.CHANGE\": [{\n            guard: \"isFinalValue\",\n            actions: [\"setFocusedValue\", \"syncInputValue\"]\n          }, {\n            actions: [\"setFocusedValue\", \"setNextFocusedIndex\", \"syncInputValue\"]\n          }],\n          \"INPUT.PASTE\": {\n            actions: [\"setPastedValue\", \"setLastValueFocusIndex\"]\n          },\n          \"INPUT.BLUR\": {\n            target: \"idle\",\n            actions: \"clearFocusedIndex\"\n          },\n          \"INPUT.DELETE\": {\n            guard: \"hasValue\",\n            actions: \"clearFocusedValue\"\n          },\n          \"INPUT.ARROW_LEFT\": {\n            actions: \"setPrevFocusedIndex\"\n          },\n          \"INPUT.ARROW_RIGHT\": {\n            actions: \"setNextFocusedIndex\"\n          },\n          \"INPUT.BACKSPACE\": [{\n            guard: \"hasValue\",\n            actions: [\"clearFocusedValue\"]\n          }, {\n            actions: [\"setPrevFocusedIndex\", \"clearFocusedValue\"]\n          }],\n          \"INPUT.ENTER\": {\n            guard: \"isValueComplete\",\n            actions: \"requestFormSubmit\"\n          },\n          \"VALUE.INVALID\": {\n            actions: \"invokeOnInvalid\"\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      autoFocus: ctx2 => !!ctx2.autoFocus,\n      isValueEmpty: (_ctx, evt) => evt.value === \"\",\n      hasValue: ctx2 => ctx2.value[ctx2.focusedIndex] !== \"\",\n      isValueComplete: ctx2 => ctx2.isValueComplete,\n      isFinalValue: ctx2 => ctx2.filledValueLength + 1 === ctx2.valueLength && ctx2.value.findIndex(v => v.trim() === \"\") === ctx2.focusedIndex,\n      hasIndex: (_ctx, evt) => evt.index !== void 0,\n      isDisabled: ctx2 => !!ctx2.disabled\n    },\n    actions: {\n      setupValue(ctx2) {\n        if (ctx2.value.length) return;\n        const inputEls = dom.getInputEls(ctx2);\n        const emptyValues = Array.from({\n          length: inputEls.length\n        }).fill(\"\");\n        assignValue(ctx2, emptyValues);\n      },\n      focusInput(ctx2) {\n        if (ctx2.focusedIndex === -1) return;\n        dom.getFocusedInputEl(ctx2)?.focus({\n          preventScroll: true\n        });\n      },\n      selectInputIfNeeded(ctx2) {\n        if (!ctx2.selectOnFocus || ctx2.focusedIndex === -1) return;\n        raf(() => {\n          dom.getFocusedInputEl(ctx2)?.select();\n        });\n      },\n      invokeOnComplete(ctx2) {\n        if (!ctx2.isValueComplete) return;\n        ctx2.onValueComplete?.({\n          value: Array.from(ctx2.value),\n          valueAsString: ctx2.valueAsString\n        });\n      },\n      invokeOnInvalid(ctx2, evt) {\n        ctx2.onValueInvalid?.({\n          value: evt.value,\n          index: ctx2.focusedIndex\n        });\n      },\n      clearFocusedIndex(ctx2) {\n        ctx2.focusedIndex = -1;\n      },\n      setFocusedIndex(ctx2, evt) {\n        ctx2.focusedIndex = evt.index;\n      },\n      setValue(ctx2, evt) {\n        set.value(ctx2, evt.value);\n      },\n      setFocusedValue(ctx2, evt) {\n        const nextValue = getNextValue(ctx2.focusedValue, evt.value);\n        set.valueAtIndex(ctx2, ctx2.focusedIndex, nextValue);\n      },\n      revertInputValue(ctx2) {\n        const inputEl = dom.getFocusedInputEl(ctx2);\n        dom.setValue(inputEl, ctx2.focusedValue);\n      },\n      syncInputValue(ctx2, evt) {\n        const inputEl = dom.getInputEl(ctx2, evt.index.toString());\n        dom.setValue(inputEl, ctx2.value[evt.index]);\n      },\n      syncInputElements(ctx2) {\n        const inputEls = dom.getInputEls(ctx2);\n        inputEls.forEach((inputEl, index) => {\n          dom.setValue(inputEl, ctx2.value[index]);\n        });\n      },\n      setPastedValue(ctx2, evt) {\n        raf(() => {\n          const startIndex = Math.min(ctx2.focusedIndex, ctx2.filledValueLength);\n          const left = startIndex > 0 ? ctx2.valueAsString.substring(0, ctx2.focusedIndex) : \"\";\n          const right = evt.value.substring(0, ctx2.valueLength - startIndex);\n          const value = left + right;\n          set.value(ctx2, value.split(\"\"));\n        });\n      },\n      setValueAtIndex(ctx2, evt) {\n        const nextValue = getNextValue(ctx2.focusedValue, evt.value);\n        set.valueAtIndex(ctx2, evt.index, nextValue);\n      },\n      clearValue(ctx2) {\n        const nextValue = Array.from({\n          length: ctx2.valueLength\n        }).fill(\"\");\n        set.value(ctx2, nextValue);\n      },\n      clearFocusedValue(ctx2) {\n        set.valueAtIndex(ctx2, ctx2.focusedIndex, \"\");\n      },\n      setFocusIndexToFirst(ctx2) {\n        ctx2.focusedIndex = 0;\n      },\n      setNextFocusedIndex(ctx2) {\n        ctx2.focusedIndex = Math.min(ctx2.focusedIndex + 1, ctx2.valueLength - 1);\n      },\n      setPrevFocusedIndex(ctx2) {\n        ctx2.focusedIndex = Math.max(ctx2.focusedIndex - 1, 0);\n      },\n      setLastValueFocusIndex(ctx2) {\n        raf(() => {\n          ctx2.focusedIndex = Math.min(ctx2.filledValueLength, ctx2.valueLength - 1);\n        });\n      },\n      blurFocusedInputIfNeeded(ctx2) {\n        if (!ctx2.blurOnComplete) return;\n        raf(() => {\n          dom.getFocusedInputEl(ctx2)?.blur();\n        });\n      },\n      requestFormSubmit(ctx2) {\n        if (!ctx2.name || !ctx2.isValueComplete) return;\n        const inputEl = dom.getHiddenInputEl(ctx2);\n        inputEl?.form?.requestSubmit();\n      }\n    }\n  });\n}\nfunction assignValue(ctx, value) {\n  const arr = Array.isArray(value) ? value : value.split(\"\").filter(Boolean);\n  arr.forEach((value2, index) => {\n    ctx.value[index] = value2;\n  });\n}\nfunction getNextValue(current, next) {\n  let nextValue = next;\n  if (current[0] === next[0]) nextValue = next[1];else if (current[0] === next[1]) nextValue = next[0];\n  return nextValue.split(\"\")[nextValue.length - 1];\n}\nvar invoke = {\n  change(ctx) {\n    ctx.onValueChange?.({\n      value: Array.from(ctx.value),\n      valueAsString: ctx.valueAsString\n    });\n    const inputEl = dom.getHiddenInputEl(ctx);\n    dispatchInputValueEvent(inputEl, {\n      value: ctx.valueAsString\n    });\n  }\n};\nvar set = {\n  value(ctx, value) {\n    if (isEqual(ctx.value, value)) return;\n    assignValue(ctx, value);\n    invoke.change(ctx);\n  },\n  valueAtIndex(ctx, index, value) {\n    if (isEqual(ctx.value[index], value)) return;\n    ctx.value[index] = value;\n    invoke.change(ctx);\n  }\n};\nexport { anatomy, connect, machine };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
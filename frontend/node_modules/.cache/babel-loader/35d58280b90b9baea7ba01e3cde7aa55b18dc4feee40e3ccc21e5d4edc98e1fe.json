{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope } from '@zag-js/dom-query';\nimport { createMachine } from '@zag-js/core';\nimport { createSplitProps, compact, isObject } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/timer.anatomy.ts\nvar anatomy = createAnatomy(\"timer\").parts(\"root\", \"area\", \"control\", \"item\", \"itemValue\", \"itemLabel\", \"actionTrigger\", \"separator\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `timer:${ctx.id}:root`,\n  getAreaId: ctx => ctx.ids?.area ?? `timer:${ctx.id}:area`,\n  getAreaEl: ctx => dom.getById(ctx, dom.getAreaId(ctx))\n});\n\n// src/timer.connect.ts\nvar validActions = /* @__PURE__ */new Set([\"start\", \"pause\", \"resume\", \"reset\"]);\nfunction connect(state, send, normalize) {\n  const running = state.matches(\"running\");\n  const paused = state.matches(\"paused\");\n  const time = state.context.time;\n  const formattedTime = state.context.formattedTime;\n  const progressPercent = state.context.progressPercent;\n  return {\n    running,\n    paused,\n    time,\n    formattedTime,\n    progressPercent,\n    start() {\n      send(\"START\");\n    },\n    pause() {\n      send(\"PAUSE\");\n    },\n    resume() {\n      send(\"RESUME\");\n    },\n    reset() {\n      send(\"RESET\");\n    },\n    restart() {\n      send(\"RESTART\");\n    },\n    getRootProps() {\n      return normalize.element({\n        id: dom.getRootId(state.context),\n        ...parts.root.attrs\n      });\n    },\n    getAreaProps() {\n      return normalize.element({\n        role: \"timer\",\n        id: dom.getAreaId(state.context),\n        \"aria-label\": `${time.days} days ${formattedTime.hours}:${formattedTime.minutes}:${formattedTime.seconds}`,\n        \"aria-atomic\": true,\n        ...parts.area.attrs\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs\n      });\n    },\n    getItemProps(props2) {\n      const value = time[props2.type];\n      return normalize.element({\n        ...parts.item.attrs,\n        \"data-type\": props2.type,\n        style: {\n          \"--value\": value\n        }\n      });\n    },\n    getItemLabelProps(props2) {\n      return normalize.element({\n        ...parts.itemLabel.attrs,\n        \"data-type\": props2.type\n      });\n    },\n    getItemValueProps(props2) {\n      return normalize.element({\n        ...parts.itemValue.attrs,\n        \"data-type\": props2.type\n      });\n    },\n    getSeparatorProps() {\n      return normalize.element({\n        \"aria-hidden\": true,\n        ...parts.separator.attrs\n      });\n    },\n    getActionTriggerProps(props2) {\n      if (!validActions.has(props2.action)) {\n        throw new Error(`[zag-js] Invalid action: ${props2.action}. Must be one of: ${Array.from(validActions).join(\", \")}`);\n      }\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        hidden: (() => {\n          switch (props2.action) {\n            case \"start\":\n              return running || paused;\n            case \"pause\":\n              return !running;\n            case \"reset\":\n              return !running && !paused;\n            case \"resume\":\n              return !paused;\n            default:\n              return;\n          }\n        })(),\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send(props2.action.toUpperCase());\n        }\n      });\n    }\n  };\n}\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"timer\",\n    initial: ctx.autoStart ? \"running\" : \"idle\",\n    context: {\n      interval: 250,\n      ...ctx,\n      currentMs: ctx.startMs ?? 0\n    },\n    on: {\n      RESTART: {\n        target: \"running\",\n        actions: \"resetTime\"\n      }\n    },\n    computed: {\n      time: ctx2 => msToTime(ctx2.currentMs),\n      formattedTime: ctx2 => formatTime(ctx2.time),\n      progressPercent: ctx2 => {\n        const targetMs = ctx2.targetMs;\n        if (targetMs == null) return 0;\n        return toPercent(ctx2.currentMs, ctx2.startMs ?? 0, targetMs);\n      }\n    },\n    states: {\n      idle: {\n        on: {\n          START: \"running\",\n          RESET: {\n            actions: \"resetTime\"\n          }\n        }\n      },\n      running: {\n        every: {\n          TICK_INTERVAL: [\"sendTickEvent\"]\n        },\n        on: {\n          PAUSE: \"paused\",\n          TICK: [{\n            target: \"idle\",\n            guard: \"hasReachedTarget\",\n            actions: [\"invokeOnComplete\"]\n          }, {\n            actions: [\"updateTime\", \"invokeOnTick\"]\n          }],\n          RESET: {\n            actions: \"resetTime\"\n          }\n        }\n      },\n      paused: {\n        on: {\n          RESUME: \"running\",\n          RESET: {\n            target: \"idle\",\n            actions: \"resetTime\"\n          }\n        }\n      }\n    }\n  }, {\n    delays: {\n      TICK_INTERVAL: ctx2 => ctx2.interval\n    },\n    actions: {\n      updateTime(ctx2) {\n        const sign = ctx2.countdown ? -1 : 1;\n        ctx2.currentMs = ctx2.currentMs + sign * ctx2.interval;\n      },\n      sendTickEvent(_ctx, _evt, {\n        send\n      }) {\n        send({\n          type: \"TICK\"\n        });\n      },\n      resetTime(ctx2) {\n        ctx2.currentMs = ctx2.startMs ?? 0;\n      },\n      invokeOnTick(ctx2) {\n        ctx2.onTick?.({\n          value: ctx2.currentMs,\n          time: ctx2.time,\n          formattedTime: ctx2.formattedTime\n        });\n      },\n      invokeOnComplete(ctx2) {\n        ctx2.onComplete?.();\n      }\n    },\n    guards: {\n      hasReachedTarget: ctx2 => {\n        let targetMs = ctx2.targetMs;\n        if (targetMs == null && ctx2.countdown) targetMs = 0;\n        if (targetMs == null) return false;\n        return ctx2.currentMs === targetMs;\n      }\n    }\n  });\n}\nfunction msToTime(ms) {\n  const milliseconds = ms % 1e3;\n  const seconds = Math.floor(ms / 1e3) % 60;\n  const minutes = Math.floor(ms / (1e3 * 60)) % 60;\n  const hours = Math.floor(ms / (1e3 * 60 * 60)) % 24;\n  const days = Math.floor(ms / (1e3 * 60 * 60 * 24));\n  return {\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds\n  };\n}\nfunction toPercent(value, minValue, maxValue) {\n  return (value - minValue) / (maxValue - minValue);\n}\nfunction padStart(num, size = 2) {\n  return num.toString().padStart(size, \"0\");\n}\nfunction formatTime(time) {\n  const {\n    days,\n    hours,\n    minutes,\n    seconds\n  } = time;\n  return {\n    days: padStart(days),\n    hours: padStart(hours),\n    minutes: padStart(minutes),\n    seconds: padStart(seconds),\n    milliseconds: time.milliseconds.toString()\n  };\n}\nvar segments = /* @__PURE__ */new Set([\"days\", \"hours\", \"minutes\", \"seconds\"]);\nfunction isTimeSegment(date) {\n  return isObject(date) && Object.keys(date).some(key => segments.has(key));\n}\nfunction parse(date) {\n  if (typeof date === \"string\") {\n    return new Date(date).getTime();\n  }\n  if (isTimeSegment(date)) {\n    const {\n      days = 0,\n      hours = 0,\n      minutes = 0,\n      seconds = 0,\n      milliseconds = 0\n    } = date;\n    const value = (days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60 + seconds) * 1e3;\n    return value + milliseconds;\n  }\n  throw new Error(\"Invalid date\");\n}\nvar props = createProps()([\"autoStart\", \"countdown\", \"getRootNode\", \"id\", \"ids\", \"interval\", \"onComplete\", \"onTick\", \"startMs\", \"targetMs\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, parse, props, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, queryAll, dataAttr, getEventStep, getEventKey, trackPointerMove, raf, getRelativePoint } from '@zag-js/dom-query';\nimport { createMachine } from '@zag-js/core';\nimport { createSplitProps, compact } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/splitter.anatomy.ts\nvar anatomy = createAnatomy(\"splitter\").parts(\"root\", \"panel\", \"resizeTrigger\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `splitter:${ctx.id}`,\n  getResizeTriggerId: (ctx, id) => ctx.ids?.resizeTrigger?.(id) ?? `splitter:${ctx.id}:splitter:${id}`,\n  getLabelId: ctx => ctx.ids?.label ?? `splitter:${ctx.id}:label`,\n  getPanelId: (ctx, id) => ctx.ids?.panel?.(id) ?? `splitter:${ctx.id}:panel:${id}`,\n  getGlobalCursorId: ctx => `splitter:${ctx.id}:global-cursor`,\n  getRootEl: ctx => dom.getById(ctx, dom.getRootId(ctx)),\n  getResizeTriggerEl: (ctx, id) => dom.getById(ctx, dom.getResizeTriggerId(ctx, id)),\n  getPanelEl: (ctx, id) => dom.getById(ctx, dom.getPanelId(ctx, id)),\n  getCursor(ctx) {\n    const x = ctx.isHorizontal;\n    let cursor = x ? \"col-resize\" : \"row-resize\";\n    if (ctx.activeResizeState.isAtMin) cursor = x ? \"e-resize\" : \"s-resize\";\n    if (ctx.activeResizeState.isAtMax) cursor = x ? \"w-resize\" : \"n-resize\";\n    return cursor;\n  },\n  getPanelStyle(ctx, id) {\n    const flexGrow = ctx.panels.find(panel => panel.id === id)?.size ?? \"0\";\n    return {\n      flexBasis: 0,\n      flexGrow,\n      flexShrink: 1,\n      overflow: \"hidden\"\n    };\n  },\n  getActiveHandleEl(ctx) {\n    const activeId = ctx.activeResizeId;\n    if (activeId == null) return;\n    return dom.getById(ctx, dom.getResizeTriggerId(ctx, activeId));\n  },\n  getResizeTriggerEls(ctx) {\n    const ownerId = CSS.escape(dom.getRootId(ctx));\n    return queryAll(dom.getRootEl(ctx), `[role=separator][data-ownedby='${ownerId}']`);\n  },\n  setupGlobalCursor(ctx) {\n    const styleEl = dom.getById(ctx, dom.getGlobalCursorId(ctx));\n    const textContent = `* { cursor: ${dom.getCursor(ctx)} !important; }`;\n    if (styleEl) {\n      styleEl.textContent = textContent;\n    } else {\n      const style = dom.getDoc(ctx).createElement(\"style\");\n      style.id = dom.getGlobalCursorId(ctx);\n      style.textContent = textContent;\n      dom.getDoc(ctx).head.appendChild(style);\n    }\n  },\n  removeGlobalCursor(ctx) {\n    dom.getById(ctx, dom.getGlobalCursorId(ctx))?.remove();\n  }\n});\n\n// src/splitter.utils.ts\nfunction validateSize(key, size) {\n  if (Math.floor(size) > 100) {\n    throw new Error(`Total ${key} of panels cannot be greater than 100`);\n  }\n}\nfunction getNormalizedPanels(ctx) {\n  let numOfPanelsWithoutSize = 0;\n  let totalSize = 0;\n  let totalMinSize = 0;\n  const panels = ctx.size.map(panel => {\n    const minSize = panel.minSize ?? 0;\n    const maxSize = panel.maxSize ?? 100;\n    totalMinSize += minSize;\n    if (panel.size == null) {\n      numOfPanelsWithoutSize++;\n    } else {\n      totalSize += panel.size;\n    }\n    return {\n      ...panel,\n      minSize,\n      maxSize\n    };\n  });\n  validateSize(\"minSize\", totalMinSize);\n  validateSize(\"size\", totalSize);\n  let end = 0;\n  let remainingSize = 0;\n  const result = panels.map(panel => {\n    let start = end;\n    if (panel.size != null) {\n      end += panel.size;\n      remainingSize = panel.size - panel.minSize;\n      return {\n        ...panel,\n        start,\n        end,\n        remainingSize\n      };\n    }\n    const size = (100 - totalSize) / numOfPanelsWithoutSize;\n    end += size;\n    remainingSize = size - panel.minSize;\n    return {\n      ...panel,\n      size,\n      start,\n      end,\n      remainingSize\n    };\n  });\n  return result;\n}\nfunction getHandlePanels(ctx, id = ctx.activeResizeId) {\n  const [beforeId, afterId] = id?.split(\":\") ?? [];\n  if (!beforeId || !afterId) return;\n  const beforeIndex = ctx.previousPanels.findIndex(panel => panel.id === beforeId);\n  const afterIndex = ctx.previousPanels.findIndex(panel => panel.id === afterId);\n  if (beforeIndex === -1 || afterIndex === -1) return;\n  const before = ctx.previousPanels[beforeIndex];\n  const after = ctx.previousPanels[afterIndex];\n  return {\n    before: {\n      ...before,\n      index: beforeIndex\n    },\n    after: {\n      ...after,\n      index: afterIndex\n    }\n  };\n}\nfunction getHandleBounds(ctx, id = ctx.activeResizeId) {\n  const panels = getHandlePanels(ctx, id);\n  if (!panels) return;\n  const {\n    before,\n    after\n  } = panels;\n  return {\n    min: Math.max(before.start + before.minSize, after.end - after.maxSize),\n    max: Math.min(after.end - after.minSize, before.maxSize + before.start)\n  };\n}\nfunction getPanelBounds(ctx, id) {\n  const bounds = getHandleBounds(ctx, id);\n  const panels = getHandlePanels(ctx, id);\n  if (!bounds || !panels) return;\n  const {\n    before,\n    after\n  } = panels;\n  const beforeMin = Math.abs(before.start - bounds.min);\n  const afterMin = after.size + (before.size - beforeMin);\n  const beforeMax = Math.abs(before.start - bounds.max);\n  const afterMax = after.size - (beforeMax - before.size);\n  return {\n    before: {\n      index: before.index,\n      min: beforeMin,\n      max: beforeMax,\n      isAtMin: beforeMin === before.size,\n      isAtMax: beforeMax === before.size,\n      up(step) {\n        return Math.min(before.size + step, beforeMax);\n      },\n      down(step) {\n        return Math.max(before.size - step, beforeMin);\n      }\n    },\n    after: {\n      index: after.index,\n      min: afterMin,\n      max: afterMax,\n      isAtMin: afterMin === after.size,\n      isAtMax: afterMax === after.size,\n      up(step) {\n        return Math.min(after.size + step, afterMin);\n      },\n      down(step) {\n        return Math.max(after.size - step, afterMax);\n      }\n    }\n  };\n}\nfunction clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n\n// src/splitter.connect.ts\nfunction connect(state, send, normalize) {\n  const horizontal = state.context.isHorizontal;\n  const focused = state.hasTag(\"focus\");\n  const dragging = state.matches(\"dragging\");\n  const panels = state.context.panels;\n  function getResizeTriggerState(props2) {\n    const {\n      id,\n      disabled\n    } = props2;\n    const ids = id.split(\":\");\n    const panelIds = ids.map(id2 => dom.getPanelId(state.context, id2));\n    const panels2 = getHandleBounds(state.context, id);\n    return {\n      disabled: !!disabled,\n      focused: state.context.activeResizeId === id && focused,\n      panelIds,\n      min: panels2?.min,\n      max: panels2?.max,\n      value: 0\n    };\n  }\n  return {\n    focused,\n    dragging,\n    getResizeTriggerState,\n    bounds: getHandleBounds(state.context),\n    setToMinSize(id) {\n      const panel = panels.find(panel2 => panel2.id === id);\n      send({\n        type: \"SET_PANEL_SIZE\",\n        id,\n        size: panel?.minSize,\n        src: \"setToMinSize\"\n      });\n    },\n    setToMaxSize(id) {\n      const panel = panels.find(panel2 => panel2.id === id);\n      send({\n        type: \"SET_PANEL_SIZE\",\n        id,\n        size: panel?.maxSize,\n        src: \"setToMaxSize\"\n      });\n    },\n    setSize(id, size) {\n      send({\n        type: \"SET_PANEL_SIZE\",\n        id,\n        size\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-orientation\": state.context.orientation,\n        id: dom.getRootId(state.context),\n        dir: state.context.dir,\n        style: {\n          display: \"flex\",\n          flexDirection: horizontal ? \"row\" : \"column\",\n          height: \"100%\",\n          width: \"100%\",\n          overflow: \"hidden\"\n        }\n      });\n    },\n    getPanelProps(props2) {\n      const {\n        id\n      } = props2;\n      return normalize.element({\n        ...parts.panel.attrs,\n        \"data-orientation\": state.context.orientation,\n        dir: state.context.dir,\n        id: dom.getPanelId(state.context, id),\n        \"data-ownedby\": dom.getRootId(state.context),\n        style: dom.getPanelStyle(state.context, id)\n      });\n    },\n    getResizeTriggerProps(props2) {\n      const {\n        id,\n        disabled,\n        step = 1\n      } = props2;\n      const triggerState = getResizeTriggerState(props2);\n      return normalize.element({\n        ...parts.resizeTrigger.attrs,\n        dir: state.context.dir,\n        id: dom.getResizeTriggerId(state.context, id),\n        role: \"separator\",\n        \"data-ownedby\": dom.getRootId(state.context),\n        tabIndex: disabled ? void 0 : 0,\n        \"aria-valuenow\": triggerState.value,\n        \"aria-valuemin\": triggerState.min,\n        \"aria-valuemax\": triggerState.max,\n        \"data-orientation\": state.context.orientation,\n        \"aria-orientation\": state.context.orientation,\n        \"aria-controls\": triggerState.panelIds.join(\" \"),\n        \"data-focus\": dataAttr(triggerState.focused),\n        \"data-disabled\": dataAttr(disabled),\n        style: {\n          touchAction: \"none\",\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\",\n          flex: \"0 0 auto\",\n          pointerEvents: dragging && !triggerState.focused ? \"none\" : void 0,\n          cursor: horizontal ? \"col-resize\" : \"row-resize\",\n          [horizontal ? \"minHeight\" : \"minWidth\"]: \"0\"\n        },\n        onPointerDown(event) {\n          if (disabled) {\n            event.preventDefault();\n            return;\n          }\n          send({\n            type: \"POINTER_DOWN\",\n            id\n          });\n          event.currentTarget.setPointerCapture(event.pointerId);\n          event.preventDefault();\n          event.stopPropagation();\n        },\n        onPointerUp(event) {\n          if (disabled) return;\n          if (event.currentTarget.hasPointerCapture(event.pointerId)) {\n            event.currentTarget.releasePointerCapture(event.pointerId);\n          }\n        },\n        onPointerOver() {\n          if (disabled) return;\n          send({\n            type: \"POINTER_OVER\",\n            id\n          });\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send({\n            type: \"POINTER_LEAVE\",\n            id\n          });\n        },\n        onBlur() {\n          send(\"BLUR\");\n        },\n        onFocus() {\n          send({\n            type: \"FOCUS\",\n            id\n          });\n        },\n        onDoubleClick() {\n          if (disabled) return;\n          send({\n            type: \"DOUBLE_CLICK\",\n            id\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          const moveStep = getEventStep(event) * step;\n          const keyMap = {\n            Enter() {\n              send(\"ENTER\");\n            },\n            ArrowUp() {\n              send({\n                type: \"ARROW_UP\",\n                step: moveStep\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"ARROW_DOWN\",\n                step: moveStep\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"ARROW_LEFT\",\n                step: moveStep\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"ARROW_RIGHT\",\n                step: moveStep\n              });\n            },\n            Home() {\n              send(\"HOME\");\n            },\n            End() {\n              send(\"END\");\n            }\n          };\n          const key = getEventKey(event, state.context);\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    }\n  };\n}\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"splitter\",\n    initial: \"idle\",\n    context: {\n      orientation: \"horizontal\",\n      activeResizeId: null,\n      previousPanels: [],\n      size: [],\n      initialSize: [],\n      activeResizeState: {\n        isAtMin: false,\n        isAtMax: false\n      },\n      ...ctx\n    },\n    created: [\"setPreviousPanels\", \"setInitialSize\"],\n    watch: {\n      size: [\"setActiveResizeState\"]\n    },\n    computed: {\n      isHorizontal: ctx2 => ctx2.orientation === \"horizontal\",\n      panels: ctx2 => getNormalizedPanels(ctx2)\n    },\n    on: {\n      SET_PANEL_SIZE: {\n        actions: \"setPanelSize\"\n      }\n    },\n    states: {\n      idle: {\n        entry: [\"clearActiveHandleId\"],\n        on: {\n          POINTER_OVER: {\n            target: \"hover:temp\",\n            actions: [\"setActiveHandleId\"]\n          },\n          FOCUS: {\n            target: \"focused\",\n            actions: [\"setActiveHandleId\"]\n          },\n          DOUBLE_CLICK: {\n            actions: [\"resetStartPanel\", \"setPreviousPanels\"]\n          }\n        }\n      },\n      \"hover:temp\": {\n        after: {\n          HOVER_DELAY: \"hover\"\n        },\n        on: {\n          POINTER_DOWN: {\n            target: \"dragging\",\n            actions: [\"setActiveHandleId\"]\n          },\n          POINTER_LEAVE: \"idle\"\n        }\n      },\n      hover: {\n        tags: [\"focus\"],\n        on: {\n          POINTER_DOWN: \"dragging\",\n          POINTER_LEAVE: \"idle\"\n        }\n      },\n      focused: {\n        tags: [\"focus\"],\n        on: {\n          BLUR: \"idle\",\n          POINTER_DOWN: {\n            target: \"dragging\",\n            actions: [\"setActiveHandleId\"]\n          },\n          ARROW_LEFT: {\n            guard: \"isHorizontal\",\n            actions: [\"shrinkStartPanel\", \"setPreviousPanels\"]\n          },\n          ARROW_RIGHT: {\n            guard: \"isHorizontal\",\n            actions: [\"expandStartPanel\", \"setPreviousPanels\"]\n          },\n          ARROW_UP: {\n            guard: \"isVertical\",\n            actions: [\"shrinkStartPanel\", \"setPreviousPanels\"]\n          },\n          ARROW_DOWN: {\n            guard: \"isVertical\",\n            actions: [\"expandStartPanel\", \"setPreviousPanels\"]\n          },\n          ENTER: [{\n            guard: \"isStartPanelAtMax\",\n            actions: [\"setStartPanelToMin\", \"setPreviousPanels\"]\n          }, {\n            actions: [\"setStartPanelToMax\", \"setPreviousPanels\"]\n          }],\n          HOME: {\n            actions: [\"setStartPanelToMin\", \"setPreviousPanels\"]\n          },\n          END: {\n            actions: [\"setStartPanelToMax\", \"setPreviousPanels\"]\n          }\n        }\n      },\n      dragging: {\n        tags: [\"focus\"],\n        entry: \"focusResizeHandle\",\n        activities: [\"trackPointerMove\"],\n        on: {\n          POINTER_MOVE: {\n            actions: [\"setPointerValue\", \"setGlobalCursor\", \"invokeOnResize\"]\n          },\n          POINTER_UP: {\n            target: \"focused\",\n            actions: [\"setPreviousPanels\", \"clearGlobalCursor\", \"blurResizeHandle\", \"invokeOnResizeEnd\"]\n          }\n        }\n      }\n    }\n  }, {\n    activities: {\n      trackPointerMove: (ctx2, _evt, {\n        send\n      }) => {\n        const doc = dom.getDoc(ctx2);\n        return trackPointerMove(doc, {\n          onPointerMove(info) {\n            send({\n              type: \"POINTER_MOVE\",\n              point: info.point\n            });\n          },\n          onPointerUp() {\n            send(\"POINTER_UP\");\n          }\n        });\n      }\n    },\n    guards: {\n      isStartPanelAtMin: ctx2 => ctx2.activeResizeState.isAtMin,\n      isStartPanelAtMax: ctx2 => ctx2.activeResizeState.isAtMax,\n      isHorizontal: ctx2 => ctx2.isHorizontal,\n      isVertical: ctx2 => !ctx2.isHorizontal\n    },\n    delays: {\n      HOVER_DELAY: 250\n    },\n    actions: {\n      setGlobalCursor(ctx2) {\n        dom.setupGlobalCursor(ctx2);\n      },\n      clearGlobalCursor(ctx2) {\n        dom.removeGlobalCursor(ctx2);\n      },\n      invokeOnResize(ctx2) {\n        ctx2.onSizeChange?.({\n          size: Array.from(ctx2.size),\n          activeHandleId: ctx2.activeResizeId\n        });\n      },\n      invokeOnResizeEnd(ctx2) {\n        ctx2.onSizeChangeEnd?.({\n          size: Array.from(ctx2.size),\n          activeHandleId: ctx2.activeResizeId\n        });\n      },\n      setActiveHandleId(ctx2, evt) {\n        ctx2.activeResizeId = evt.id;\n      },\n      clearActiveHandleId(ctx2) {\n        ctx2.activeResizeId = null;\n      },\n      setInitialSize(ctx2) {\n        ctx2.initialSize = ctx2.panels.slice().map(panel => ({\n          id: panel.id,\n          size: panel.size\n        }));\n      },\n      setPanelSize(ctx2, evt) {\n        const {\n          id,\n          size\n        } = evt;\n        ctx2.size = ctx2.size.map(panel => {\n          const panelSize = clamp(size, panel.minSize ?? 0, panel.maxSize ?? 100);\n          return panel.id === id ? {\n            ...panel,\n            size: panelSize\n          } : panel;\n        });\n      },\n      setStartPanelToMin(ctx2) {\n        const bounds = getPanelBounds(ctx2);\n        if (!bounds) return;\n        const {\n          before,\n          after\n        } = bounds;\n        ctx2.size[before.index].size = before.min;\n        ctx2.size[after.index].size = after.min;\n      },\n      setStartPanelToMax(ctx2) {\n        const bounds = getPanelBounds(ctx2);\n        if (!bounds) return;\n        const {\n          before,\n          after\n        } = bounds;\n        ctx2.size[before.index].size = before.max;\n        ctx2.size[after.index].size = after.max;\n      },\n      expandStartPanel(ctx2, evt) {\n        const bounds = getPanelBounds(ctx2);\n        if (!bounds) return;\n        const {\n          before,\n          after\n        } = bounds;\n        ctx2.size[before.index].size = before.up(evt.step);\n        ctx2.size[after.index].size = after.down(evt.step);\n      },\n      shrinkStartPanel(ctx2, evt) {\n        const bounds = getPanelBounds(ctx2);\n        if (!bounds) return;\n        const {\n          before,\n          after\n        } = bounds;\n        ctx2.size[before.index].size = before.down(evt.step);\n        ctx2.size[after.index].size = after.up(evt.step);\n      },\n      resetStartPanel(ctx2, evt) {\n        const bounds = getPanelBounds(ctx2, evt.id);\n        if (!bounds) return;\n        const {\n          before,\n          after\n        } = bounds;\n        ctx2.size[before.index].size = ctx2.initialSize[before.index].size;\n        ctx2.size[after.index].size = ctx2.initialSize[after.index].size;\n      },\n      focusResizeHandle(ctx2) {\n        raf(() => {\n          dom.getActiveHandleEl(ctx2)?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      blurResizeHandle(ctx2) {\n        raf(() => {\n          dom.getActiveHandleEl(ctx2)?.blur();\n        });\n      },\n      setPreviousPanels(ctx2) {\n        ctx2.previousPanels = ctx2.panels.slice();\n      },\n      setActiveResizeState(ctx2) {\n        const panels = getPanelBounds(ctx2);\n        if (!panels) return;\n        const {\n          before\n        } = panels;\n        ctx2.activeResizeState = {\n          isAtMin: before.isAtMin,\n          isAtMax: before.isAtMax\n        };\n      },\n      setPointerValue(ctx2, evt) {\n        const panels = getHandlePanels(ctx2);\n        const bounds = getHandleBounds(ctx2);\n        if (!panels || !bounds) return;\n        const rootEl = dom.getRootEl(ctx2);\n        if (!rootEl) return;\n        const relativePoint = getRelativePoint(evt.point, rootEl);\n        const percentValue = relativePoint.getPercentValue({\n          dir: ctx2.dir,\n          orientation: ctx2.orientation\n        });\n        let pointValue = percentValue * 100;\n        ctx2.activeResizeState = {\n          isAtMin: pointValue < bounds.min,\n          isAtMax: pointValue > bounds.max\n        };\n        pointValue = clamp(pointValue, bounds.min, bounds.max);\n        const {\n          before,\n          after\n        } = panels;\n        const offset = pointValue - before.end;\n        ctx2.size[before.index].size = before.size + offset;\n        ctx2.size[after.index].size = after.size - offset;\n      }\n    }\n  });\n}\nvar props = createProps()([\"dir\", \"getRootNode\", \"id\", \"ids\", \"onSizeChange\", \"onSizeChangeEnd\", \"orientation\", \"size\"]);\nvar splitProps = createSplitProps(props);\nvar panelProps = createProps()([\"id\", \"snapSize\"]);\nvar splitPanelProps = createSplitProps(panelProps);\nvar resizeTriggerProps = createProps()([\"disabled\", \"id\", \"step\"]);\nvar splitResizeTriggerProps = createSplitProps(resizeTriggerProps);\nexport { anatomy, connect, machine, panelProps, props, resizeTriggerProps, splitPanelProps, splitProps, splitResizeTriggerProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
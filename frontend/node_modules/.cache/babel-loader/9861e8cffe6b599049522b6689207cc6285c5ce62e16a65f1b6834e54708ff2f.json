{"ast":null,"code":"import { createProxy, isChanged, getUntracked, trackMemo } from 'proxy-compare';\n// This is required only for performance.\n// https://github.com/dai-shi/proxy-memoize/issues/68\nconst targetCache = new WeakMap();\n// constants from proxy-compare\nconst HAS_KEY_PROPERTY = 'h';\nconst ALL_OWN_KEYS_PROPERTY = 'w';\nconst HAS_OWN_KEY_PROPERTY = 'o';\nconst KEYS_PROPERTY = 'k';\nconst trackMemoUntrackedObjSet = new WeakSet();\nconst isObject = x => typeof x === 'object' && x !== null;\nconst untrack = (x, seen) => {\n  if (!isObject(x)) return x;\n  const untrackedObj = getUntracked(x);\n  if (untrackedObj) {\n    trackMemo(x);\n    trackMemoUntrackedObjSet.add(untrackedObj);\n    return untrackedObj;\n  }\n  if (!seen.has(x)) {\n    seen.add(x);\n    Object.entries(x).forEach(([k, v]) => {\n      const vv = untrack(v, seen);\n      if (!Object.is(vv, v)) x[k] = vv;\n    });\n  }\n  return x;\n};\nconst touchAffected = (dst, src, affected) => {\n  var _a, _b, _c;\n  if (!isObject(dst) || !isObject(src)) return;\n  const untrackedObj = getUntracked(src);\n  const used = affected.get(untrackedObj || src);\n  if (!used) {\n    if (trackMemoUntrackedObjSet.has(untrackedObj)) {\n      trackMemo(dst);\n    }\n    return;\n  }\n  (_a = used[HAS_KEY_PROPERTY]) === null || _a === void 0 ? void 0 : _a.forEach(key => {\n    Reflect.has(dst, key);\n  });\n  if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n    Reflect.ownKeys(dst);\n  }\n  (_b = used[HAS_OWN_KEY_PROPERTY]) === null || _b === void 0 ? void 0 : _b.forEach(key => {\n    Reflect.getOwnPropertyDescriptor(dst, key);\n  });\n  (_c = used[KEYS_PROPERTY]) === null || _c === void 0 ? void 0 : _c.forEach(key => {\n    touchAffected(dst[key], src[key], affected);\n  });\n};\nconst isOriginalEqual = (x, y) => {\n  for (let xx = x; xx; x = xx, xx = getUntracked(xx));\n  for (let yy = y; yy; y = yy, yy = getUntracked(yy));\n  return Object.is(x, y);\n};\n// properties\nconst OBJ_PROPERTY = 'o';\nconst RESULT_PROPERTY = 'r';\nconst AFFECTED_PROPERTY = 'a';\n/**\n * Create a memoized function\n *\n * @example\n * import { memoize } from 'proxy-memoize';\n *\n * const fn = memoize(obj => ({ sum: obj.a + obj.b, diff: obj.a - obj.b }));\n *\n * @param options\n * @param options.size - (default: 1)\n * @param options.noWeakMap - disable tier-1 cache (default: false)\n */\nexport function memoize(fn, options) {\n  var _a;\n  let memoListHead = 0;\n  const size = (_a = options === null || options === void 0 ? void 0 : options.size) !== null && _a !== void 0 ? _a : 1;\n  const memoList = [];\n  const resultCache = (options === null || options === void 0 ? void 0 : options.noWeakMap) ? null : new WeakMap();\n  const memoizedFn = obj => {\n    const cache = resultCache === null || resultCache === void 0 ? void 0 : resultCache.get(obj);\n    if (cache) {\n      return cache;\n    }\n    for (let i = 0; i < size; i += 1) {\n      const memo = memoList[(memoListHead + i) % size];\n      if (!memo) break;\n      const {\n        [OBJ_PROPERTY]: memoObj,\n        [AFFECTED_PROPERTY]: memoAffected,\n        [RESULT_PROPERTY]: memoResult\n      } = memo;\n      if (!isChanged(memoObj, obj, memoAffected, new WeakMap(), isOriginalEqual)) {\n        touchAffected(obj, memoObj, memoAffected);\n        resultCache === null || resultCache === void 0 ? void 0 : resultCache.set(obj, memoResult);\n        return memoResult;\n      }\n    }\n    const affected = new WeakMap();\n    const proxy = createProxy(obj, affected, undefined, targetCache);\n    const result = untrack(fn(proxy), new WeakSet());\n    touchAffected(obj, obj, affected);\n    const entry = {\n      [OBJ_PROPERTY]: obj,\n      [RESULT_PROPERTY]: result,\n      [AFFECTED_PROPERTY]: affected\n    };\n    memoListHead = (memoListHead - 1 + size) % size;\n    memoList[memoListHead] = entry;\n    resultCache === null || resultCache === void 0 ? void 0 : resultCache.set(obj, result);\n    return result;\n  };\n  return memoizedFn;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
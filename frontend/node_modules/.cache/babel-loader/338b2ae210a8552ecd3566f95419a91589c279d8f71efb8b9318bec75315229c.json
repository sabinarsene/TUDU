{"ast":null,"code":"function $(e, t, u, x = h => h) {\n  return e * x(.5 - t * (.5 - u));\n}\nfunction se(e) {\n  return [-e[0], -e[1]];\n}\nfunction l(e, t) {\n  return [e[0] + t[0], e[1] + t[1]];\n}\nfunction a(e, t) {\n  return [e[0] - t[0], e[1] - t[1]];\n}\nfunction b(e, t) {\n  return [e[0] * t, e[1] * t];\n}\nfunction he(e, t) {\n  return [e[0] / t, e[1] / t];\n}\nfunction R(e) {\n  return [e[1], -e[0]];\n}\nfunction B(e, t) {\n  return e[0] * t[0] + e[1] * t[1];\n}\nfunction ue(e, t) {\n  return e[0] === t[0] && e[1] === t[1];\n}\nfunction ge(e) {\n  return Math.hypot(e[0], e[1]);\n}\nfunction de(e) {\n  return e[0] * e[0] + e[1] * e[1];\n}\nfunction A(e, t) {\n  return de(a(e, t));\n}\nfunction G(e) {\n  return he(e, ge(e));\n}\nfunction ie(e, t) {\n  return Math.hypot(e[1] - t[1], e[0] - t[0]);\n}\nfunction L(e, t, u) {\n  let x = Math.sin(u),\n    h = Math.cos(u),\n    y = e[0] - t[0],\n    n = e[1] - t[1],\n    f = y * h - n * x,\n    d = y * x + n * h;\n  return [f + t[0], d + t[1]];\n}\nfunction K(e, t, u) {\n  return l(e, b(a(t, e), u));\n}\nfunction ee(e, t, u) {\n  return l(e, b(t, u));\n}\nvar {\n    min: C,\n    PI: xe\n  } = Math,\n  pe = .275,\n  V = xe + 1e-4;\nfunction ce(e, t = {}) {\n  let {\n      size: u = 16,\n      smoothing: x = .5,\n      thinning: h = .5,\n      simulatePressure: y = !0,\n      easing: n = r => r,\n      start: f = {},\n      end: d = {},\n      last: D = !1\n    } = t,\n    {\n      cap: S = !0,\n      easing: j = r => r * (2 - r)\n    } = f,\n    {\n      cap: q = !0,\n      easing: c = r => --r * r * r + 1\n    } = d;\n  if (e.length === 0 || u <= 0) return [];\n  let p = e[e.length - 1].runningLength,\n    g = f.taper === !1 ? 0 : f.taper === !0 ? Math.max(u, p) : f.taper,\n    T = d.taper === !1 ? 0 : d.taper === !0 ? Math.max(u, p) : d.taper,\n    te = Math.pow(u * x, 2),\n    _ = [],\n    M = [],\n    H = e.slice(0, 10).reduce((r, i) => {\n      let o = i.pressure;\n      if (y) {\n        let s = C(1, i.distance / u),\n          W = C(1, 1 - s);\n        o = C(1, r + (W - r) * (s * pe));\n      }\n      return (r + o) / 2;\n    }, e[0].pressure),\n    m = $(u, h, e[e.length - 1].pressure, n),\n    U,\n    X = e[0].vector,\n    z = e[0].point,\n    F = z,\n    O = z,\n    E = F,\n    J = !1;\n  for (let r = 0; r < e.length; r++) {\n    let {\n        pressure: i\n      } = e[r],\n      {\n        point: o,\n        vector: s,\n        distance: W,\n        runningLength: I\n      } = e[r];\n    if (r < e.length - 1 && p - I < 3) continue;\n    if (h) {\n      if (y) {\n        let v = C(1, W / u),\n          Z = C(1, 1 - v);\n        i = C(1, H + (Z - H) * (v * pe));\n      }\n      m = $(u, h, i, n);\n    } else m = u / 2;\n    U === void 0 && (U = m);\n    let le = I < g ? j(I / g) : 1,\n      fe = p - I < T ? c((p - I) / T) : 1;\n    m = Math.max(.01, m * Math.min(le, fe));\n    let re = (r < e.length - 1 ? e[r + 1] : e[r]).vector,\n      Y = r < e.length - 1 ? B(s, re) : 1,\n      be = B(s, X) < 0 && !J,\n      ne = Y !== null && Y < 0;\n    if (be || ne) {\n      let v = b(R(X), m);\n      for (let Z = 1 / 13, w = 0; w <= 1; w += Z) O = L(a(o, v), o, V * w), _.push(O), E = L(l(o, v), o, V * -w), M.push(E);\n      z = O, F = E, ne && (J = !0);\n      continue;\n    }\n    if (J = !1, r === e.length - 1) {\n      let v = b(R(s), m);\n      _.push(a(o, v)), M.push(l(o, v));\n      continue;\n    }\n    let oe = b(R(K(re, s, Y)), m);\n    O = a(o, oe), (r <= 1 || A(z, O) > te) && (_.push(O), z = O), E = l(o, oe), (r <= 1 || A(F, E) > te) && (M.push(E), F = E), H = i, X = s;\n  }\n  let P = e[0].point.slice(0, 2),\n    k = e.length > 1 ? e[e.length - 1].point.slice(0, 2) : l(e[0].point, [1, 1]),\n    Q = [],\n    N = [];\n  if (e.length === 1) {\n    if (!(g || T) || D) {\n      let r = ee(P, G(R(a(P, k))), -(U || m)),\n        i = [];\n      for (let o = 1 / 13, s = o; s <= 1; s += o) i.push(L(r, P, V * 2 * s));\n      return i;\n    }\n  } else {\n    if (!(g || T && e.length === 1)) if (S) for (let i = 1 / 13, o = i; o <= 1; o += i) {\n      let s = L(M[0], P, V * o);\n      Q.push(s);\n    } else {\n      let i = a(_[0], M[0]),\n        o = b(i, .5),\n        s = b(i, .51);\n      Q.push(a(P, o), a(P, s), l(P, s), l(P, o));\n    }\n    let r = R(se(e[e.length - 1].vector));\n    if (T || g && e.length === 1) N.push(k);else if (q) {\n      let i = ee(k, r, m);\n      for (let o = 1 / 29, s = o; s < 1; s += o) N.push(L(i, k, V * 3 * s));\n    } else N.push(l(k, b(r, m)), l(k, b(r, m * .99)), a(k, b(r, m * .99)), a(k, b(r, m)));\n  }\n  return _.concat(N, M.reverse(), Q);\n}\nfunction me(e, t = {}) {\n  var q;\n  let {\n    streamline: u = .5,\n    size: x = 16,\n    last: h = !1\n  } = t;\n  if (e.length === 0) return [];\n  let y = .15 + (1 - u) * .85,\n    n = Array.isArray(e[0]) ? e : e.map(({\n      x: c,\n      y: p,\n      pressure: g = .5\n    }) => [c, p, g]);\n  if (n.length === 2) {\n    let c = n[1];\n    n = n.slice(0, -1);\n    for (let p = 1; p < 5; p++) n.push(K(n[0], c, p / 4));\n  }\n  n.length === 1 && (n = [...n, [...l(n[0], [1, 1]), ...n[0].slice(2)]]);\n  let f = [{\n      point: [n[0][0], n[0][1]],\n      pressure: n[0][2] >= 0 ? n[0][2] : .25,\n      vector: [1, 1],\n      distance: 0,\n      runningLength: 0\n    }],\n    d = !1,\n    D = 0,\n    S = f[0],\n    j = n.length - 1;\n  for (let c = 1; c < n.length; c++) {\n    let p = h && c === j ? n[c].slice(0, 2) : K(S.point, n[c], y);\n    if (ue(S.point, p)) continue;\n    let g = ie(p, S.point);\n    if (D += g, c < j && !d) {\n      if (D < x) continue;\n      d = !0;\n    }\n    S = {\n      point: p,\n      pressure: n[c][2] >= 0 ? n[c][2] : .5,\n      vector: G(a(S.point, p)),\n      distance: g,\n      runningLength: D\n    }, f.push(S);\n  }\n  return f[0].vector = ((q = f[1]) == null ? void 0 : q.vector) || [0, 0], f;\n}\nfunction ae(e, t = {}) {\n  return ce(me(e, t), t);\n}\nvar _e = ae;\nexport { _e as default, ae as getStroke, ce as getStrokeOutlinePoints, me as getStrokePoints };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
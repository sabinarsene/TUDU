{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, queryAll, prevById, nextById, indexOfId, dispatchInputValueEvent, dataAttr, ariaAttr, getNativeEvent, isComposingEvent, getEventKey, contains, trackFormControl, raf } from '@zag-js/dom-query';\nimport { autoResizeInput } from '@zag-js/auto-resize';\nimport { createMachine, guards } from '@zag-js/core';\nimport { trackInteractOutside } from '@zag-js/interact-outside';\nimport { createLiveRegion } from '@zag-js/live-region';\nimport { createSplitProps, compact, removeAt, warn, uniq, isEqual } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/tags-input.anatomy.ts\nvar anatomy = createAnatomy(\"tagsInput\").parts(\"root\", \"label\", \"control\", \"input\", \"clearTrigger\", \"item\", \"itemPreview\", \"itemInput\", \"itemText\", \"itemDeleteTrigger\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `tags-input:${ctx.id}`,\n  getInputId: ctx => ctx.ids?.input ?? `tags-input:${ctx.id}:input`,\n  getClearTriggerId: ctx => ctx.ids?.clearBtn ?? `tags-input:${ctx.id}:clear-btn`,\n  getHiddenInputId: ctx => ctx.ids?.hiddenInput ?? `tags-input:${ctx.id}:hidden-input`,\n  getLabelId: ctx => ctx.ids?.label ?? `tags-input:${ctx.id}:label`,\n  getControlId: ctx => ctx.ids?.control ?? `tags-input:${ctx.id}:control`,\n  getItemId: (ctx, opt) => ctx.ids?.item?.(opt) ?? `tags-input:${ctx.id}:tag:${opt.value}:${opt.index}`,\n  getItemDeleteTriggerId: (ctx, opt) => ctx.ids?.itemDeleteTrigger?.(opt) ?? `${dom.getItemId(ctx, opt)}:delete-btn`,\n  getItemInputId: (ctx, opt) => ctx.ids?.itemInput?.(opt) ?? `${dom.getItemId(ctx, opt)}:input`,\n  getEditInputId: ctx => `${ctx.editedTagId}:input`,\n  getTagInputEl: (ctx, opt) => dom.getById(ctx, dom.getItemInputId(ctx, opt)),\n  getRootEl: ctx => dom.getById(ctx, dom.getRootId(ctx)),\n  getInputEl: ctx => dom.getById(ctx, dom.getInputId(ctx)),\n  getHiddenInputEl: ctx => dom.getById(ctx, dom.getHiddenInputId(ctx)),\n  getEditInputEl: ctx => dom.getById(ctx, dom.getEditInputId(ctx)),\n  getTagElements: ctx => queryAll(dom.getRootEl(ctx), `[data-part=item-preview]:not([data-disabled])`),\n  getFirstEl: ctx => dom.getTagElements(ctx)[0],\n  getLastEl: ctx => dom.getTagElements(ctx)[dom.getTagElements(ctx).length - 1],\n  getPrevEl: (ctx, id) => prevById(dom.getTagElements(ctx), id, false),\n  getNextEl: (ctx, id) => nextById(dom.getTagElements(ctx), id, false),\n  getTagElAtIndex: (ctx, index) => dom.getTagElements(ctx)[index],\n  getIndexOfId: (ctx, id) => indexOfId(dom.getTagElements(ctx), id),\n  isInputFocused: ctx => dom.getDoc(ctx).activeElement === dom.getInputEl(ctx),\n  getHighlightedTagValue: ctx => {\n    if (!ctx.highlightedTagId) return null;\n    const tagEl = dom.getById(ctx, ctx.highlightedTagId);\n    return tagEl?.dataset.value ?? null;\n  },\n  setHoverIntent: el => {\n    const tagEl = el.closest(\"[data-part=item-preview]\");\n    if (!tagEl) return;\n    tagEl.dataset.deleteIntent = \"\";\n  },\n  clearHoverIntent: el => {\n    const tagEl = el.closest(\"[data-part=item-preview]\");\n    if (!tagEl) return;\n    delete tagEl.dataset.deleteIntent;\n  },\n  dispatchInputEvent(ctx) {\n    const inputEl = dom.getHiddenInputEl(ctx);\n    if (!inputEl) return;\n    dispatchInputValueEvent(inputEl, {\n      value: ctx.valueAsString\n    });\n  }\n});\n\n// src/tags-input.connect.ts\nfunction connect(state, send, normalize) {\n  const interactive = state.context.isInteractive;\n  const disabled = state.context.disabled;\n  const readOnly = state.context.readOnly;\n  const invalid = state.context.invalid || state.context.isOverflowing;\n  const translations = state.context.translations;\n  const focused = state.hasTag(\"focused\");\n  const editingTag = state.matches(\"editing:tag\");\n  const empty = state.context.count === 0;\n  function getItemState(options) {\n    const id = dom.getItemId(state.context, options);\n    return {\n      id,\n      editing: editingTag && state.context.editedTagId === id,\n      highlighted: id === state.context.highlightedTagId,\n      disabled: Boolean(options.disabled || disabled)\n    };\n  }\n  return {\n    empty,\n    inputValue: state.context.trimmedInputValue,\n    value: state.context.value,\n    valueAsString: state.context.valueAsString,\n    count: state.context.count,\n    atMax: state.context.isAtMax,\n    setValue(value) {\n      send({\n        type: \"SET_VALUE\",\n        value\n      });\n    },\n    clearValue(id) {\n      if (id) {\n        send({\n          type: \"CLEAR_TAG\",\n          id\n        });\n      } else {\n        send(\"CLEAR_VALUE\");\n      }\n    },\n    addValue(value) {\n      send({\n        type: \"ADD_TAG\",\n        value\n      });\n    },\n    setValueAtIndex(index, value) {\n      send({\n        type: \"SET_VALUE_AT_INDEX\",\n        index,\n        value\n      });\n    },\n    setInputValue(value) {\n      send({\n        type: \"SET_INPUT_VALUE\",\n        value\n      });\n    },\n    clearInputValue() {\n      send({\n        type: \"SET_INPUT_VALUE\",\n        value: \"\"\n      });\n    },\n    focus() {\n      dom.getInputEl(state.context)?.focus();\n    },\n    getItemState,\n    getRootProps() {\n      return normalize.element({\n        dir: state.context.dir,\n        ...parts.root.attrs,\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-focus\": dataAttr(focused),\n        \"data-empty\": dataAttr(empty),\n        id: dom.getRootId(state.context),\n        onPointerDown() {\n          if (!interactive) return;\n          send(\"POINTER_DOWN\");\n        }\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly),\n        id: dom.getLabelId(state.context),\n        dir: state.context.dir,\n        htmlFor: dom.getInputId(state.context)\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        id: dom.getControlId(state.context),\n        ...parts.control.attrs,\n        dir: state.context.dir,\n        tabIndex: readOnly ? 0 : void 0,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(readOnly),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-focus\": dataAttr(focused)\n      });\n    },\n    getInputProps() {\n      return normalize.input({\n        ...parts.input.attrs,\n        dir: state.context.dir,\n        \"data-invalid\": dataAttr(invalid),\n        \"aria-invalid\": ariaAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly),\n        maxLength: state.context.maxLength,\n        id: dom.getInputId(state.context),\n        defaultValue: state.context.inputValue,\n        autoComplete: \"off\",\n        autoCorrect: \"off\",\n        autoCapitalize: \"none\",\n        disabled: disabled || readOnly,\n        onInput(event) {\n          const evt = getNativeEvent(event);\n          const value = event.currentTarget.value;\n          if (evt.inputType === \"insertFromPaste\") {\n            send({\n              type: \"PASTE\",\n              value\n            });\n            return;\n          }\n          if (endsWith(value, state.context.delimiter)) {\n            send(\"DELIMITER_KEY\");\n            return;\n          }\n          send({\n            type: \"TYPE\",\n            value,\n            key: evt.inputType\n          });\n        },\n        onFocus() {\n          send(\"FOCUS\");\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (isComposingEvent(event)) return;\n          const target = event.currentTarget;\n          const isCombobox = target.getAttribute(\"role\") === \"combobox\";\n          const isExpanded = target.ariaExpanded === \"true\";\n          const keyMap = {\n            ArrowDown() {\n              send(\"ARROW_DOWN\");\n            },\n            ArrowLeft() {\n              if (isCombobox && isExpanded) return;\n              send(\"ARROW_LEFT\");\n            },\n            ArrowRight(event2) {\n              if (state.context.highlightedTagId) {\n                event2.preventDefault();\n              }\n              if (isCombobox && isExpanded) return;\n              send(\"ARROW_RIGHT\");\n            },\n            Escape(event2) {\n              event2.preventDefault();\n              send(\"ESCAPE\");\n            },\n            Backspace() {\n              send(\"BACKSPACE\");\n            },\n            Delete() {\n              send(\"DELETE\");\n            },\n            Enter(event2) {\n              if (isCombobox && isExpanded) return;\n              send(\"ENTER\");\n              event2.preventDefault();\n            }\n          };\n          const key = getEventKey(event, state.context);\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            return;\n          }\n        }\n      });\n    },\n    getHiddenInputProps() {\n      return normalize.input({\n        type: \"text\",\n        hidden: true,\n        name: state.context.name,\n        form: state.context.form,\n        disabled,\n        readOnly,\n        required: state.context.required,\n        id: dom.getHiddenInputId(state.context),\n        defaultValue: state.context.valueAsString\n      });\n    },\n    getItemProps(props2) {\n      return normalize.element({\n        ...parts.item.attrs,\n        dir: state.context.dir,\n        \"data-value\": props2.value,\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getItemPreviewProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        ...parts.itemPreview.attrs,\n        id: itemState.id,\n        dir: state.context.dir,\n        hidden: itemState.editing,\n        \"data-value\": props2.value,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        onPointerDown(event) {\n          if (!interactive || itemState.disabled) return;\n          event.preventDefault();\n          send({\n            type: \"POINTER_DOWN_TAG\",\n            id: itemState.id\n          });\n        },\n        onDoubleClick() {\n          if (!interactive || itemState.disabled) return;\n          send({\n            type: \"DOUBLE_CLICK_TAG\",\n            id: itemState.id\n          });\n        }\n      });\n    },\n    getItemTextProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        ...parts.itemText.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted)\n      });\n    },\n    getItemInputProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.input({\n        ...parts.itemInput.attrs,\n        dir: state.context.dir,\n        \"aria-label\": translations.tagEdited(props2.value),\n        \"aria-hidden\": true,\n        disabled,\n        id: dom.getItemInputId(state.context, props2),\n        tabIndex: -1,\n        hidden: !itemState.editing,\n        defaultValue: itemState.editing ? state.context.editedTagValue : \"\",\n        onInput(event) {\n          send({\n            type: \"TAG_INPUT_TYPE\",\n            value: event.currentTarget.value\n          });\n        },\n        onBlur(event) {\n          send({\n            type: \"TAG_INPUT_BLUR\",\n            target: event.relatedTarget,\n            id: itemState.id\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (isComposingEvent(event)) return;\n          const keyMap = {\n            Enter() {\n              send(\"TAG_INPUT_ENTER\");\n            },\n            Escape() {\n              send(\"TAG_INPUT_ESCAPE\");\n            }\n          };\n          const exec = keyMap[event.key];\n          if (exec) {\n            event.preventDefault();\n            exec(event);\n          }\n        }\n      });\n    },\n    getItemDeleteTriggerProps(props2) {\n      const id = dom.getItemId(state.context, props2);\n      return normalize.button({\n        ...parts.itemDeleteTrigger.attrs,\n        dir: state.context.dir,\n        id: dom.getItemDeleteTriggerId(state.context, props2),\n        type: \"button\",\n        disabled,\n        \"aria-label\": translations.deleteTagTriggerLabel(props2.value),\n        tabIndex: -1,\n        onPointerDown(event) {\n          if (!interactive) {\n            event.preventDefault();\n          }\n        },\n        onPointerMove(event) {\n          if (!interactive) return;\n          dom.setHoverIntent(event.currentTarget);\n        },\n        onPointerLeave(event) {\n          if (!interactive) return;\n          dom.clearHoverIntent(event.currentTarget);\n        },\n        onClick() {\n          if (!interactive) return;\n          send({\n            type: \"CLICK_DELETE_TAG\",\n            id\n          });\n        }\n      });\n    },\n    getClearTriggerProps() {\n      return normalize.button({\n        ...parts.clearTrigger.attrs,\n        dir: state.context.dir,\n        id: dom.getClearTriggerId(state.context),\n        type: \"button\",\n        \"data-readonly\": dataAttr(readOnly),\n        disabled,\n        \"aria-label\": translations.clearTriggerLabel,\n        hidden: empty,\n        onClick() {\n          if (!interactive) return;\n          send(\"CLEAR_VALUE\");\n        }\n      });\n    }\n  };\n}\nfunction endsWith(str, del) {\n  if (!del) return false;\n  if (typeof del === \"string\") return str.endsWith(del);\n  return new RegExp(`${del.source}$`).test(str);\n}\nvar {\n  and,\n  not,\n  or\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"tags-input\",\n    initial: ctx.autoFocus ? \"focused:input\" : \"idle\",\n    context: {\n      inputValue: \"\",\n      editedTagValue: \"\",\n      editedTagId: null,\n      highlightedTagId: null,\n      value: [],\n      dir: \"ltr\",\n      max: Infinity,\n      blurBehavior: void 0,\n      addOnPaste: false,\n      editable: true,\n      validate: () => true,\n      delimiter: \",\",\n      disabled: false,\n      readOnly: false,\n      ...ctx,\n      liveRegion: null,\n      log: {\n        current: null,\n        prev: null\n      },\n      fieldsetDisabled: false,\n      translations: {\n        clearTriggerLabel: \"Clear all tags\",\n        deleteTagTriggerLabel: value => `Delete tag ${value}`,\n        tagAdded: value => `Added tag ${value}`,\n        tagsPasted: values => `Pasted ${values.length} tags`,\n        tagEdited: value => `Editing tag ${value}. Press enter to save or escape to cancel.`,\n        tagUpdated: value => `Tag update to ${value}`,\n        tagDeleted: value => `Tag ${value} deleted`,\n        tagSelected: value => `Tag ${value} selected. Press enter to edit, delete or backspace to remove.`,\n        ...ctx.translations\n      }\n    },\n    computed: {\n      count: ctx2 => ctx2.value.length,\n      valueAsString: ctx2 => JSON.stringify(ctx2.value),\n      trimmedInputValue: ctx2 => ctx2.inputValue.trim(),\n      isDisabled: ctx2 => !!ctx2.disabled || ctx2.fieldsetDisabled,\n      isInteractive: ctx2 => !(ctx2.readOnly || ctx2.isDisabled),\n      isAtMax: ctx2 => ctx2.count === ctx2.max,\n      isOverflowing: ctx2 => ctx2.count > ctx2.max\n    },\n    watch: {\n      highlightedTagId: \"logHighlightedTag\",\n      isOverflowing: \"invokeOnInvalid\",\n      log: \"announceLog\",\n      inputValue: \"syncInputValue\",\n      editedTagValue: \"syncEditedTagInputValue\"\n    },\n    activities: [\"trackLiveRegion\", \"trackFormControlState\"],\n    exit: [\"clearLog\"],\n    on: {\n      DOUBLE_CLICK_TAG: {\n        internal: true,\n        guard: \"isTagEditable\",\n        target: \"editing:tag\",\n        actions: [\"setEditedId\", \"initializeEditedTagValue\"]\n      },\n      POINTER_DOWN_TAG: {\n        internal: true,\n        target: \"navigating:tag\",\n        actions: [\"highlightTag\", \"focusInput\"]\n      },\n      CLICK_DELETE_TAG: {\n        target: \"focused:input\",\n        actions: [\"deleteTag\"]\n      },\n      SET_INPUT_VALUE: {\n        actions: [\"setInputValue\"]\n      },\n      SET_VALUE: {\n        actions: [\"setValue\"]\n      },\n      CLEAR_TAG: {\n        actions: [\"deleteTag\"]\n      },\n      SET_VALUE_AT_INDEX: {\n        actions: [\"setValueAtIndex\"]\n      },\n      CLEAR_VALUE: {\n        actions: [\"clearTags\", \"clearInputValue\", \"focusInput\"]\n      },\n      ADD_TAG: {\n        actions: [\"addTag\"]\n      },\n      INSERT_TAG: {\n        // (!isAtMax || allowOverflow) && !inputValueIsEmpty\n        guard: and(or(not(\"isAtMax\"), \"allowOverflow\"), not(\"isInputValueEmpty\")),\n        actions: [\"addTag\", \"clearInputValue\"]\n      },\n      EXTERNAL_BLUR: [{\n        guard: \"addOnBlur\",\n        actions: \"raiseInsertTagEvent\"\n      }, {\n        guard: \"clearOnBlur\",\n        actions: \"clearInputValue\"\n      }]\n    },\n    states: {\n      idle: {\n        on: {\n          FOCUS: \"focused:input\",\n          POINTER_DOWN: {\n            guard: not(\"hasHighlightedTag\"),\n            target: \"focused:input\"\n          }\n        }\n      },\n      \"focused:input\": {\n        tags: [\"focused\"],\n        entry: [\"focusInput\", \"clearHighlightedId\"],\n        activities: [\"trackInteractOutside\"],\n        on: {\n          TYPE: {\n            actions: \"setInputValue\"\n          },\n          BLUR: [{\n            guard: \"addOnBlur\",\n            target: \"idle\",\n            actions: \"raiseInsertTagEvent\"\n          }, {\n            guard: \"clearOnBlur\",\n            target: \"idle\",\n            actions: \"clearInputValue\"\n          }, {\n            target: \"idle\"\n          }],\n          ENTER: {\n            actions: [\"raiseInsertTagEvent\"]\n          },\n          DELIMITER_KEY: {\n            actions: [\"raiseInsertTagEvent\"]\n          },\n          ARROW_LEFT: {\n            guard: and(\"hasTags\", \"isInputCaretAtStart\"),\n            target: \"navigating:tag\",\n            actions: \"highlightLastTag\"\n          },\n          BACKSPACE: {\n            target: \"navigating:tag\",\n            guard: and(\"hasTags\", \"isInputCaretAtStart\"),\n            actions: \"highlightLastTag\"\n          },\n          DELETE: {\n            guard: \"hasHighlightedTag\",\n            actions: [\"deleteHighlightedTag\", \"highlightTagAtIndex\"]\n          },\n          PASTE: [{\n            guard: \"addOnPaste\",\n            actions: [\"setInputValue\", \"addTagFromPaste\"]\n          }, {\n            actions: \"setInputValue\"\n          }]\n        }\n      },\n      \"navigating:tag\": {\n        tags: [\"focused\"],\n        activities: [\"trackInteractOutside\"],\n        on: {\n          ARROW_RIGHT: [{\n            guard: and(\"hasTags\", \"isInputCaretAtStart\", not(\"isLastTagHighlighted\")),\n            actions: \"highlightNextTag\"\n          }, {\n            target: \"focused:input\"\n          }],\n          ARROW_LEFT: {\n            actions: \"highlightPrevTag\"\n          },\n          BLUR: {\n            target: \"idle\",\n            actions: \"clearHighlightedId\"\n          },\n          ENTER: {\n            guard: and(\"isTagEditable\", \"hasHighlightedTag\"),\n            target: \"editing:tag\",\n            actions: [\"setEditedId\", \"initializeEditedTagValue\", \"focusEditedTagInput\"]\n          },\n          ARROW_DOWN: \"focused:input\",\n          ESCAPE: \"focused:input\",\n          TYPE: {\n            target: \"focused:input\",\n            actions: \"setInputValue\"\n          },\n          BACKSPACE: [{\n            guard: \"isFirstTagHighlighted\",\n            actions: [\"deleteHighlightedTag\", \"highlightFirstTag\"]\n          }, {\n            guard: \"hasHighlightedTag\",\n            actions: [\"deleteHighlightedTag\", \"highlightPrevTag\"]\n          }, {\n            actions: [\"highlightLastTag\"]\n          }],\n          DELETE: {\n            target: \"focused:input\",\n            actions: [\"deleteHighlightedTag\", \"highlightTagAtIndex\"]\n          },\n          PASTE: [{\n            guard: \"addOnPaste\",\n            target: \"focused:input\",\n            actions: [\"setInputValue\", \"addTagFromPaste\"]\n          }, {\n            target: \"focused:input\",\n            actions: \"setInputValue\"\n          }]\n        }\n      },\n      \"editing:tag\": {\n        tags: [\"editing\", \"focused\"],\n        entry: \"focusEditedTagInput\",\n        activities: [\"autoResize\"],\n        on: {\n          TAG_INPUT_TYPE: {\n            actions: \"setEditedTagValue\"\n          },\n          TAG_INPUT_ESCAPE: {\n            target: \"navigating:tag\",\n            actions: [\"clearEditedTagValue\", \"focusInput\", \"clearEditedId\", \"highlightTagAtIndex\"]\n          },\n          TAG_INPUT_BLUR: [{\n            guard: \"isInputRelatedTarget\",\n            target: \"navigating:tag\",\n            actions: [\"clearEditedTagValue\", \"clearHighlightedId\", \"clearEditedId\"]\n          }, {\n            target: \"idle\",\n            actions: [\"clearEditedTagValue\", \"clearHighlightedId\", \"clearEditedId\", \"raiseExternalBlurEvent\"]\n          }],\n          TAG_INPUT_ENTER: [{\n            guard: \"isEditedTagEmpty\",\n            target: \"navigating:tag\",\n            actions: [\"deleteHighlightedTag\", \"focusInput\", \"clearEditedId\", \"highlightTagAtIndex\"]\n          }, {\n            target: \"navigating:tag\",\n            actions: [\"submitEditedTagValue\", \"focusInput\", \"clearEditedId\", \"highlightTagAtIndex\"]\n          }]\n        }\n      }\n    }\n  }, {\n    guards: {\n      isInputRelatedTarget: (ctx2, evt) => evt.relatedTarget === dom.getInputEl(ctx2),\n      isAtMax: ctx2 => ctx2.isAtMax,\n      hasHighlightedTag: ctx2 => ctx2.highlightedTagId !== null,\n      isFirstTagHighlighted: ctx2 => {\n        const firstItemId = dom.getItemId(ctx2, {\n          value: ctx2.value[0],\n          index: 0\n        });\n        return firstItemId === ctx2.highlightedTagId;\n      },\n      isEditedTagEmpty: ctx2 => ctx2.editedTagValue.trim() === \"\",\n      isLastTagHighlighted: ctx2 => {\n        const lastIndex = ctx2.value.length - 1;\n        const lastItemId = dom.getItemId(ctx2, {\n          value: ctx2.value[lastIndex],\n          index: lastIndex\n        });\n        return lastItemId === ctx2.highlightedTagId;\n      },\n      isInputValueEmpty: ctx2 => ctx2.trimmedInputValue.length === 0,\n      hasTags: ctx2 => ctx2.value.length > 0,\n      allowOverflow: ctx2 => !!ctx2.allowOverflow,\n      autoFocus: ctx2 => !!ctx2.autoFocus,\n      addOnBlur: ctx2 => ctx2.blurBehavior === \"add\",\n      clearOnBlur: ctx2 => ctx2.blurBehavior === \"clear\",\n      addOnPaste: ctx2 => !!ctx2.addOnPaste,\n      isTagEditable: ctx2 => !!ctx2.editable,\n      isInputCaretAtStart(ctx2) {\n        const input = dom.getInputEl(ctx2);\n        if (!input) return false;\n        try {\n          return input.selectionStart === 0 && input.selectionEnd === 0;\n        } catch {\n          return input.value === \"\";\n        }\n      }\n    },\n    activities: {\n      trackInteractOutside(ctx2, _evt, {\n        send\n      }) {\n        return trackInteractOutside(dom.getInputEl(ctx2), {\n          exclude(target) {\n            return contains(dom.getRootEl(ctx2), target);\n          },\n          onFocusOutside: ctx2.onFocusOutside,\n          onPointerDownOutside: ctx2.onPointerDownOutside,\n          onInteractOutside(event) {\n            ctx2.onInteractOutside?.(event);\n            if (event.defaultPrevented) return;\n            send({\n              type: \"BLUR\",\n              src: \"interact-outside\"\n            });\n          }\n        });\n      },\n      trackFormControlState(ctx2, _evt, {\n        send,\n        initialContext\n      }) {\n        return trackFormControl(dom.getHiddenInputEl(ctx2), {\n          onFieldsetDisabledChange(disabled) {\n            ctx2.fieldsetDisabled = disabled;\n          },\n          onFormReset() {\n            send({\n              type: \"SET_VALUE\",\n              value: initialContext.value,\n              src: \"form-reset\"\n            });\n          }\n        });\n      },\n      autoResize(ctx2) {\n        if (!ctx2.editedTagValue || ctx2.idx == null || !ctx2.editable) return;\n        const input = dom.getTagInputEl(ctx2, {\n          value: ctx2.editedTagValue,\n          index: ctx2.idx\n        });\n        return autoResizeInput(input);\n      },\n      trackLiveRegion(ctx2) {\n        ctx2.liveRegion = createLiveRegion({\n          level: \"assertive\",\n          document: dom.getDoc(ctx2)\n        });\n        return () => ctx2.liveRegion?.destroy();\n      }\n    },\n    actions: {\n      raiseInsertTagEvent(_, __, {\n        self\n      }) {\n        self.send(\"INSERT_TAG\");\n      },\n      raiseExternalBlurEvent(_, evt, {\n        self\n      }) {\n        self.send({\n          type: \"EXTERNAL_BLUR\",\n          id: evt.id\n        });\n      },\n      dispatchChangeEvent(ctx2) {\n        dom.dispatchInputEvent(ctx2);\n      },\n      highlightNextTag(ctx2) {\n        if (ctx2.highlightedTagId == null) return;\n        const next = dom.getNextEl(ctx2, ctx2.highlightedTagId);\n        set.highlightedId(ctx2, next?.id ?? null);\n      },\n      highlightFirstTag(ctx2) {\n        raf(() => {\n          const first = dom.getFirstEl(ctx2);\n          set.highlightedId(ctx2, first?.id ?? null);\n        });\n      },\n      highlightLastTag(ctx2) {\n        const last = dom.getLastEl(ctx2);\n        set.highlightedId(ctx2, last?.id ?? null);\n      },\n      highlightPrevTag(ctx2) {\n        if (ctx2.highlightedTagId == null) return;\n        const prev = dom.getPrevEl(ctx2, ctx2.highlightedTagId);\n        set.highlightedId(ctx2, prev?.id ?? null);\n      },\n      highlightTag(ctx2, evt) {\n        set.highlightedId(ctx2, evt.id);\n      },\n      highlightTagAtIndex(ctx2) {\n        raf(() => {\n          if (ctx2.idx == null) return;\n          const tagEl = dom.getTagElAtIndex(ctx2, ctx2.idx);\n          if (tagEl == null) return;\n          set.highlightedId(ctx2, tagEl.id);\n          ctx2.idx = void 0;\n        });\n      },\n      deleteTag(ctx2, evt) {\n        const index = dom.getIndexOfId(ctx2, evt.id);\n        const value = ctx2.value[index];\n        ctx2.log.prev = ctx2.log.current;\n        ctx2.log.current = {\n          type: \"delete\",\n          value\n        };\n        set.value(ctx2, removeAt(ctx2.value, index));\n      },\n      deleteHighlightedTag(ctx2) {\n        if (ctx2.highlightedTagId == null) return;\n        const index = dom.getIndexOfId(ctx2, ctx2.highlightedTagId);\n        ctx2.idx = index;\n        const value = ctx2.value[index];\n        ctx2.log.prev = ctx2.log.current;\n        ctx2.log.current = {\n          type: \"delete\",\n          value\n        };\n        set.value(ctx2, removeAt(ctx2.value, index));\n      },\n      setEditedId(ctx2, evt) {\n        ctx2.editedTagId = evt.id ?? ctx2.highlightedTagId;\n        ctx2.idx = dom.getIndexOfId(ctx2, ctx2.editedTagId);\n      },\n      clearEditedId(ctx2) {\n        ctx2.editedTagId = null;\n      },\n      clearEditedTagValue(ctx2) {\n        ctx2.editedTagValue = \"\";\n      },\n      setEditedTagValue(ctx2, evt) {\n        ctx2.editedTagValue = evt.value;\n      },\n      submitEditedTagValue(ctx2) {\n        if (!ctx2.editedTagId) return;\n        const index = dom.getIndexOfId(ctx2, ctx2.editedTagId);\n        set.valueAtIndex(ctx2, index, ctx2.editedTagValue ?? \"\");\n        ctx2.log.prev = ctx2.log.current;\n        ctx2.log.current = {\n          type: \"update\",\n          value: ctx2.editedTagValue\n        };\n      },\n      setValueAtIndex(ctx2, evt) {\n        if (evt.value) {\n          ctx2.value[evt.index] = evt.value;\n          ctx2.log.prev = ctx2.log.current;\n          ctx2.log.current = {\n            type: \"update\",\n            value: evt.value\n          };\n        } else {\n          warn(\"You need to provide a value for the tag\");\n        }\n      },\n      initializeEditedTagValue(ctx2) {\n        if (!ctx2.editedTagId) return;\n        const index = dom.getIndexOfId(ctx2, ctx2.editedTagId);\n        ctx2.editedTagValue = ctx2.value[index];\n      },\n      focusEditedTagInput(ctx2) {\n        raf(() => {\n          dom.getEditInputEl(ctx2)?.select();\n        });\n      },\n      setInputValue(ctx2, evt) {\n        set.inputValue(ctx2, evt.value);\n      },\n      clearHighlightedId(ctx2) {\n        ctx2.highlightedTagId = null;\n      },\n      focusInput(ctx2) {\n        raf(() => {\n          dom.getInputEl(ctx2)?.focus();\n        });\n      },\n      clearInputValue(ctx2) {\n        raf(() => {\n          set.inputValue(ctx2, \"\");\n        });\n      },\n      syncInputValue(ctx2) {\n        const inputEl = dom.getInputEl(ctx2);\n        dom.setValue(inputEl, ctx2.inputValue);\n      },\n      syncEditedTagInputValue(ctx2, evt) {\n        const id = ctx2.editedTagId || ctx2.highlightedTagId || evt.id;\n        if (id == null) return;\n        const editTagInputEl = dom.getById(ctx2, `${id}:input`);\n        dom.setValue(editTagInputEl, ctx2.editedTagValue);\n      },\n      addTag(ctx2, evt) {\n        const value = evt.value ?? ctx2.trimmedInputValue;\n        const guard = ctx2.validate?.({\n          inputValue: value,\n          value: Array.from(ctx2.value)\n        });\n        if (guard) {\n          const nextValue = uniq(ctx2.value.concat(value));\n          set.value(ctx2, nextValue);\n          ctx2.log.prev = ctx2.log.current;\n          ctx2.log.current = {\n            type: \"add\",\n            value\n          };\n        } else {\n          ctx2.onValueInvalid?.({\n            reason: \"invalidTag\"\n          });\n        }\n      },\n      addTagFromPaste(ctx2) {\n        raf(() => {\n          const value = ctx2.trimmedInputValue;\n          const guard = ctx2.validate?.({\n            inputValue: value,\n            value: Array.from(ctx2.value)\n          });\n          if (guard) {\n            const trimmedValue = ctx2.delimiter ? value.split(ctx2.delimiter).map(v => v.trim()) : [value];\n            const nextValue = uniq(ctx2.value.concat(...trimmedValue));\n            set.value(ctx2, nextValue);\n            ctx2.log.prev = ctx2.log.current;\n            ctx2.log.current = {\n              type: \"paste\",\n              values: trimmedValue\n            };\n          } else {\n            ctx2.onValueInvalid?.({\n              reason: \"invalidTag\"\n            });\n          }\n          set.inputValue(ctx2, \"\");\n        });\n      },\n      clearTags(ctx2) {\n        set.value(ctx2, []);\n        ctx2.log.prev = ctx2.log.current;\n        ctx2.log.current = {\n          type: \"clear\"\n        };\n      },\n      setValue(ctx2, evt) {\n        set.value(ctx2, evt.value);\n      },\n      invokeOnInvalid(ctx2) {\n        if (ctx2.isOverflowing) {\n          ctx2.onValueInvalid?.({\n            reason: \"rangeOverflow\"\n          });\n        }\n      },\n      clearLog(ctx2) {\n        ctx2.log = {\n          prev: null,\n          current: null\n        };\n      },\n      logHighlightedTag(ctx2) {\n        if (ctx2.highlightedTagId == null) return;\n        const index = dom.getIndexOfId(ctx2, ctx2.highlightedTagId);\n        ctx2.log.prev = ctx2.log.current;\n        ctx2.log.current = {\n          type: \"select\",\n          value: ctx2.value[index]\n        };\n      },\n      // queue logs with screen reader and get it announced\n      announceLog(ctx2) {\n        if (!ctx2.log.current || ctx2.liveRegion == null) return;\n        const region = ctx2.liveRegion;\n        const {\n          current,\n          prev\n        } = ctx2.log;\n        let msg;\n        switch (current.type) {\n          case \"add\":\n            msg = ctx2.translations.tagAdded(current.value);\n            break;\n          case \"delete\":\n            msg = ctx2.translations.tagDeleted(current.value);\n            break;\n          case \"update\":\n            msg = ctx2.translations.tagUpdated(current.value);\n            break;\n          case \"paste\":\n            msg = ctx2.translations.tagsPasted(current.values);\n            break;\n          case \"select\":\n            msg = ctx2.translations.tagSelected(current.value);\n            if (prev?.type === \"delete\") {\n              msg = `${ctx2.translations.tagDeleted(prev.value)}. ${msg}`;\n            } else if (prev?.type === \"update\") {\n              msg = `${ctx2.translations.tagUpdated(prev.value)}. ${msg}`;\n            }\n            break;\n        }\n        if (msg) region.announce(msg);\n      }\n    }\n  });\n}\nvar invoke = {\n  change: ctx => {\n    ctx.onValueChange?.({\n      value: Array.from(ctx.value)\n    });\n    dom.dispatchInputEvent(ctx);\n  },\n  highlightChange: ctx => {\n    const highlightedValue = dom.getHighlightedTagValue(ctx);\n    ctx.onHighlightChange?.({\n      highlightedValue\n    });\n  },\n  valueChange: ctx => {\n    ctx.onInputValueChange?.({\n      inputValue: ctx.inputValue\n    });\n  }\n};\nvar set = {\n  value: (ctx, value) => {\n    if (isEqual(ctx.value, value)) return;\n    ctx.value = value;\n    invoke.change(ctx);\n  },\n  valueAtIndex: (ctx, index, value) => {\n    if (isEqual(ctx.value[index], value)) return;\n    ctx.value[index] = value;\n    invoke.change(ctx);\n  },\n  highlightedId: (ctx, id) => {\n    if (isEqual(ctx.highlightedTagId, id)) return;\n    ctx.highlightedTagId = id;\n    invoke.highlightChange(ctx);\n  },\n  inputValue: (ctx, value) => {\n    if (isEqual(ctx.inputValue, value)) return;\n    ctx.inputValue = value;\n    invoke.valueChange(ctx);\n  }\n};\nvar props = createProps()([\"addOnPaste\", \"allowOverflow\", \"autoFocus\", \"blurBehavior\", \"delimiter\", \"dir\", \"disabled\", \"editable\", \"form\", \"getRootNode\", \"id\", \"ids\", \"inputValue\", \"invalid\", \"max\", \"maxLength\", \"name\", \"onFocusOutside\", \"onHighlightChange\", \"onInputValueChange\", \"onInteractOutside\", \"onPointerDownOutside\", \"onValueChange\", \"onValueInvalid\", \"required\", \"readOnly\", \"translations\", \"validate\", \"value\"]);\nvar splitProps = createSplitProps(props);\nvar itemProps = createProps()([\"index\", \"disabled\", \"value\"]);\nvar splitItemProps = createSplitProps(itemProps);\nexport { anatomy, connect, itemProps, machine, props, splitItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
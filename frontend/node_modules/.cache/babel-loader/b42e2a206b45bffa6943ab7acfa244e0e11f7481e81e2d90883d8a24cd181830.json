{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { getPlacementStyles, getPlacement } from '@zag-js/popper';\nimport { createScope } from '@zag-js/dom-query';\nimport { createMachine, guards } from '@zag-js/core';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { createSplitProps, compact } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/hover-card.anatomy.ts\nvar anatomy = createAnatomy(\"hoverCard\").parts(\"arrow\", \"arrowTip\", \"trigger\", \"positioner\", \"content\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getTriggerId: ctx => ctx.ids?.trigger ?? `hover-card:${ctx.id}:trigger`,\n  getContentId: ctx => ctx.ids?.content ?? `hover-card:${ctx.id}:content`,\n  getPositionerId: ctx => ctx.ids?.positioner ?? `hover-card:${ctx.id}:popper`,\n  getArrowId: ctx => ctx.ids?.arrow ?? `hover-card:${ctx.id}:arrow`,\n  getTriggerEl: ctx => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getContentEl: ctx => dom.getById(ctx, dom.getContentId(ctx)),\n  getPositionerEl: ctx => dom.getById(ctx, dom.getPositionerId(ctx))\n});\n\n// src/hover-card.connect.ts\nfunction connect(state, send, normalize) {\n  const open = state.hasTag(\"open\");\n  const popperStyles = getPlacementStyles({\n    ...state.context.positioning,\n    placement: state.context.currentPlacement\n  });\n  return {\n    open,\n    setOpen(nextOpen) {\n      if (nextOpen === open) return;\n      send(nextOpen ? \"OPEN\" : \"CLOSE\");\n    },\n    reposition(options = {}) {\n      send({\n        type: \"POSITIONING.SET\",\n        options\n      });\n    },\n    getArrowProps() {\n      return normalize.element({\n        id: dom.getArrowId(state.context),\n        ...parts.arrow.attrs,\n        dir: state.context.dir,\n        style: popperStyles.arrow\n      });\n    },\n    getArrowTipProps() {\n      return normalize.element({\n        ...parts.arrowTip.attrs,\n        dir: state.context.dir,\n        style: popperStyles.arrowTip\n      });\n    },\n    getTriggerProps() {\n      return normalize.element({\n        ...parts.trigger.attrs,\n        dir: state.context.dir,\n        \"data-placement\": state.context.currentPlacement,\n        id: dom.getTriggerId(state.context),\n        \"data-state\": open ? \"open\" : \"closed\",\n        onPointerEnter(event) {\n          if (event.pointerType === \"touch\") return;\n          send({\n            type: \"POINTER_ENTER\",\n            src: \"trigger\"\n          });\n        },\n        onPointerLeave(event) {\n          if (event.pointerType === \"touch\") return;\n          send({\n            type: \"POINTER_LEAVE\",\n            src: \"trigger\"\n          });\n        },\n        onFocus() {\n          send(\"TRIGGER_FOCUS\");\n        },\n        onBlur() {\n          send(\"TRIGGER_BLUR\");\n        }\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        id: dom.getPositionerId(state.context),\n        ...parts.positioner.attrs,\n        dir: state.context.dir,\n        style: popperStyles.floating\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: state.context.dir,\n        id: dom.getContentId(state.context),\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-placement\": state.context.currentPlacement,\n        onPointerEnter(event) {\n          if (event.pointerType === \"touch\") return;\n          send({\n            type: \"POINTER_ENTER\",\n            src: \"content\"\n          });\n        },\n        onPointerLeave(event) {\n          if (event.pointerType === \"touch\") return;\n          send({\n            type: \"POINTER_LEAVE\",\n            src: \"content\"\n          });\n        }\n      });\n    }\n  };\n}\nvar {\n  not,\n  and\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"hover-card\",\n    initial: ctx.open ? \"open\" : \"closed\",\n    context: {\n      openDelay: 700,\n      closeDelay: 300,\n      currentPlacement: void 0,\n      ...ctx,\n      positioning: {\n        placement: \"bottom\",\n        ...ctx.positioning\n      }\n    },\n    watch: {\n      open: [\"toggleVisibility\"]\n    },\n    states: {\n      closed: {\n        tags: [\"closed\"],\n        entry: [\"clearIsPointer\"],\n        on: {\n          \"CONTROLLED.OPEN\": \"open\",\n          POINTER_ENTER: {\n            target: \"opening\",\n            actions: [\"setIsPointer\"]\n          },\n          TRIGGER_FOCUS: \"opening\",\n          OPEN: \"opening\"\n        }\n      },\n      opening: {\n        tags: [\"closed\"],\n        after: {\n          OPEN_DELAY: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\"]\n          }]\n        },\n        on: {\n          \"CONTROLLED.OPEN\": \"open\",\n          \"CONTROLLED.CLOSE\": \"closed\",\n          POINTER_LEAVE: [{\n            guard: \"isOpenControlled\",\n            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n            actions: [\"invokeOnClose\", \"toggleVisibility\"]\n          }, {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }],\n          TRIGGER_BLUR: [{\n            guard: and(\"isOpenControlled\", not(\"isPointer\")),\n            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n            actions: [\"invokeOnClose\", \"toggleVisibility\"]\n          }, {\n            guard: not(\"isPointer\"),\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }],\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n            actions: [\"invokeOnClose\", \"toggleVisibility\"]\n          }, {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }]\n        }\n      },\n      open: {\n        tags: [\"open\"],\n        activities: [\"trackDismissableElement\", \"trackPositioning\"],\n        on: {\n          \"CONTROLLED.CLOSE\": \"closed\",\n          POINTER_ENTER: {\n            actions: [\"setIsPointer\"]\n          },\n          POINTER_LEAVE: \"closing\",\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }],\n          TRIGGER_BLUR: [{\n            guard: and(\"isOpenControlled\", not(\"isPointer\")),\n            actions: [\"invokeOnClose\"]\n          }, {\n            guard: not(\"isPointer\"),\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }],\n          \"POSITIONING.SET\": {\n            actions: \"reposition\"\n          }\n        }\n      },\n      closing: {\n        tags: [\"open\"],\n        activities: [\"trackPositioning\"],\n        after: {\n          CLOSE_DELAY: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }]\n        },\n        on: {\n          \"CONTROLLED.CLOSE\": \"closed\",\n          \"CONTROLLED.OPEN\": \"open\",\n          POINTER_ENTER: {\n            target: \"open\",\n            // no need to invokeOnOpen here because it's still open (but about to close)\n            actions: [\"setIsPointer\"]\n          }\n        }\n      }\n    }\n  }, {\n    delays: {\n      OPEN_DELAY: ctx2 => ctx2.openDelay,\n      CLOSE_DELAY: ctx2 => ctx2.closeDelay\n    },\n    guards: {\n      isPointer: ctx2 => !!ctx2.isPointer,\n      isOpenControlled: ctx2 => !!ctx2[\"open.controlled\"]\n    },\n    activities: {\n      trackPositioning(ctx2) {\n        ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);\n        const getPositionerEl = () => dom.getPositionerEl(ctx2);\n        return getPlacement(dom.getTriggerEl(ctx2), getPositionerEl, {\n          ...ctx2.positioning,\n          defer: true,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      trackDismissableElement(ctx2, _evt, {\n        send\n      }) {\n        const getContentEl = () => dom.getContentEl(ctx2);\n        return trackDismissableElement(getContentEl, {\n          defer: true,\n          exclude: [dom.getTriggerEl(ctx2)],\n          onDismiss() {\n            send({\n              type: \"CLOSE\",\n              src: \"interact-outside\"\n            });\n          },\n          onFocusOutside(event) {\n            event.preventDefault();\n          }\n        });\n      }\n    },\n    actions: {\n      invokeOnClose(ctx2) {\n        ctx2.onOpenChange?.({\n          open: false\n        });\n      },\n      invokeOnOpen(ctx2) {\n        ctx2.onOpenChange?.({\n          open: true\n        });\n      },\n      setIsPointer(ctx2) {\n        ctx2.isPointer = true;\n      },\n      clearIsPointer(ctx2) {\n        ctx2.isPointer = false;\n      },\n      reposition(ctx2, evt) {\n        const getPositionerEl = () => dom.getPositionerEl(ctx2);\n        getPlacement(dom.getTriggerEl(ctx2), getPositionerEl, {\n          ...ctx2.positioning,\n          ...evt.options,\n          defer: true,\n          listeners: false,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      toggleVisibility(ctx2, evt, {\n        send\n      }) {\n        queueMicrotask(() => {\n          send({\n            type: ctx2.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n            previousEvent: evt\n          });\n        });\n      }\n    }\n  });\n}\nvar props = createProps()([\"closeDelay\", \"dir\", \"getRootNode\", \"id\", \"ids\", \"onOpenChange\", \"open.controlled\", \"open\", \"openDelay\", \"positioning\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { toArray } from './array';\nimport { isAutoFocusAllowedCached, isVisibleCached, notHiddenInput } from './is';\nimport { orderByTabIndex } from './tabOrder';\nimport { getFocusables, getParentAutofocusables } from './tabUtils';\n/**\r\n * given list of focusable elements keeps the ones user can interact with\r\n * @param nodes\r\n * @param visibilityCache\r\n */\nexport var filterFocusable = function (nodes, visibilityCache) {\n  return toArray(nodes).filter(function (node) {\n    return isVisibleCached(visibilityCache, node);\n  }).filter(function (node) {\n    return notHiddenInput(node);\n  });\n};\nexport var filterAutoFocusable = function (nodes, cache) {\n  if (cache === void 0) {\n    cache = new Map();\n  }\n  return toArray(nodes).filter(function (node) {\n    return isAutoFocusAllowedCached(cache, node);\n  });\n};\n/**\r\n * !__WARNING__! Low level API.\r\n * @returns all tabbable nodes\r\n *\r\n * @see {@link getFocusableNodes} to get any focusable element\r\n *\r\n * @param topNodes - array of top level HTMLElements to search inside\r\n * @param visibilityCache - an cache to store intermediate measurements. Expected to be a fresh `new Map` on every call\r\n */\nexport var getTabbableNodes = function (topNodes, visibilityCache, withGuards) {\n  return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);\n};\n/**\r\n * !__WARNING__! Low level API.\r\n *\r\n * @returns anything \"focusable\", not only tabbable. The difference is in `tabIndex=-1`\r\n * (without guards, as long as they are not expected to be ever focused)\r\n *\r\n * @see {@link getTabbableNodes} to get only tabble nodes element\r\n *\r\n * @param topNodes - array of top level HTMLElements to search inside\r\n * @param visibilityCache - an cache to store intermediate measurements. Expected to be a fresh `new Map` on every call\r\n */\nexport var getFocusableNodes = function (topNodes, visibilityCache) {\n  return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);\n};\n/**\r\n * return list of nodes which are expected to be auto-focused\r\n * @param topNode\r\n * @param visibilityCache\r\n */\nexport var parentAutofocusables = function (topNode, visibilityCache) {\n  return filterFocusable(getParentAutofocusables(topNode), visibilityCache);\n};\n/*\r\n * Determines if element is contained in scope, including nested shadow DOMs\r\n */\nexport var contains = function (scope, element) {\n  if (scope.shadowRoot) {\n    return contains(scope.shadowRoot, element);\n  } else {\n    if (Object.getPrototypeOf(scope).contains !== undefined && Object.getPrototypeOf(scope).contains.call(scope, element)) {\n      return true;\n    }\n    return toArray(scope.children).some(function (child) {\n      var _a;\n      if (child instanceof HTMLIFrameElement) {\n        var iframeBody = (_a = child.contentDocument) === null || _a === void 0 ? void 0 : _a.body;\n        if (iframeBody) {\n          return contains(iframeBody, element);\n        }\n        return false;\n      }\n      return contains(child, element);\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
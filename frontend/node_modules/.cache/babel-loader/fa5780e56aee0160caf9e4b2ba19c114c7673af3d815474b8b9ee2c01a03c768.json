{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, getFocusables, isSafari, dataAttr, proxyTabFocus, getInitialFocus, raf } from '@zag-js/dom-query';\nimport { getPlacementStyles, getPlacement } from '@zag-js/popper';\nimport { ariaHidden } from '@zag-js/aria-hidden';\nimport { createMachine } from '@zag-js/core';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { trapFocus } from '@zag-js/focus-trap';\nimport { preventBodyScroll } from '@zag-js/remove-scroll';\nimport { createSplitProps, compact } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/popover.anatomy.ts\nvar anatomy = createAnatomy(\"popover\").parts(\"arrow\", \"arrowTip\", \"anchor\", \"trigger\", \"indicator\", \"positioner\", \"content\", \"title\", \"description\", \"closeTrigger\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getAnchorId: ctx => ctx.ids?.anchor ?? `popover:${ctx.id}:anchor`,\n  getTriggerId: ctx => ctx.ids?.trigger ?? `popover:${ctx.id}:trigger`,\n  getContentId: ctx => ctx.ids?.content ?? `popover:${ctx.id}:content`,\n  getPositionerId: ctx => ctx.ids?.positioner ?? `popover:${ctx.id}:popper`,\n  getArrowId: ctx => ctx.ids?.arrow ?? `popover:${ctx.id}:arrow`,\n  getTitleId: ctx => ctx.ids?.title ?? `popover:${ctx.id}:title`,\n  getDescriptionId: ctx => ctx.ids?.description ?? `popover:${ctx.id}:desc`,\n  getCloseTriggerId: ctx => ctx.ids?.closeTrigger ?? `popover:${ctx.id}:close`,\n  getAnchorEl: ctx => dom.getById(ctx, dom.getAnchorId(ctx)),\n  getTriggerEl: ctx => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getContentEl: ctx => dom.getById(ctx, dom.getContentId(ctx)),\n  getPositionerEl: ctx => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getTitleEl: ctx => dom.getById(ctx, dom.getTitleId(ctx)),\n  getDescriptionEl: ctx => dom.getById(ctx, dom.getDescriptionId(ctx)),\n  getFocusableEls: ctx => getFocusables(dom.getContentEl(ctx)),\n  getFirstFocusableEl: ctx => dom.getFocusableEls(ctx)[0]\n});\n\n// src/popover.connect.ts\nfunction connect(state, send, normalize) {\n  const open = state.matches(\"open\");\n  const currentPlacement = state.context.currentPlacement;\n  const portalled = state.context.currentPortalled;\n  const rendered = state.context.renderedElements;\n  const popperStyles = getPlacementStyles({\n    ...state.context.positioning,\n    placement: currentPlacement\n  });\n  return {\n    portalled,\n    open,\n    setOpen(nextOpen) {\n      if (nextOpen === open) return;\n      send(nextOpen ? \"OPEN\" : \"CLOSE\");\n    },\n    reposition(options = {}) {\n      send({\n        type: \"POSITIONING.SET\",\n        options\n      });\n    },\n    getArrowProps() {\n      return normalize.element({\n        id: dom.getArrowId(state.context),\n        ...parts.arrow.attrs,\n        dir: state.context.dir,\n        style: popperStyles.arrow\n      });\n    },\n    getArrowTipProps() {\n      return normalize.element({\n        ...parts.arrowTip.attrs,\n        dir: state.context.dir,\n        style: popperStyles.arrowTip\n      });\n    },\n    getAnchorProps() {\n      return normalize.element({\n        ...parts.anchor.attrs,\n        dir: state.context.dir,\n        id: dom.getAnchorId(state.context)\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        dir: state.context.dir,\n        type: \"button\",\n        \"data-placement\": currentPlacement,\n        id: dom.getTriggerId(state.context),\n        \"aria-haspopup\": \"dialog\",\n        \"aria-expanded\": open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-controls\": dom.getContentId(state.context),\n        onPointerDown(event) {\n          if (isSafari()) {\n            event.currentTarget.focus();\n          }\n        },\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send(\"TOGGLE\");\n        },\n        onBlur(event) {\n          send({\n            type: \"TRIGGER_BLUR\",\n            target: event.relatedTarget\n          });\n        }\n      });\n    },\n    getIndicatorProps() {\n      return normalize.element({\n        ...parts.indicator.attrs,\n        dir: state.context.dir,\n        \"data-state\": open ? \"open\" : \"closed\"\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        id: dom.getPositionerId(state.context),\n        ...parts.positioner.attrs,\n        dir: state.context.dir,\n        style: popperStyles.floating\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: state.context.dir,\n        id: dom.getContentId(state.context),\n        tabIndex: -1,\n        role: \"dialog\",\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-expanded\": dataAttr(open),\n        \"aria-labelledby\": rendered.title ? dom.getTitleId(state.context) : void 0,\n        \"aria-describedby\": rendered.description ? dom.getDescriptionId(state.context) : void 0,\n        \"data-placement\": currentPlacement\n      });\n    },\n    getTitleProps() {\n      return normalize.element({\n        ...parts.title.attrs,\n        id: dom.getTitleId(state.context),\n        dir: state.context.dir\n      });\n    },\n    getDescriptionProps() {\n      return normalize.element({\n        ...parts.description.attrs,\n        id: dom.getDescriptionId(state.context),\n        dir: state.context.dir\n      });\n    },\n    getCloseTriggerProps() {\n      return normalize.button({\n        ...parts.closeTrigger.attrs,\n        dir: state.context.dir,\n        id: dom.getCloseTriggerId(state.context),\n        type: \"button\",\n        \"aria-label\": \"close\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send(\"CLOSE\");\n        }\n      });\n    }\n  };\n}\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"popover\",\n    initial: ctx.open ? \"open\" : \"closed\",\n    context: {\n      closeOnInteractOutside: true,\n      closeOnEscape: true,\n      autoFocus: true,\n      modal: false,\n      portalled: true,\n      positioning: {\n        placement: \"bottom\",\n        ...ctx.positioning\n      },\n      currentPlacement: void 0,\n      ...ctx,\n      renderedElements: {\n        title: true,\n        description: true\n      }\n    },\n    computed: {\n      currentPortalled: ctx2 => !!ctx2.modal || !!ctx2.portalled\n    },\n    watch: {\n      open: [\"toggleVisibility\"]\n    },\n    entry: [\"checkRenderedElements\"],\n    states: {\n      closed: {\n        on: {\n          \"CONTROLLED.OPEN\": {\n            target: \"open\",\n            actions: [\"setInitialFocus\"]\n          },\n          TOGGLE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\", \"setInitialFocus\"]\n          }],\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\", \"setInitialFocus\"]\n          }]\n        }\n      },\n      open: {\n        activities: [\"trapFocus\", \"preventScroll\", \"hideContentBelow\", \"trackPositioning\", \"trackDismissableElement\", \"proxyTabFocus\"],\n        on: {\n          \"CONTROLLED.CLOSE\": {\n            target: \"closed\",\n            actions: [\"setFinalFocus\"]\n          },\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"closed\",\n            actions: [\"invokeOnClose\", \"setFinalFocus\"]\n          }],\n          TOGGLE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }],\n          \"POSITIONING.SET\": {\n            actions: \"reposition\"\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      isOpenControlled: ctx2 => !!ctx2[\"open.controlled\"]\n    },\n    activities: {\n      trackPositioning(ctx2) {\n        ctx2.currentPlacement = ctx2.positioning.placement;\n        const anchorEl = dom.getAnchorEl(ctx2) ?? dom.getTriggerEl(ctx2);\n        const getPositionerEl = () => dom.getPositionerEl(ctx2);\n        return getPlacement(anchorEl, getPositionerEl, {\n          ...ctx2.positioning,\n          defer: true,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      trackDismissableElement(ctx2, _evt, {\n        send\n      }) {\n        const getContentEl = () => dom.getContentEl(ctx2);\n        let restoreFocus = true;\n        return trackDismissableElement(getContentEl, {\n          pointerBlocking: ctx2.modal,\n          exclude: dom.getTriggerEl(ctx2),\n          defer: true,\n          onEscapeKeyDown(event) {\n            ctx2.onEscapeKeyDown?.(event);\n            if (ctx2.closeOnEscape) return;\n            event.preventDefault();\n          },\n          onInteractOutside(event) {\n            ctx2.onInteractOutside?.(event);\n            if (event.defaultPrevented) return;\n            restoreFocus = !(event.detail.focusable || event.detail.contextmenu);\n            if (!ctx2.closeOnInteractOutside) {\n              event.preventDefault();\n            }\n          },\n          onPointerDownOutside: ctx2.onPointerDownOutside,\n          onFocusOutside: ctx2.onFocusOutside,\n          persistentElements: ctx2.persistentElements,\n          onDismiss() {\n            send({\n              type: \"CLOSE\",\n              src: \"interact-outside\",\n              restoreFocus\n            });\n          }\n        });\n      },\n      proxyTabFocus(ctx2) {\n        if (ctx2.modal || !ctx2.portalled) return;\n        const getContentEl = () => dom.getContentEl(ctx2);\n        return proxyTabFocus(getContentEl, {\n          triggerElement: dom.getTriggerEl(ctx2),\n          defer: true,\n          onFocus(el) {\n            el.focus({\n              preventScroll: true\n            });\n          }\n        });\n      },\n      hideContentBelow(ctx2) {\n        if (!ctx2.modal) return;\n        const getElements = () => [dom.getContentEl(ctx2), dom.getTriggerEl(ctx2)];\n        return ariaHidden(getElements, {\n          defer: true\n        });\n      },\n      preventScroll(ctx2) {\n        if (!ctx2.modal) return;\n        return preventBodyScroll(dom.getDoc(ctx2));\n      },\n      trapFocus(ctx2) {\n        if (!ctx2.modal) return;\n        const contentEl = () => dom.getContentEl(ctx2);\n        return trapFocus(contentEl, {\n          initialFocus: () => getInitialFocus({\n            root: dom.getContentEl(ctx2),\n            getInitialEl: ctx2.initialFocusEl,\n            enabled: ctx2.autoFocus\n          })\n        });\n      }\n    },\n    actions: {\n      reposition(ctx2, evt) {\n        const anchorEl = dom.getAnchorEl(ctx2) ?? dom.getTriggerEl(ctx2);\n        const getPositionerEl = () => dom.getPositionerEl(ctx2);\n        getPlacement(anchorEl, getPositionerEl, {\n          ...ctx2.positioning,\n          ...evt.options,\n          defer: true,\n          listeners: false,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      checkRenderedElements(ctx2) {\n        raf(() => {\n          Object.assign(ctx2.renderedElements, {\n            title: !!dom.getTitleEl(ctx2),\n            description: !!dom.getDescriptionEl(ctx2)\n          });\n        });\n      },\n      setInitialFocus(ctx2) {\n        if (ctx2.modal) return;\n        raf(() => {\n          const element = getInitialFocus({\n            root: dom.getContentEl(ctx2),\n            getInitialEl: ctx2.initialFocusEl,\n            enabled: ctx2.autoFocus\n          });\n          element?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      setFinalFocus(ctx2, evt) {\n        const restoreFocus = evt.restoreFocus ?? evt.previousEvent?.restoreFocus;\n        if (restoreFocus != null && !restoreFocus) return;\n        raf(() => {\n          const element = dom.getTriggerEl(ctx2);\n          element?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      invokeOnOpen(ctx2) {\n        ctx2.onOpenChange?.({\n          open: true\n        });\n      },\n      invokeOnClose(ctx2) {\n        ctx2.onOpenChange?.({\n          open: false\n        });\n      },\n      toggleVisibility(ctx2, evt, {\n        send\n      }) {\n        send({\n          type: ctx2.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: evt\n        });\n      }\n    }\n  });\n}\nvar props = createProps()([\"autoFocus\", \"closeOnEscape\", \"closeOnInteractOutside\", \"dir\", \"getRootNode\", \"id\", \"ids\", \"initialFocusEl\", \"modal\", \"onEscapeKeyDown\", \"onFocusOutside\", \"onInteractOutside\", \"onOpenChange\", \"onPointerDownOutside\", \"open.controlled\", \"open\", \"persistentElements\", \"portalled\", \"positioning\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
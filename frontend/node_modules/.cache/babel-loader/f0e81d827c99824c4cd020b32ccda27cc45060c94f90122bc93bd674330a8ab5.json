{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createScope, queryAll, nextById, prevById, dataAttr, isSafari, getEventKey } from '@zag-js/dom-query';\nimport { first, last, createSplitProps, compact, remove, add, warn, isEqual } from '@zag-js/utils';\nimport { createMachine, guards } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/accordion.anatomy.ts\nvar anatomy = createAnatomy(\"accordion\").parts(\"root\", \"item\", \"itemTrigger\", \"itemContent\", \"itemIndicator\");\nvar parts = anatomy.build();\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `accordion:${ctx.id}`,\n  getItemId: (ctx, value) => ctx.ids?.item?.(value) ?? `accordion:${ctx.id}:item:${value}`,\n  getItemContentId: (ctx, value) => ctx.ids?.itemContent?.(value) ?? `accordion:${ctx.id}:content:${value}`,\n  getItemTriggerId: (ctx, value) => ctx.ids?.itemTrigger?.(value) ?? `accordion:${ctx.id}:trigger:${value}`,\n  getRootEl: ctx => dom.getById(ctx, dom.getRootId(ctx)),\n  getTriggerEls: ctx => {\n    const ownerId = CSS.escape(dom.getRootId(ctx));\n    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;\n    return queryAll(dom.getRootEl(ctx), selector);\n  },\n  getFirstTriggerEl: ctx => first(dom.getTriggerEls(ctx)),\n  getLastTriggerEl: ctx => last(dom.getTriggerEls(ctx)),\n  getNextTriggerEl: (ctx, id) => nextById(dom.getTriggerEls(ctx), dom.getItemTriggerId(ctx, id)),\n  getPrevTriggerEl: (ctx, id) => prevById(dom.getTriggerEls(ctx), dom.getItemTriggerId(ctx, id))\n});\n\n// src/accordion.connect.ts\nfunction connect(state, send, normalize) {\n  const focusedValue = state.context.focusedValue;\n  const value = state.context.value;\n  const multiple = state.context.multiple;\n  function setValue(value2) {\n    let nextValue = value2;\n    if (!multiple && nextValue.length > 1) {\n      nextValue = [nextValue[0]];\n    }\n    send({\n      type: \"VALUE.SET\",\n      value: nextValue\n    });\n  }\n  function getItemState(props2) {\n    return {\n      expanded: value.includes(props2.value),\n      focused: focusedValue === props2.value,\n      disabled: Boolean(props2.disabled ?? state.context.disabled)\n    };\n  }\n  return {\n    focusedValue,\n    value,\n    setValue,\n    getItemState,\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        id: dom.getRootId(state.context),\n        \"data-orientation\": state.context.orientation\n      });\n    },\n    getItemProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        ...parts.item.attrs,\n        dir: state.context.dir,\n        id: dom.getItemId(state.context, props2.value),\n        \"data-state\": itemState.expanded ? \"open\" : \"closed\",\n        \"data-focus\": dataAttr(itemState.focused),\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-orientation\": state.context.orientation\n      });\n    },\n    getItemContentProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        ...parts.itemContent.attrs,\n        dir: state.context.dir,\n        role: \"region\",\n        id: dom.getItemContentId(state.context, props2.value),\n        \"aria-labelledby\": dom.getItemTriggerId(state.context, props2.value),\n        hidden: !itemState.expanded,\n        \"data-state\": itemState.expanded ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-focus\": dataAttr(itemState.focused),\n        \"data-orientation\": state.context.orientation\n      });\n    },\n    getItemIndicatorProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        ...parts.itemIndicator.attrs,\n        dir: state.context.dir,\n        \"aria-hidden\": true,\n        \"data-state\": itemState.expanded ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-focus\": dataAttr(itemState.focused),\n        \"data-orientation\": state.context.orientation\n      });\n    },\n    getItemTriggerProps(props2) {\n      const {\n        value: value2\n      } = props2;\n      const itemState = getItemState(props2);\n      return normalize.button({\n        ...parts.itemTrigger.attrs,\n        type: \"button\",\n        dir: state.context.dir,\n        id: dom.getItemTriggerId(state.context, value2),\n        \"aria-controls\": dom.getItemContentId(state.context, value2),\n        \"aria-expanded\": itemState.expanded,\n        disabled: itemState.disabled,\n        \"data-orientation\": state.context.orientation,\n        \"aria-disabled\": itemState.disabled,\n        \"data-state\": itemState.expanded ? \"open\" : \"closed\",\n        \"data-ownedby\": dom.getRootId(state.context),\n        onFocus() {\n          if (itemState.disabled) return;\n          send({\n            type: \"TRIGGER.FOCUS\",\n            value: value2\n          });\n        },\n        onBlur() {\n          if (itemState.disabled) return;\n          send(\"TRIGGER.BLUR\");\n        },\n        onClick(event) {\n          if (itemState.disabled) return;\n          if (isSafari()) {\n            event.currentTarget.focus();\n          }\n          send({\n            type: \"TRIGGER.CLICK\",\n            value: value2\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (itemState.disabled) return;\n          const keyMap = {\n            ArrowDown() {\n              if (state.context.isHorizontal) return;\n              send({\n                type: \"GOTO.NEXT\",\n                value: value2\n              });\n            },\n            ArrowUp() {\n              if (state.context.isHorizontal) return;\n              send({\n                type: \"GOTO.PREV\",\n                value: value2\n              });\n            },\n            ArrowRight() {\n              if (!state.context.isHorizontal) return;\n              send({\n                type: \"GOTO.NEXT\",\n                value: value2\n              });\n            },\n            ArrowLeft() {\n              if (!state.context.isHorizontal) return;\n              send({\n                type: \"GOTO.PREV\",\n                value: value2\n              });\n            },\n            Home() {\n              send({\n                type: \"GOTO.FIRST\",\n                value: value2\n              });\n            },\n            End() {\n              send({\n                type: \"GOTO.LAST\",\n                value: value2\n              });\n            }\n          };\n          const key = getEventKey(event, {\n            dir: state.context.dir,\n            orientation: state.context.orientation\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    }\n  };\n}\nvar {\n  and,\n  not\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"accordion\",\n    initial: \"idle\",\n    context: {\n      focusedValue: null,\n      value: [],\n      collapsible: false,\n      multiple: false,\n      orientation: \"vertical\",\n      ...ctx\n    },\n    watch: {\n      value: \"coarseValue\",\n      multiple: \"coarseValue\"\n    },\n    created: \"coarseValue\",\n    computed: {\n      isHorizontal: ctx2 => ctx2.orientation === \"horizontal\"\n    },\n    on: {\n      \"VALUE.SET\": {\n        actions: [\"setValue\"]\n      }\n    },\n    states: {\n      idle: {\n        on: {\n          \"TRIGGER.FOCUS\": {\n            target: \"focused\",\n            actions: \"setFocusedValue\"\n          }\n        }\n      },\n      focused: {\n        on: {\n          \"GOTO.NEXT\": {\n            actions: \"focusNextTrigger\"\n          },\n          \"GOTO.PREV\": {\n            actions: \"focusPrevTrigger\"\n          },\n          \"TRIGGER.CLICK\": [{\n            guard: and(\"isExpanded\", \"canToggle\"),\n            actions: [\"collapse\"]\n          }, {\n            guard: not(\"isExpanded\"),\n            actions: [\"expand\"]\n          }],\n          \"GOTO.FIRST\": {\n            actions: \"focusFirstTrigger\"\n          },\n          \"GOTO.LAST\": {\n            actions: \"focusLastTrigger\"\n          },\n          \"TRIGGER.BLUR\": {\n            target: \"idle\",\n            actions: \"clearFocusedValue\"\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      canToggle: ctx2 => !!ctx2.collapsible || !!ctx2.multiple,\n      isExpanded: (ctx2, evt) => ctx2.value.includes(evt.value)\n    },\n    actions: {\n      collapse(ctx2, evt) {\n        const next = ctx2.multiple ? remove(ctx2.value, evt.value) : [];\n        set.value(ctx2, ctx2.multiple ? next : []);\n      },\n      expand(ctx2, evt) {\n        const next = ctx2.multiple ? add(ctx2.value, evt.value) : [evt.value];\n        set.value(ctx2, next);\n      },\n      focusFirstTrigger(ctx2) {\n        dom.getFirstTriggerEl(ctx2)?.focus();\n      },\n      focusLastTrigger(ctx2) {\n        dom.getLastTriggerEl(ctx2)?.focus();\n      },\n      focusNextTrigger(ctx2) {\n        if (!ctx2.focusedValue) return;\n        const triggerEl = dom.getNextTriggerEl(ctx2, ctx2.focusedValue);\n        triggerEl?.focus();\n      },\n      focusPrevTrigger(ctx2) {\n        if (!ctx2.focusedValue) return;\n        const triggerEl = dom.getPrevTriggerEl(ctx2, ctx2.focusedValue);\n        triggerEl?.focus();\n      },\n      setFocusedValue(ctx2, evt) {\n        set.focusedValue(ctx2, evt.value);\n      },\n      clearFocusedValue(ctx2) {\n        set.focusedValue(ctx2, null);\n      },\n      setValue(ctx2, evt) {\n        set.value(ctx2, evt.value);\n      },\n      coarseValue(ctx2) {\n        if (!ctx2.multiple && ctx2.value.length > 1) {\n          warn(`The value of accordion should be a single value when multiple is false.`);\n          ctx2.value = [ctx2.value[0]];\n        }\n      }\n    }\n  });\n}\nvar invoke = {\n  change(ctx) {\n    ctx.onValueChange?.({\n      value: Array.from(ctx.value)\n    });\n  },\n  focusChange(ctx) {\n    ctx.onFocusChange?.({\n      value: ctx.focusedValue\n    });\n  }\n};\nvar set = {\n  value(ctx, value) {\n    if (isEqual(ctx.value, value)) return;\n    ctx.value = value;\n    invoke.change(ctx);\n  },\n  focusedValue(ctx, value) {\n    if (isEqual(ctx.focusedValue, value)) return;\n    ctx.focusedValue = value;\n    invoke.focusChange(ctx);\n  }\n};\nvar props = createProps()([\"collapsible\", \"dir\", \"disabled\", \"getRootNode\", \"id\", \"ids\", \"multiple\", \"onFocusChange\", \"onValueChange\", \"orientation\", \"value\"]);\nvar splitProps = createSplitProps(props);\nvar itemProps = createProps()([\"value\", \"disabled\"]);\nvar splitItemProps = createSplitProps(itemProps);\nexport { anatomy, connect, itemProps, machine, props, splitItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
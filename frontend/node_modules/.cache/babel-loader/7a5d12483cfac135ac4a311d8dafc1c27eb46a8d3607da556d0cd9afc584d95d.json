{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { ListCollection } from '@zag-js/collection';\nimport { ref, createMachine, guards } from '@zag-js/core';\nimport { createScope, query, dataAttr, ariaAttr, isComposingEvent, getEventKey, isLeftClick, isDownloadingEvent, isOpeningInNewTab, isContextMenuEvent, clickIfLink, observeChildren, raf, observeAttributes, scrollIntoView, isAnchorElement } from '@zag-js/dom-query';\nimport { getPlacementStyles, getPlacement } from '@zag-js/popper';\nimport { ariaHidden } from '@zag-js/aria-hidden';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { compact, isBoolean, match, isArray, isEqual, addOrRemove } from '@zag-js/utils';\n\n// src/combobox.anatomy.ts\nvar anatomy = createAnatomy(\"combobox\").parts(\"root\", \"clearTrigger\", \"content\", \"control\", \"input\", \"item\", \"itemGroup\", \"itemGroupLabel\", \"itemIndicator\", \"itemText\", \"label\", \"list\", \"positioner\", \"trigger\");\nvar parts = anatomy.build();\nvar collection = options => {\n  return ref(new ListCollection(options));\n};\ncollection.empty = () => {\n  return ref(new ListCollection({\n    items: []\n  }));\n};\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `combobox:${ctx.id}`,\n  getLabelId: ctx => ctx.ids?.label ?? `combobox:${ctx.id}:label`,\n  getControlId: ctx => ctx.ids?.control ?? `combobox:${ctx.id}:control`,\n  getInputId: ctx => ctx.ids?.input ?? `combobox:${ctx.id}:input`,\n  getContentId: ctx => ctx.ids?.content ?? `combobox:${ctx.id}:content`,\n  getPositionerId: ctx => ctx.ids?.positioner ?? `combobox:${ctx.id}:popper`,\n  getTriggerId: ctx => ctx.ids?.trigger ?? `combobox:${ctx.id}:toggle-btn`,\n  getClearTriggerId: ctx => ctx.ids?.clearTrigger ?? `combobox:${ctx.id}:clear-btn`,\n  getItemGroupId: (ctx, id) => ctx.ids?.itemGroup?.(id) ?? `combobox:${ctx.id}:optgroup:${id}`,\n  getItemGroupLabelId: (ctx, id) => ctx.ids?.itemGroupLabel?.(id) ?? `combobox:${ctx.id}:optgroup-label:${id}`,\n  getItemId: (ctx, id) => ctx.ids?.item?.(id) ?? `combobox:${ctx.id}:option:${id}`,\n  getContentEl: ctx => dom.getById(ctx, dom.getContentId(ctx)),\n  getInputEl: ctx => dom.getById(ctx, dom.getInputId(ctx)),\n  getPositionerEl: ctx => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getControlEl: ctx => dom.getById(ctx, dom.getControlId(ctx)),\n  getTriggerEl: ctx => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getClearTriggerEl: ctx => dom.getById(ctx, dom.getClearTriggerId(ctx)),\n  getHighlightedItemEl: ctx => {\n    const value = ctx.highlightedValue;\n    if (value == null) return;\n    const selector = `[role=option][data-value=\"${CSS.escape(value)}\"`;\n    return query(dom.getContentEl(ctx), selector);\n  },\n  focusInputEl: ctx => {\n    const inputEl = dom.getInputEl(ctx);\n    if (dom.isActiveElement(ctx, inputEl)) return;\n    inputEl?.focus({\n      preventScroll: true\n    });\n  },\n  focusTriggerEl: ctx => {\n    const triggerEl = dom.getTriggerEl(ctx);\n    if (dom.isActiveElement(ctx, triggerEl)) return;\n    triggerEl?.focus({\n      preventScroll: true\n    });\n  }\n});\n\n// src/combobox.connect.ts\nfunction connect(state, send, normalize) {\n  const translations = state.context.translations;\n  const collection2 = state.context.collection;\n  const disabled = state.context.disabled;\n  const interactive = state.context.isInteractive;\n  const invalid = state.context.invalid;\n  const readOnly = state.context.readOnly;\n  const open = state.hasTag(\"open\");\n  const focused = state.hasTag(\"focused\");\n  const composite = state.context.composite;\n  const highlightedValue = state.context.highlightedValue;\n  const popperStyles = getPlacementStyles({\n    ...state.context.positioning,\n    placement: state.context.currentPlacement\n  });\n  function getItemState(props) {\n    const disabled2 = collection2.getItemDisabled(props.item);\n    const value = collection2.getItemValue(props.item);\n    return {\n      value,\n      disabled: Boolean(disabled2 || disabled2),\n      highlighted: highlightedValue === value,\n      selected: state.context.value.includes(value)\n    };\n  }\n  return {\n    focused,\n    open,\n    inputValue: state.context.inputValue,\n    highlightedValue,\n    highlightedItem: state.context.highlightedItem,\n    value: state.context.value,\n    valueAsString: state.context.valueAsString,\n    hasSelectedItems: state.context.hasSelectedItems,\n    selectedItems: state.context.selectedItems,\n    collection: state.context.collection,\n    multiple: !!state.context.multiple,\n    disabled: !!disabled,\n    syncSelectedItems() {\n      send({\n        type: \"SELECTED_ITEMS.SYNC\"\n      });\n    },\n    reposition(options = {}) {\n      send({\n        type: \"POSITIONING.SET\",\n        options\n      });\n    },\n    setCollection(collection3) {\n      send({\n        type: \"COLLECTION.SET\",\n        value: collection3\n      });\n    },\n    setHighlightValue(value) {\n      send({\n        type: \"HIGHLIGHTED_VALUE.SET\",\n        value\n      });\n    },\n    selectValue(value) {\n      send({\n        type: \"ITEM.SELECT\",\n        value\n      });\n    },\n    setValue(value) {\n      send({\n        type: \"VALUE.SET\",\n        value\n      });\n    },\n    setInputValue(value) {\n      send({\n        type: \"INPUT_VALUE.SET\",\n        value\n      });\n    },\n    clearValue(value) {\n      if (value != null) {\n        send({\n          type: \"ITEM.CLEAR\",\n          value\n        });\n      } else {\n        send(\"VALUE.CLEAR\");\n      }\n    },\n    focus() {\n      dom.getInputEl(state.context)?.focus();\n    },\n    setOpen(nextOpen) {\n      if (nextOpen === open) return;\n      send(nextOpen ? \"OPEN\" : \"CLOSE\");\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        id: dom.getRootId(state.context),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly)\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        dir: state.context.dir,\n        htmlFor: dom.getInputId(state.context),\n        id: dom.getLabelId(state.context),\n        \"data-readonly\": dataAttr(readOnly),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-focus\": dataAttr(focused),\n        onClick(event) {\n          if (composite) return;\n          event.preventDefault();\n          dom.getTriggerEl(state.context)?.focus({\n            preventScroll: true\n          });\n        }\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        dir: state.context.dir,\n        id: dom.getControlId(state.context),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-focus\": dataAttr(focused),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid)\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        ...parts.positioner.attrs,\n        dir: state.context.dir,\n        id: dom.getPositionerId(state.context),\n        style: popperStyles.floating\n      });\n    },\n    getInputProps() {\n      return normalize.input({\n        ...parts.input.attrs,\n        dir: state.context.dir,\n        \"aria-invalid\": ariaAttr(invalid),\n        \"data-invalid\": dataAttr(invalid),\n        name: state.context.name,\n        form: state.context.form,\n        disabled,\n        autoFocus: state.context.autoFocus,\n        required: state.context.required,\n        autoComplete: \"off\",\n        autoCorrect: \"off\",\n        autoCapitalize: \"none\",\n        spellCheck: \"false\",\n        readOnly,\n        placeholder: state.context.placeholder,\n        id: dom.getInputId(state.context),\n        type: \"text\",\n        role: \"combobox\",\n        defaultValue: state.context.inputValue,\n        \"aria-autocomplete\": state.context.autoComplete ? \"both\" : \"list\",\n        \"aria-controls\": dom.getContentId(state.context),\n        \"aria-expanded\": open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-activedescendant\": highlightedValue ? dom.getItemId(state.context, highlightedValue) : void 0,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!state.context.openOnClick) return;\n          if (!interactive) return;\n          send(\"INPUT.CLICK\");\n        },\n        onFocus() {\n          if (disabled) return;\n          send(\"INPUT.FOCUS\");\n        },\n        onBlur() {\n          if (disabled) return;\n          send(\"INPUT.BLUR\");\n        },\n        onChange(event) {\n          send({\n            type: \"INPUT.CHANGE\",\n            value: event.currentTarget.value\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          if (event.ctrlKey || event.shiftKey || isComposingEvent(event)) return;\n          const openOnKeyPress = state.context.openOnKeyPress;\n          const isModifierKey = event.ctrlKey || event.metaKey || event.shiftKey;\n          const keypress = true;\n          const keymap = {\n            ArrowDown(event2) {\n              if (!openOnKeyPress && !open) return;\n              send({\n                type: event2.altKey ? \"OPEN\" : \"INPUT.ARROW_DOWN\",\n                keypress\n              });\n              event2.preventDefault();\n            },\n            ArrowUp() {\n              if (!openOnKeyPress && !open) return;\n              send({\n                type: event.altKey ? \"CLOSE\" : \"INPUT.ARROW_UP\",\n                keypress\n              });\n              event.preventDefault();\n            },\n            Home(event2) {\n              if (isModifierKey) return;\n              send({\n                type: \"INPUT.HOME\",\n                keypress\n              });\n              if (open) {\n                event2.preventDefault();\n              }\n            },\n            End(event2) {\n              if (isModifierKey) return;\n              send({\n                type: \"INPUT.END\",\n                keypress\n              });\n              if (open) {\n                event2.preventDefault();\n              }\n            },\n            Enter(event2) {\n              send({\n                type: \"INPUT.ENTER\",\n                keypress\n              });\n              if (open) {\n                event2.preventDefault();\n              }\n              const itemEl = dom.getHighlightedItemEl(state.context);\n              if (isAnchorElement(itemEl)) {\n                state.context.navigate({\n                  value: state.context.highlightedValue,\n                  node: itemEl\n                });\n              }\n            },\n            Escape() {\n              send({\n                type: \"INPUT.ESCAPE\",\n                keypress\n              });\n              event.preventDefault();\n            }\n          };\n          const key = getEventKey(event, state.context);\n          const exec = keymap[key];\n          exec?.(event);\n        }\n      });\n    },\n    getTriggerProps(props = {}) {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        dir: state.context.dir,\n        id: dom.getTriggerId(state.context),\n        \"aria-haspopup\": composite ? \"listbox\" : \"dialog\",\n        type: \"button\",\n        tabIndex: props.focusable ? void 0 : -1,\n        \"aria-label\": translations.triggerLabel,\n        \"aria-expanded\": open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-controls\": open ? dom.getContentId(state.context) : void 0,\n        disabled,\n        \"data-invalid\": dataAttr(invalid),\n        \"data-focusable\": dataAttr(props.focusable),\n        \"data-readonly\": dataAttr(readOnly),\n        \"data-disabled\": dataAttr(disabled),\n        onFocus() {\n          if (!props.focusable) return;\n          send({\n            type: \"INPUT.FOCUS\",\n            src: \"trigger\"\n          });\n        },\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          if (!isLeftClick(event)) return;\n          send(\"TRIGGER.CLICK\");\n        },\n        onPointerDown(event) {\n          if (!interactive) return;\n          if (event.pointerType === \"touch\") return;\n          event.preventDefault();\n          queueMicrotask(() => {\n            dom.getInputEl(state.context)?.focus({\n              preventScroll: true\n            });\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (composite) return;\n          const keyMap = {\n            ArrowDown() {\n              send({\n                type: \"INPUT.ARROW_DOWN\",\n                src: \"trigger\"\n              });\n            },\n            ArrowUp() {\n              send({\n                type: \"INPUT.ARROW_UP\",\n                src: \"trigger\"\n              });\n            }\n          };\n          const key = getEventKey(event, state.context);\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: state.context.dir,\n        id: dom.getContentId(state.context),\n        role: !composite ? \"dialog\" : \"listbox\",\n        tabIndex: -1,\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-placement\": state.context.currentPlacement,\n        \"aria-labelledby\": dom.getLabelId(state.context),\n        \"aria-multiselectable\": state.context.multiple && composite ? true : void 0,\n        onPointerDown(event) {\n          event.preventDefault();\n        }\n      });\n    },\n    getListProps() {\n      return normalize.element({\n        ...parts.list.attrs,\n        role: !composite ? \"listbox\" : void 0,\n        \"aria-labelledby\": dom.getLabelId(state.context),\n        \"aria-multiselectable\": state.context.multiple && !composite ? true : void 0\n      });\n    },\n    getClearTriggerProps() {\n      return normalize.button({\n        ...parts.clearTrigger.attrs,\n        dir: state.context.dir,\n        id: dom.getClearTriggerId(state.context),\n        type: \"button\",\n        tabIndex: -1,\n        disabled,\n        \"data-invalid\": dataAttr(invalid),\n        \"aria-label\": translations.clearTriggerLabel,\n        \"aria-controls\": dom.getInputId(state.context),\n        hidden: !state.context.value.length,\n        onPointerDown(event) {\n          event.preventDefault();\n        },\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          send({\n            type: \"VALUE.CLEAR\",\n            src: \"clear-trigger\"\n          });\n        }\n      });\n    },\n    getItemState,\n    getItemProps(props) {\n      const itemState = getItemState(props);\n      const value = itemState.value;\n      return normalize.element({\n        ...parts.item.attrs,\n        dir: state.context.dir,\n        id: dom.getItemId(state.context, value),\n        role: \"option\",\n        tabIndex: -1,\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        \"aria-selected\": ariaAttr(itemState.highlighted),\n        \"aria-disabled\": ariaAttr(itemState.disabled),\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-value\": itemState.value,\n        onPointerMove() {\n          if (itemState.disabled) return;\n          if (itemState.highlighted) return;\n          send({\n            type: \"ITEM.POINTER_MOVE\",\n            value\n          });\n        },\n        onPointerLeave() {\n          if (props.persistFocus) return;\n          if (itemState.disabled) return;\n          const mouseMoved = state.previousEvent.type.includes(\"POINTER\");\n          if (!mouseMoved) return;\n          send({\n            type: \"ITEM.POINTER_LEAVE\",\n            value\n          });\n        },\n        onClick(event) {\n          if (isDownloadingEvent(event)) return;\n          if (isOpeningInNewTab(event)) return;\n          if (isContextMenuEvent(event)) return;\n          if (itemState.disabled) return;\n          send({\n            type: \"ITEM.CLICK\",\n            src: \"click\",\n            value\n          });\n        }\n      });\n    },\n    getItemTextProps(props) {\n      const itemState = getItemState(props);\n      return normalize.element({\n        ...parts.itemText.attrs,\n        dir: state.context.dir,\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted)\n      });\n    },\n    getItemIndicatorProps(props) {\n      const itemState = getItemState(props);\n      return normalize.element({\n        \"aria-hidden\": true,\n        ...parts.itemIndicator.attrs,\n        dir: state.context.dir,\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        hidden: !itemState.selected\n      });\n    },\n    getItemGroupProps(props) {\n      const {\n        id\n      } = props;\n      return normalize.element({\n        ...parts.itemGroup.attrs,\n        dir: state.context.dir,\n        id: dom.getItemGroupId(state.context, id),\n        \"aria-labelledby\": dom.getItemGroupLabelId(state.context, id)\n      });\n    },\n    getItemGroupLabelProps(props) {\n      const {\n        htmlFor\n      } = props;\n      return normalize.element({\n        ...parts.itemGroupLabel.attrs,\n        dir: state.context.dir,\n        id: dom.getItemGroupLabelId(state.context, htmlFor),\n        role: \"group\"\n      });\n    }\n  };\n}\nvar {\n  and,\n  not\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"combobox\",\n    initial: ctx.open ? \"suggesting\" : \"idle\",\n    context: {\n      loopFocus: true,\n      openOnClick: false,\n      value: [],\n      highlightedValue: null,\n      inputValue: \"\",\n      allowCustomValue: false,\n      closeOnSelect: !ctx.multiple,\n      inputBehavior: \"none\",\n      selectionBehavior: \"replace\",\n      openOnKeyPress: true,\n      openOnChange: true,\n      composite: true,\n      readOnly: false,\n      disabled: false,\n      navigate({\n        node\n      }) {\n        clickIfLink(node);\n      },\n      ...ctx,\n      highlightedItem: null,\n      selectedItems: [],\n      valueAsString: \"\",\n      collection: ctx.collection ?? collection.empty(),\n      positioning: {\n        placement: \"bottom\",\n        sameWidth: true,\n        ...ctx.positioning\n      },\n      translations: {\n        triggerLabel: \"Toggle suggestions\",\n        clearTriggerLabel: \"Clear value\",\n        ...ctx.translations\n      }\n    },\n    created: [\"syncInitialValues\", \"syncSelectionBehavior\"],\n    computed: {\n      isInputValueEmpty: ctx2 => ctx2.inputValue.length === 0,\n      isInteractive: ctx2 => !(ctx2.readOnly || ctx2.disabled),\n      autoComplete: ctx2 => ctx2.inputBehavior === \"autocomplete\",\n      autoHighlight: ctx2 => ctx2.inputBehavior === \"autohighlight\",\n      hasSelectedItems: ctx2 => ctx2.value.length > 0\n    },\n    watch: {\n      value: [\"syncSelectedItems\"],\n      inputValue: [\"syncInputValue\"],\n      highlightedValue: [\"syncHighlightedItem\", \"autofillInputValue\"],\n      multiple: [\"syncSelectionBehavior\"],\n      open: [\"toggleVisibility\"]\n    },\n    on: {\n      \"SELECTED_ITEMS.SYNC\": {\n        actions: [\"syncSelectedItems\"]\n      },\n      \"HIGHLIGHTED_VALUE.SET\": {\n        actions: [\"setHighlightedItem\"]\n      },\n      \"ITEM.SELECT\": {\n        actions: [\"selectItem\"]\n      },\n      \"ITEM.CLEAR\": {\n        actions: [\"clearItem\"]\n      },\n      \"VALUE.SET\": {\n        actions: [\"setSelectedItems\"]\n      },\n      \"INPUT_VALUE.SET\": {\n        actions: \"setInputValue\"\n      },\n      \"COLLECTION.SET\": {\n        actions: [\"setCollection\"]\n      },\n      \"POSITIONING.SET\": {\n        actions: [\"reposition\"]\n      }\n    },\n    states: {\n      idle: {\n        tags: [\"idle\", \"closed\"],\n        entry: [\"scrollContentToTop\", \"clearHighlightedItem\"],\n        on: {\n          \"CONTROLLED.OPEN\": {\n            target: \"interacting\"\n          },\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"setInitialFocus\", \"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n          }, {\n            target: \"interacting\",\n            actions: [\"setInitialFocus\", \"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n          }],\n          \"INPUT.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n          }, {\n            target: \"interacting\",\n            actions: [\"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n          }],\n          \"INPUT.FOCUS\": {\n            target: \"focused\"\n          },\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"interacting\",\n            actions: [\"invokeOnOpen\"]\n          }],\n          \"VALUE.CLEAR\": {\n            target: \"focused\",\n            actions: [\"clearInputValue\", \"clearSelectedItems\", \"setInitialFocus\"]\n          }\n        }\n      },\n      focused: {\n        tags: [\"focused\", \"closed\"],\n        entry: [\"scrollContentToTop\", \"clearHighlightedItem\"],\n        on: {\n          \"CONTROLLED.OPEN\": [{\n            guard: \"isChangeEvent\",\n            target: \"suggesting\"\n          }, {\n            target: \"interacting\"\n          }],\n          \"INPUT.CHANGE\": [{\n            guard: and(\"isOpenControlled\", \"openOnChange\"),\n            actions: [\"setInputValue\", \"invokeOnOpen\", \"highlightFirstItemIfNeeded\"]\n          }, {\n            guard: \"openOnChange\",\n            target: \"suggesting\",\n            actions: [\"setInputValue\", \"invokeOnOpen\", \"highlightFirstItemIfNeeded\"]\n          }, {\n            actions: \"setInputValue\"\n          }],\n          \"LAYER.INTERACT_OUTSIDE\": {\n            target: \"idle\"\n          },\n          \"INPUT.ESCAPE\": {\n            guard: and(\"isCustomValue\", not(\"allowCustomValue\")),\n            actions: \"revertInputValue\"\n          },\n          \"INPUT.BLUR\": {\n            target: \"idle\"\n          },\n          \"INPUT.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n          }, {\n            target: \"interacting\",\n            actions: [\"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n          }],\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"setInitialFocus\", \"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n          }, {\n            target: \"interacting\",\n            actions: [\"setInitialFocus\", \"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n          }],\n          \"INPUT.ARROW_DOWN\": [\n          // == group 1 ==\n          {\n            guard: and(\"isOpenControlled\", \"autoComplete\"),\n            actions: [\"invokeOnOpen\"]\n          }, {\n            guard: \"autoComplete\",\n            target: \"interacting\",\n            actions: [\"invokeOnOpen\"]\n          },\n          // == group 2 ==\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"highlightFirstOrSelectedItem\", \"invokeOnOpen\"]\n          }, {\n            target: \"interacting\",\n            actions: [\"highlightFirstOrSelectedItem\", \"invokeOnOpen\"]\n          }],\n          \"INPUT.ARROW_UP\": [\n          // == group 1 ==\n          {\n            guard: \"autoComplete\",\n            target: \"interacting\",\n            actions: \"invokeOnOpen\"\n          }, {\n            guard: \"autoComplete\",\n            target: \"interacting\",\n            actions: \"invokeOnOpen\"\n          },\n          // == group 2 ==\n          {\n            target: \"interacting\",\n            actions: [\"highlightLastOrSelectedItem\", \"invokeOnOpen\"]\n          }, {\n            target: \"interacting\",\n            actions: [\"highlightLastOrSelectedItem\", \"invokeOnOpen\"]\n          }],\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"interacting\",\n            actions: [\"invokeOnOpen\"]\n          }],\n          \"VALUE.CLEAR\": {\n            actions: [\"clearInputValue\", \"clearSelectedItems\"]\n          }\n        }\n      },\n      interacting: {\n        tags: [\"open\", \"focused\"],\n        entry: [\"setInitialFocus\"],\n        activities: [\"scrollToHighlightedItem\", \"trackDismissableLayer\", \"computePlacement\", \"hideOtherElements\"],\n        on: {\n          \"CONTROLLED.CLOSE\": [{\n            guard: \"restoreFocus\",\n            target: \"focused\",\n            actions: [\"setFinalFocus\"]\n          }, {\n            target: \"idle\"\n          }],\n          \"INPUT.HOME\": {\n            actions: [\"highlightFirstItem\"]\n          },\n          \"INPUT.END\": {\n            actions: [\"highlightLastItem\"]\n          },\n          \"INPUT.ARROW_DOWN\": [{\n            guard: and(\"autoComplete\", \"isLastItemHighlighted\"),\n            actions: [\"clearHighlightedItem\", \"scrollContentToTop\"]\n          }, {\n            actions: [\"highlightNextItem\"]\n          }],\n          \"INPUT.ARROW_UP\": [{\n            guard: and(\"autoComplete\", \"isFirstItemHighlighted\"),\n            actions: \"clearHighlightedItem\"\n          }, {\n            actions: \"highlightPrevItem\"\n          }],\n          \"INPUT.ENTER\": [\n          // == group 1 ==\n          {\n            guard: and(\"isOpenControlled\", \"isCustomValue\", not(\"hasHighlightedItem\"), not(\"allowCustomValue\")),\n            actions: [\"revertInputValue\", \"invokeOnClose\"]\n          }, {\n            guard: and(\"isCustomValue\", not(\"hasHighlightedItem\"), not(\"allowCustomValue\")),\n            target: \"focused\",\n            actions: [\"revertInputValue\", \"invokeOnClose\"]\n          },\n          // == group 2 ==\n          {\n            guard: and(\"isOpenControlled\", \"closeOnSelect\"),\n            actions: [\"selectHighlightedItem\", \"invokeOnClose\"]\n          }, {\n            guard: \"closeOnSelect\",\n            target: \"focused\",\n            actions: [\"selectHighlightedItem\", \"invokeOnClose\", \"setFinalFocus\"]\n          }, {\n            actions: [\"selectHighlightedItem\"]\n          }],\n          \"INPUT.CHANGE\": [{\n            guard: \"autoComplete\",\n            target: \"suggesting\",\n            actions: [\"setInputValue\", \"invokeOnOpen\"]\n          }, {\n            target: \"suggesting\",\n            actions: [\"clearHighlightedItem\", \"setInputValue\", \"invokeOnOpen\"]\n          }],\n          \"ITEM.POINTER_MOVE\": {\n            actions: [\"setHighlightedItem\"]\n          },\n          \"ITEM.POINTER_LEAVE\": {\n            actions: [\"clearHighlightedItem\"]\n          },\n          \"ITEM.CLICK\": [{\n            guard: and(\"isOpenControlled\", \"closeOnSelect\"),\n            actions: [\"selectItem\", \"invokeOnClose\"]\n          }, {\n            guard: \"closeOnSelect\",\n            target: \"focused\",\n            actions: [\"selectItem\", \"invokeOnClose\", \"setFinalFocus\"]\n          }, {\n            actions: [\"selectItem\"]\n          }],\n          \"LAYER.ESCAPE\": [{\n            guard: and(\"isOpenControlled\", \"autoComplete\"),\n            actions: [\"syncInputValue\", \"invokeOnClose\"]\n          }, {\n            guard: \"autoComplete\",\n            target: \"focused\",\n            actions: [\"syncInputValue\", \"invokeOnClose\"]\n          }, {\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnClose\"\n          }, {\n            target: \"focused\",\n            actions: [\"invokeOnClose\", \"setFinalFocus\"]\n          }],\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnClose\"\n          }, {\n            target: \"focused\",\n            actions: \"invokeOnClose\"\n          }],\n          \"LAYER.INTERACT_OUTSIDE\": [\n          // == group 1 ==\n          {\n            guard: and(\"isOpenControlled\", \"isCustomValue\", not(\"allowCustomValue\")),\n            actions: [\"revertInputValue\", \"invokeOnClose\"]\n          }, {\n            guard: and(\"isCustomValue\", not(\"allowCustomValue\")),\n            target: \"idle\",\n            actions: [\"revertInputValue\", \"invokeOnClose\"]\n          },\n          // == group 2 ==\n          {\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnClose\"\n          }, {\n            target: \"idle\",\n            actions: \"invokeOnClose\"\n          }],\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"focused\",\n            actions: [\"invokeOnClose\", \"setFinalFocus\"]\n          }],\n          \"VALUE.CLEAR\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"clearInputValue\", \"clearSelectedItems\", \"invokeOnClose\"]\n          }, {\n            target: \"focused\",\n            actions: [\"clearInputValue\", \"clearSelectedItems\", \"invokeOnClose\", \"setFinalFocus\"]\n          }]\n        }\n      },\n      suggesting: {\n        tags: [\"open\", \"focused\"],\n        activities: [\"trackDismissableLayer\", \"scrollToHighlightedItem\", \"computePlacement\", \"trackChildNodes\", \"hideOtherElements\"],\n        entry: [\"setInitialFocus\"],\n        on: {\n          \"CONTROLLED.CLOSE\": [{\n            guard: \"restoreFocus\",\n            target: \"focused\",\n            actions: [\"setFinalFocus\"]\n          }, {\n            target: \"idle\"\n          }],\n          CHILDREN_CHANGE: {\n            actions: [\"highlightFirstItem\"]\n          },\n          \"INPUT.ARROW_DOWN\": {\n            target: \"interacting\",\n            actions: [\"highlightNextItem\"]\n          },\n          \"INPUT.ARROW_UP\": {\n            target: \"interacting\",\n            actions: [\"highlightPrevItem\"]\n          },\n          \"INPUT.HOME\": {\n            target: \"interacting\",\n            actions: [\"highlightFirstItem\"]\n          },\n          \"INPUT.END\": {\n            target: \"interacting\",\n            actions: [\"highlightLastItem\"]\n          },\n          \"INPUT.ENTER\": [\n          // == group 1 ==\n          {\n            guard: and(\"isOpenControlled\", \"isCustomValue\", not(\"hasHighlightedItem\"), not(\"allowCustomValue\")),\n            actions: [\"revertInputValue\", \"invokeOnClose\"]\n          }, {\n            guard: and(\"isCustomValue\", not(\"hasHighlightedItem\"), not(\"allowCustomValue\")),\n            target: \"focused\",\n            actions: [\"revertInputValue\", \"invokeOnClose\"]\n          },\n          // == group 2 ==\n          {\n            guard: and(\"isOpenControlled\", \"closeOnSelect\"),\n            actions: [\"selectHighlightedItem\", \"invokeOnClose\"]\n          }, {\n            guard: \"closeOnSelect\",\n            target: \"focused\",\n            actions: [\"selectHighlightedItem\", \"invokeOnClose\", \"setFinalFocus\"]\n          }, {\n            actions: [\"selectHighlightedItem\"]\n          }],\n          \"INPUT.CHANGE\": [{\n            guard: \"autoHighlight\",\n            actions: [\"setInputValue\"]\n          }, {\n            actions: [\"setInputValue\"]\n          }],\n          \"LAYER.ESCAPE\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"focused\",\n            actions: [\"invokeOnClose\"]\n          }],\n          \"ITEM.POINTER_MOVE\": {\n            target: \"interacting\",\n            actions: [\"setHighlightedItem\"]\n          },\n          \"ITEM.POINTER_LEAVE\": {\n            actions: [\"clearHighlightedItem\"]\n          },\n          \"LAYER.INTERACT_OUTSIDE\": [\n          // == group 1 ==\n          {\n            guard: and(\"isOpenControlled\", \"isCustomValue\", not(\"allowCustomValue\")),\n            actions: [\"revertInputValue\", \"invokeOnClose\"]\n          }, {\n            guard: and(\"isCustomValue\", not(\"allowCustomValue\")),\n            target: \"idle\",\n            actions: [\"revertInputValue\", \"invokeOnClose\"]\n          },\n          // == group 2 ==\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"idle\",\n            actions: [\"invokeOnClose\"]\n          }],\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"focused\",\n            actions: [\"invokeOnClose\"]\n          }],\n          \"ITEM.CLICK\": [{\n            guard: and(\"isOpenControlled\", \"closeOnSelect\"),\n            actions: [\"selectItem\", \"invokeOnClose\"]\n          }, {\n            guard: \"closeOnSelect\",\n            target: \"focused\",\n            actions: [\"selectItem\", \"invokeOnClose\", \"setFinalFocus\"]\n          }, {\n            actions: [\"selectItem\"]\n          }],\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"focused\",\n            actions: [\"invokeOnClose\", \"setFinalFocus\"]\n          }],\n          \"VALUE.CLEAR\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"clearInputValue\", \"clearSelectedItems\", \"invokeOnClose\"]\n          }, {\n            target: \"focused\",\n            actions: [\"clearInputValue\", \"clearSelectedItems\", \"invokeOnClose\", \"setFinalFocus\"]\n          }]\n        }\n      }\n    }\n  }, {\n    guards: {\n      isInputValueEmpty: ctx2 => ctx2.isInputValueEmpty,\n      autoComplete: ctx2 => ctx2.autoComplete && !ctx2.multiple,\n      autoHighlight: ctx2 => ctx2.autoHighlight,\n      isFirstItemHighlighted: ctx2 => ctx2.collection.firstValue === ctx2.highlightedValue,\n      isLastItemHighlighted: ctx2 => ctx2.collection.lastValue === ctx2.highlightedValue,\n      isCustomValue: ctx2 => ctx2.inputValue !== ctx2.valueAsString,\n      allowCustomValue: ctx2 => !!ctx2.allowCustomValue,\n      hasHighlightedItem: ctx2 => ctx2.highlightedValue != null,\n      closeOnSelect: ctx2 => !!ctx2.closeOnSelect,\n      isOpenControlled: ctx2 => !!ctx2[\"open.controlled\"],\n      openOnChange: (ctx2, evt) => {\n        if (isBoolean(ctx2.openOnChange)) return ctx2.openOnChange;\n        return !!ctx2.openOnChange?.({\n          inputValue: evt.value\n        });\n      },\n      restoreFocus: (_ctx, evt) => evt.restoreFocus == null ? true : !!evt.restoreFocus,\n      isChangeEvent: (_ctx, evt) => evt.previousEvent?.type === \"INPUT.CHANGE\"\n    },\n    activities: {\n      trackDismissableLayer(ctx2, _evt, {\n        send\n      }) {\n        if (ctx2.disableLayer) return;\n        const contentEl = () => dom.getContentEl(ctx2);\n        return trackDismissableElement(contentEl, {\n          defer: true,\n          exclude: () => [dom.getInputEl(ctx2), dom.getTriggerEl(ctx2), dom.getClearTriggerEl(ctx2)],\n          onFocusOutside: ctx2.onFocusOutside,\n          onPointerDownOutside: ctx2.onPointerDownOutside,\n          onInteractOutside: ctx2.onInteractOutside,\n          onEscapeKeyDown(event) {\n            event.preventDefault();\n            event.stopPropagation();\n            send(\"LAYER.ESCAPE\");\n          },\n          onDismiss() {\n            send({\n              type: \"LAYER.INTERACT_OUTSIDE\",\n              restoreFocus: false\n            });\n          }\n        });\n      },\n      hideOtherElements(ctx2) {\n        return ariaHidden([dom.getInputEl(ctx2), dom.getContentEl(ctx2), dom.getTriggerEl(ctx2), dom.getClearTriggerEl(ctx2)]);\n      },\n      computePlacement(ctx2) {\n        const controlEl = () => dom.getControlEl(ctx2);\n        const positionerEl = () => dom.getPositionerEl(ctx2);\n        ctx2.currentPlacement = ctx2.positioning.placement;\n        return getPlacement(controlEl, positionerEl, {\n          ...ctx2.positioning,\n          defer: true,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      // in event the options are fetched (async), we still want to auto-highlight the first option\n      trackChildNodes(ctx2, _evt, {\n        send\n      }) {\n        if (!ctx2.autoHighlight) return;\n        const exec = () => send(\"CHILDREN_CHANGE\");\n        const contentEl = () => dom.getContentEl(ctx2);\n        return observeChildren(contentEl, {\n          callback: exec,\n          defer: true\n        });\n      },\n      scrollToHighlightedItem(ctx2, _evt, {\n        getState\n      }) {\n        const inputEl = dom.getInputEl(ctx2);\n        let cleanups = [];\n        const exec = immediate => {\n          const state = getState();\n          const pointer = state.event.type.includes(\"POINTER\");\n          if (pointer || !ctx2.highlightedValue) return;\n          const itemEl = dom.getHighlightedItemEl(ctx2);\n          const contentEl = dom.getContentEl(ctx2);\n          if (ctx2.scrollToIndexFn) {\n            const highlightedIndex = ctx2.collection.indexOf(ctx2.highlightedValue);\n            ctx2.scrollToIndexFn({\n              index: highlightedIndex,\n              immediate\n            });\n            return;\n          }\n          const rafCleanup2 = raf(() => {\n            scrollIntoView(itemEl, {\n              rootEl: contentEl,\n              block: \"nearest\"\n            });\n          });\n          cleanups.push(rafCleanup2);\n        };\n        const rafCleanup = raf(() => exec(true));\n        cleanups.push(rafCleanup);\n        const observerCleanup = observeAttributes(inputEl, {\n          attributes: [\"aria-activedescendant\"],\n          callback: () => exec(false)\n        });\n        cleanups.push(observerCleanup);\n        return () => {\n          cleanups.forEach(cleanup => cleanup());\n        };\n      }\n    },\n    actions: {\n      reposition(ctx2, evt) {\n        const controlEl = () => dom.getControlEl(ctx2);\n        const positionerEl = () => dom.getPositionerEl(ctx2);\n        getPlacement(controlEl, positionerEl, {\n          ...ctx2.positioning,\n          ...evt.options,\n          defer: true,\n          listeners: false,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      setHighlightedItem(ctx2, evt) {\n        if (evt.value == null) return;\n        set.highlightedValue(ctx2, evt.value);\n      },\n      clearHighlightedItem(ctx2) {\n        set.highlightedValue(ctx2, null, true);\n      },\n      selectHighlightedItem(ctx2) {\n        set.value(ctx2, ctx2.highlightedValue);\n        set.inputValue(ctx2, getInputValue(ctx2));\n      },\n      selectItem(ctx2, evt) {\n        if (evt.value == null) return;\n        set.value(ctx2, evt.value);\n        set.inputValue(ctx2, getInputValue(ctx2));\n      },\n      clearItem(ctx2, evt) {\n        if (evt.value == null) return;\n        const value = ctx2.value.filter(v => v !== evt.value);\n        set.value(ctx2, value);\n        set.inputValue(ctx2, getInputValue(ctx2));\n      },\n      setInitialFocus(ctx2) {\n        raf(() => {\n          dom.focusInputEl(ctx2);\n        });\n      },\n      setFinalFocus(ctx2) {\n        raf(() => {\n          const triggerEl = dom.getTriggerEl(ctx2);\n          if (triggerEl?.dataset.focusable == null) {\n            dom.focusInputEl(ctx2);\n          } else {\n            dom.focusTriggerEl(ctx2);\n          }\n        });\n      },\n      syncInputValue(ctx2) {\n        const inputEl = dom.getInputEl(ctx2);\n        if (!inputEl) return;\n        inputEl.value = ctx2.inputValue;\n        queueMicrotask(() => {\n          const {\n            selectionStart,\n            selectionEnd\n          } = inputEl;\n          if (Math.abs((selectionEnd ?? 0) - (selectionStart ?? 0)) !== 0) return;\n          if (selectionStart !== 0) return;\n          inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);\n        });\n      },\n      setInputValue(ctx2, evt) {\n        set.inputValue(ctx2, evt.value);\n      },\n      clearInputValue(ctx2) {\n        set.inputValue(ctx2, \"\");\n      },\n      revertInputValue(ctx2) {\n        const inputValue = match(ctx2.selectionBehavior, {\n          replace: ctx2.hasSelectedItems ? ctx2.valueAsString : \"\",\n          preserve: ctx2.inputValue,\n          clear: \"\"\n        });\n        set.inputValue(ctx2, inputValue);\n      },\n      syncInitialValues(ctx2) {\n        const selectedItems = ctx2.collection.findMany(ctx2.value);\n        const valueAsString = ctx2.collection.stringifyMany(ctx2.value);\n        ctx2.highlightedItem = ctx2.collection.find(ctx2.highlightedValue);\n        ctx2.selectedItems = selectedItems;\n        ctx2.valueAsString = valueAsString;\n        if (ctx2.inputValue.trim() || ctx2.multiple) return;\n        ctx2.inputValue = match(ctx2.selectionBehavior, {\n          preserve: ctx2.inputValue || valueAsString,\n          replace: valueAsString,\n          clear: \"\"\n        });\n      },\n      syncSelectionBehavior(ctx2) {\n        if (ctx2.multiple) {\n          ctx2.selectionBehavior = \"clear\";\n        }\n      },\n      setSelectedItems(ctx2, evt) {\n        if (!isArray(evt.value)) return;\n        set.value(ctx2, evt.value);\n        set.inputValue(ctx2, getInputValue(ctx2));\n      },\n      clearSelectedItems(ctx2) {\n        set.value(ctx2, []);\n        set.inputValue(ctx2, getInputValue(ctx2));\n      },\n      scrollContentToTop(ctx2) {\n        if (ctx2.scrollToIndexFn) {\n          ctx2.scrollToIndexFn({\n            index: 0,\n            immediate: true\n          });\n        } else {\n          const contentEl = dom.getContentEl(ctx2);\n          if (!contentEl) return;\n          contentEl.scrollTop = 0;\n        }\n      },\n      invokeOnOpen(ctx2) {\n        ctx2.onOpenChange?.({\n          open: true\n        });\n      },\n      invokeOnClose(ctx2) {\n        ctx2.onOpenChange?.({\n          open: false\n        });\n      },\n      highlightFirstItem(ctx2) {\n        raf(() => {\n          const value = ctx2.collection.firstValue;\n          set.highlightedValue(ctx2, value, true);\n        });\n      },\n      highlightFirstItemIfNeeded(ctx2) {\n        if (!ctx2.autoHighlight) return;\n        raf(() => {\n          const value = ctx2.collection.firstValue;\n          set.highlightedValue(ctx2, value);\n        });\n      },\n      highlightLastItem(ctx2) {\n        raf(() => {\n          const value = ctx2.collection.lastValue;\n          set.highlightedValue(ctx2, value);\n        });\n      },\n      highlightNextItem(ctx2) {\n        let value = null;\n        if (ctx2.highlightedValue) {\n          value = ctx2.collection.getNextValue(ctx2.highlightedValue);\n          if (!value && ctx2.loopFocus) value = ctx2.collection.firstValue;\n        } else {\n          value = ctx2.collection.firstValue;\n        }\n        set.highlightedValue(ctx2, value);\n      },\n      highlightPrevItem(ctx2) {\n        let value = null;\n        if (ctx2.highlightedValue) {\n          value = ctx2.collection.getPreviousValue(ctx2.highlightedValue);\n          if (!value && ctx2.loopFocus) value = ctx2.collection.lastValue;\n        } else {\n          value = ctx2.collection.lastValue;\n        }\n        set.highlightedValue(ctx2, value);\n      },\n      highlightFirstSelectedItem(ctx2) {\n        raf(() => {\n          const [value] = ctx2.collection.sort(ctx2.value);\n          set.highlightedValue(ctx2, value);\n        });\n      },\n      highlightFirstOrSelectedItem(ctx2) {\n        raf(() => {\n          let value = null;\n          if (ctx2.hasSelectedItems) {\n            value = ctx2.collection.sort(ctx2.value)[0];\n          } else {\n            value = ctx2.collection.firstValue;\n          }\n          set.highlightedValue(ctx2, value);\n        });\n      },\n      highlightLastOrSelectedItem(ctx2) {\n        raf(() => {\n          let value = null;\n          if (ctx2.hasSelectedItems) {\n            value = ctx2.collection.sort(ctx2.value)[0];\n          } else {\n            value = ctx2.collection.lastValue;\n          }\n          set.highlightedValue(ctx2, value);\n        });\n      },\n      autofillInputValue(ctx2, evt) {\n        const inputEl = dom.getInputEl(ctx2);\n        if (!ctx2.autoComplete || !inputEl || !evt.keypress) return;\n        const valueText = ctx2.collection.stringify(ctx2.highlightedValue);\n        raf(() => {\n          inputEl.value = valueText || ctx2.inputValue;\n        });\n      },\n      setCollection(ctx2, evt) {\n        ctx2.collection = evt.value;\n      },\n      syncSelectedItems(ctx2) {\n        sync.valueChange(ctx2);\n        set.inputValue(ctx2, getInputValue(ctx2));\n      },\n      syncHighlightedItem(ctx2) {\n        sync.highlightChange(ctx2);\n      },\n      toggleVisibility(ctx2, evt, {\n        send\n      }) {\n        send({\n          type: ctx2.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: evt\n        });\n      }\n    }\n  });\n}\nfunction getInputValue(ctx) {\n  return match(ctx.selectionBehavior, {\n    preserve: ctx.inputValue,\n    replace: ctx.valueAsString,\n    clear: \"\"\n  });\n}\nvar sync = {\n  valueChange: ctx => {\n    const prevSelectedItems = ctx.selectedItems;\n    ctx.selectedItems = ctx.value.map(v => {\n      const foundItem = prevSelectedItems.find(item => ctx.collection.getItemValue(item) === v);\n      if (foundItem) return foundItem;\n      return ctx.collection.find(v);\n    });\n    ctx.valueAsString = ctx.collection.stringifyItems(ctx.selectedItems);\n  },\n  highlightChange: ctx => {\n    ctx.highlightedItem = ctx.collection.find(ctx.highlightedValue);\n  }\n};\nvar invoke = {\n  valueChange: ctx => {\n    sync.valueChange(ctx);\n    ctx.onValueChange?.({\n      value: Array.from(ctx.value),\n      items: Array.from(ctx.selectedItems)\n    });\n  },\n  highlightChange: ctx => {\n    sync.highlightChange(ctx);\n    ctx.onHighlightChange?.({\n      highlightedValue: ctx.highlightedValue,\n      highlightedItem: ctx.highlightedItem\n    });\n  },\n  inputChange: ctx => {\n    ctx.onInputValueChange?.({\n      inputValue: ctx.inputValue\n    });\n  }\n};\nvar set = {\n  value: (ctx, value, force = false) => {\n    if (isEqual(ctx.value, value)) return;\n    if (value == null && !force) return;\n    if (value == null && force) {\n      ctx.value = [];\n      invoke.valueChange(ctx);\n      return;\n    }\n    if (isArray(value)) {\n      ctx.value = value;\n    } else if (value != null) {\n      ctx.value = ctx.multiple ? addOrRemove(ctx.value, value) : [value];\n    }\n    invoke.valueChange(ctx);\n  },\n  highlightedValue: (ctx, value, force = false) => {\n    if (isEqual(ctx.highlightedValue, value)) return;\n    if (!value && !force) return;\n    ctx.highlightedValue = value || null;\n    invoke.highlightChange(ctx);\n  },\n  inputValue: (ctx, value) => {\n    if (isEqual(ctx.inputValue, value)) return;\n    ctx.inputValue = value;\n    invoke.inputChange(ctx);\n  }\n};\nexport { anatomy, collection, connect, machine };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
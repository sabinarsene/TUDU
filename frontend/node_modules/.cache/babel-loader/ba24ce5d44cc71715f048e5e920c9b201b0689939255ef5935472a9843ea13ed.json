{"ast":null,"code":"\"use strict\";\n\nimport { compact } from '../utils/compact.js';\nimport { createProps } from '../utils/create-props.js';\nimport { isString, isObject, isFunction } from '../utils/is.js';\nimport { memo } from '../utils/memo.js';\nimport { mapObject, walkObject } from '../utils/walk-object.js';\nimport { cssVar } from './css-var.js';\nimport { esc } from './esc.js';\nimport { expandTokenReferences } from './expand-reference.js';\nimport { mapToJson } from './map-to-json.js';\nimport { TOKEN_PATH_REGEX, hasReference, expandReferences, getReferences } from './references.js';\nimport { tokenMiddlewares } from './token-middleware.js';\nimport { tokenTransforms } from './token-transforms.js';\nconst isToken = value => {\n  return isObject(value) && Object.prototype.hasOwnProperty.call(value, \"value\");\n};\nfunction expandBreakpoints(breakpoints) {\n  if (!breakpoints) return {\n    breakpoints: {},\n    sizes: {}\n  };\n  return {\n    breakpoints: mapObject(breakpoints, value => ({\n      value\n    })),\n    sizes: Object.fromEntries(Object.entries(breakpoints).map(([key, value]) => [`breakpoint-${key}`, {\n      value\n    }]))\n  };\n}\nfunction createTokenDictionary(options) {\n  const {\n    prefix = \"\",\n    tokens = {},\n    semanticTokens = {},\n    breakpoints = {}\n  } = options;\n  const formatTokenName = path => path.join(\".\");\n  const formatCssVar = (path, prefix2) => cssVar(path.join(\"-\"), {\n    prefix: prefix2\n  });\n  const allTokens = [];\n  const tokenNameMap = /* @__PURE__ */new Map();\n  const conditionMap = /* @__PURE__ */new Map();\n  const cssVarMap = /* @__PURE__ */new Map();\n  const colorPaletteMap = /* @__PURE__ */new Map();\n  const flatMap = /* @__PURE__ */new Map();\n  const byCategory = /* @__PURE__ */new Map();\n  const categoryMap = /* @__PURE__ */new Map();\n  const transforms = /* @__PURE__ */new Map();\n  const middlewares = [];\n  function registerToken(token, phase) {\n    allTokens.push(token);\n    tokenNameMap.set(token.name, token);\n    if (phase) {\n      transforms.forEach(fn => {\n        if (fn.enforce === phase) transformToken(fn, token);\n      });\n    }\n  }\n  const breakpointTokens = expandBreakpoints(breakpoints);\n  const computedTokens = compact({\n    ...tokens,\n    breakpoints: breakpointTokens.breakpoints,\n    sizes: {\n      ...tokens.sizes,\n      ...breakpointTokens.sizes\n    }\n  });\n  function registerTokens() {\n    walkObject(computedTokens, (entry, path) => {\n      const isDefault = path.includes(\"DEFAULT\");\n      path = filterDefault(path);\n      const category = path[0];\n      const name = formatTokenName(path);\n      const t = isString(entry) ? {\n        value: entry\n      } : entry;\n      const token = {\n        value: t.value,\n        originalValue: t.value,\n        name,\n        path,\n        extensions: {\n          condition: \"base\",\n          originalPath: path,\n          category,\n          prop: formatTokenName(path.slice(1))\n        }\n      };\n      if (isDefault) {\n        token.extensions.default = true;\n      }\n      registerToken(token);\n    }, {\n      stop: isToken\n    });\n    walkObject(semanticTokens, (entry, path) => {\n      const isDefault = path.includes(\"DEFAULT\");\n      path = filterBaseCondition(filterDefault(path));\n      const category = path[0];\n      const name = formatTokenName(path);\n      const t = isString(entry.value) ? {\n        value: {\n          base: entry.value\n        }\n      } : entry;\n      const token = {\n        value: t.value.base || \"\",\n        originalValue: t.value.base || \"\",\n        name,\n        path,\n        extensions: {\n          originalPath: path,\n          category,\n          conditions: t.value,\n          condition: \"base\",\n          prop: formatTokenName(path.slice(1))\n        }\n      };\n      if (isDefault) {\n        token.extensions.default = true;\n      }\n      registerToken(token);\n    }, {\n      stop: isToken\n    });\n  }\n  function getByName(name) {\n    return tokenNameMap.get(name);\n  }\n  function buildConditionMap(token) {\n    const {\n      condition\n    } = token.extensions;\n    if (!condition) return;\n    if (!conditionMap.has(condition)) {\n      conditionMap.set(condition, /* @__PURE__ */new Set());\n    }\n    conditionMap.get(condition).add(token);\n  }\n  function buildCategoryMap(token) {\n    const {\n      category,\n      prop\n    } = token.extensions;\n    if (!category) return;\n    if (!categoryMap.has(category)) {\n      categoryMap.set(category, /* @__PURE__ */new Map());\n    }\n    categoryMap.get(category).set(prop, token);\n  }\n  function buildCssVars(token) {\n    const {\n      condition,\n      negative,\n      virtual,\n      cssVar: cssVar2\n    } = token.extensions;\n    if (negative || virtual || !condition || !cssVar2) return;\n    if (!cssVarMap.has(condition)) {\n      cssVarMap.set(condition, /* @__PURE__ */new Map());\n    }\n    cssVarMap.get(condition).set(cssVar2.var, token.value);\n  }\n  function buildFlatMap(token) {\n    const {\n      category,\n      prop,\n      cssVar: cssVar2,\n      negative\n    } = token.extensions;\n    if (!category) return;\n    if (!byCategory.has(category)) {\n      byCategory.set(category, /* @__PURE__ */new Map());\n    }\n    const value = negative ? token.extensions.conditions ? token.originalValue : token.value : cssVar2.ref;\n    byCategory.get(category).set(prop, value);\n    flatMap.set([category, prop].join(\".\"), value);\n  }\n  function buildColorPalette(token) {\n    const {\n      colorPalette,\n      virtual,\n      default: isDefault\n    } = token.extensions;\n    if (!colorPalette || virtual) return;\n    colorPalette.roots.forEach(root => {\n      const name = formatTokenName(root);\n      if (!colorPaletteMap.has(name)) {\n        colorPaletteMap.set(name, /* @__PURE__ */new Map());\n      }\n      const virtualPath = replaceRootWithColorPalette([...token.path], [...root]);\n      const virtualName = formatTokenName(virtualPath);\n      const virtualToken = getByName(virtualName);\n      if (!virtualToken || !virtualToken.extensions.cssVar) return;\n      const {\n        var: virtualVar\n      } = virtualToken.extensions.cssVar;\n      colorPaletteMap.get(name).set(virtualVar, token.extensions.cssVar.ref);\n      if (isDefault && root.length === 1) {\n        const colorPaletteName = formatTokenName([\"colors\", \"colorPalette\"]);\n        const colorPaletteToken = getByName(colorPaletteName);\n        if (!colorPaletteToken) return;\n        const name2 = formatTokenName(token.path);\n        const virtualToken2 = getByName(name2);\n        if (!virtualToken2) return;\n        const keyPath = colorPalette.keys[0]?.filter(Boolean);\n        if (!keyPath.length) return;\n        const computedName = formatTokenName(root.concat(keyPath));\n        if (!colorPaletteMap.has(computedName)) {\n          colorPaletteMap.set(computedName, /* @__PURE__ */new Map());\n        }\n        colorPaletteMap.get(computedName).set(colorPaletteToken.extensions.cssVar.var, virtualToken2.extensions.cssVar.ref);\n      }\n    });\n  }\n  let byCategoryJson = {};\n  function setupViews() {\n    allTokens.forEach(token => {\n      buildConditionMap(token);\n      buildCategoryMap(token);\n      buildCssVars(token);\n      buildFlatMap(token);\n      buildColorPalette(token);\n    });\n    byCategoryJson = mapToJson(byCategory);\n  }\n  const colorMix = (value, tokenFn) => {\n    if (!value || typeof value !== \"string\") return {\n      invalid: true,\n      value\n    };\n    const [colorPath, rawOpacity] = value.split(\"/\");\n    if (!colorPath || !rawOpacity) {\n      return {\n        invalid: true,\n        value: colorPath\n      };\n    }\n    const colorToken = tokenFn(colorPath);\n    const opacityToken = getByName(`opacity.${rawOpacity}`)?.value;\n    if (!opacityToken && isNaN(Number(rawOpacity))) {\n      return {\n        invalid: true,\n        value: colorPath\n      };\n    }\n    const percent = opacityToken ? Number(opacityToken) * 100 + \"%\" : `${rawOpacity}%`;\n    const color = colorToken ?? colorPath;\n    return {\n      invalid: false,\n      color,\n      value: `color-mix(in srgb, ${color} ${percent}, transparent)`\n    };\n  };\n  const getVar = memo((value, fallback) => {\n    return flatMap.get(value) ?? fallback;\n  });\n  const getCategoryValues = memo(category => {\n    return byCategoryJson[category] || null;\n  });\n  const expandReferenceInValue = memo(value => {\n    return expandTokenReferences(value, path => {\n      if (!path) return;\n      if (path.includes(\"/\")) {\n        const mix = colorMix(path, v => getVar(v));\n        if (mix.invalid) {\n          throw new Error(\"Invalid color mix at \" + path + \": \" + mix.value);\n        }\n        return mix.value;\n      }\n      const resolved = getVar(path);\n      if (resolved) return resolved;\n      return TOKEN_PATH_REGEX.test(path) ? esc(path) : path;\n    });\n  });\n  const dictionary = {\n    prefix,\n    allTokens,\n    tokenMap: tokenNameMap,\n    registerToken,\n    getByName,\n    formatTokenName,\n    formatCssVar,\n    flatMap,\n    cssVarMap,\n    categoryMap,\n    colorPaletteMap,\n    getVar,\n    getCategoryValues,\n    expandReferenceInValue\n  };\n  function registerTransform(...fns) {\n    fns.forEach(fn => {\n      transforms.set(fn.name, fn);\n    });\n  }\n  function registerMiddleware(...fns) {\n    middlewares.push(...fns);\n  }\n  function transformToken(transform, token) {\n    if (token.extensions.references) return;\n    if (isFunction(transform.match) && !transform.match(token)) return;\n    const fn = v => transform.transform(v, dictionary);\n    const transformed = fn(token);\n    switch (true) {\n      case transform.type === \"extensions\":\n        Object.assign(token.extensions, transformed);\n        break;\n      case transform.type === \"value\":\n        token.value = transformed;\n        break;\n      default:\n        token[transform.type] = transformed;\n        break;\n    }\n  }\n  function applyMiddlewares(enforce) {\n    middlewares.forEach(middleware => {\n      if (middleware.enforce === enforce) {\n        middleware.transform(dictionary);\n      }\n    });\n  }\n  function applyTransforms(enforce) {\n    transforms.forEach(transform => {\n      if (transform.enforce === enforce) {\n        allTokens.forEach(token => {\n          transformToken(transform, token);\n        });\n      }\n    });\n  }\n  function addConditionalTokens() {\n    allTokens.forEach(token => {\n      const tokens2 = getConditionalTokens(token);\n      if (!tokens2 || tokens2.length === 0) return;\n      tokens2.forEach(token2 => {\n        registerToken(token2);\n      });\n    });\n  }\n  function getTokenReferences(value) {\n    const refs = getReferences(value);\n    return refs.map(ref => getByName(ref)).filter(Boolean);\n  }\n  function addReferences() {\n    allTokens.forEach(token => {\n      if (!hasReference(token.value)) return;\n      const references = getTokenReferences(token.value);\n      token.extensions.references = references.reduce((acc, ref) => {\n        acc[ref.name] = ref;\n        return acc;\n      }, {});\n    });\n  }\n  function expandTokenReferences$1() {\n    allTokens.forEach(token => {\n      expandReferences(token);\n    });\n  }\n  function build() {\n    applyMiddlewares(\"pre\");\n    applyTransforms(\"pre\");\n    addConditionalTokens();\n    addReferences();\n    expandTokenReferences$1();\n    applyMiddlewares(\"post\");\n    applyTransforms(\"post\");\n    setupViews();\n  }\n  registerTokens();\n  registerTransform(...tokenTransforms);\n  registerMiddleware(...tokenMiddlewares);\n  build();\n  return dictionary;\n}\nfunction filterDefault(path) {\n  if (path[0] === \"DEFAULT\") return path;\n  return path.filter(item => item !== \"DEFAULT\");\n}\nfunction filterBaseCondition(path) {\n  return path.filter(item => item !== \"base\");\n}\nfunction getConditionalTokens(token) {\n  if (!token.extensions.conditions) return;\n  const {\n    conditions\n  } = token.extensions;\n  const tokens = [];\n  walkObject(conditions, (value, path) => {\n    const nextPath = filterBaseCondition(path);\n    if (!nextPath.length) return;\n    const nextToken = structuredClone(token);\n    nextToken.value = value;\n    nextToken.extensions.condition = nextPath.join(\":\");\n    tokens.push(nextToken);\n  });\n  return tokens;\n}\nfunction replaceRootWithColorPalette(path, roots) {\n  const startIndex = path.findIndex((_, index) => roots.every((rootElement, rootIndex) => path[index + rootIndex] === rootElement));\n  if (startIndex === -1) {\n    return path;\n  }\n  path.splice(startIndex, roots.length);\n  path.splice(startIndex, 0, \"colorPalette\");\n  return path;\n}\nconst tokenCategories = createProps()([\"aspectRatios\", \"zIndex\", \"opacity\", \"colors\", \"fonts\", \"fontSizes\", \"fontWeights\", \"lineHeights\", \"letterSpacings\", \"sizes\", \"shadows\", \"spacing\", \"radii\", \"cursor\", \"borders\", \"borderWidths\", \"borderStyles\", \"durations\", \"easings\", \"animations\", \"blurs\", \"gradients\", \"breakpoints\", \"assets\"]);\nexport { createTokenDictionary, tokenCategories };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { TreeCollection, filePathToTree } from '@zag-js/collection';\nimport { ref, createMachine, guards } from '@zag-js/core';\nimport { createScope, getByTypeahead, isComposingEvent, getEventTarget, isEditableElement, getEventKey, isModifierKey, dataAttr } from '@zag-js/dom-query';\nimport { createSplitProps, uniq, remove, add, compact, addOrRemove, first, isEqual } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/tree-view.anatomy.ts\nvar anatomy = createAnatomy(\"tree-view\").parts(\"root\", \"label\", \"tree\", \"item\", \"itemIndicator\", \"itemText\", \"branch\", \"branchControl\", \"branchTrigger\", \"branchContent\", \"branchText\", \"branchIndicator\", \"branchIndentGuide\");\nvar parts = anatomy.build();\nvar collection = options => {\n  return ref(new TreeCollection(options));\n};\ncollection.empty = () => {\n  return ref(new TreeCollection({\n    rootNode: {\n      children: []\n    }\n  }));\n};\nfunction filePathCollection(paths) {\n  return ref(filePathToTree(paths));\n}\n\n// src/tree-view.utils.ts\nfunction skipFn(ctx) {\n  return function skip({\n    indexPath\n  }) {\n    const paths = ctx.collection.getValuePath(indexPath).slice(0, -1);\n    return paths.some(value => !ctx.expandedValue.includes(value));\n  };\n}\nfunction getVisibleNodes(ctx) {\n  const nodes = [];\n  ctx.collection.visit({\n    skip: skipFn(ctx),\n    onEnter: (node, indexPath) => {\n      nodes.push({\n        node,\n        indexPath\n      });\n    }\n  });\n  return nodes;\n}\n\n// src/tree-view.dom.ts\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `tree:${ctx.id}:root`,\n  getLabelId: ctx => ctx.ids?.label ?? `tree:${ctx.id}:label`,\n  getNodeId: (ctx, value) => ctx.ids?.node?.(value) ?? `tree:${ctx.id}:node:${value}`,\n  getTreeId: ctx => ctx.ids?.tree ?? `tree:${ctx.id}:tree`,\n  getTreeEl: ctx => dom.getById(ctx, dom.getTreeId(ctx)),\n  focusNode: (ctx, value) => {\n    if (value == null) return;\n    const nodeId = dom.getNodeId(ctx, value);\n    dom.getById(ctx, nodeId)?.focus({\n      preventScroll: true\n    });\n  },\n  getMatchingNode(ctx, key) {\n    const nodes = getVisibleNodes(ctx);\n    const elements = nodes.map(({\n      node\n    }) => ({\n      textContent: ctx.collection.stringifyNode(node),\n      id: ctx.collection.getNodeValue(node)\n    }));\n    return getByTypeahead(elements, {\n      state: ctx.typeaheadState,\n      key,\n      activeId: ctx.focusedValue\n    });\n  }\n});\n\n// src/tree-view.connect.ts\nfunction connect(state, send, normalize) {\n  const collection2 = state.context.collection;\n  const expandedValue = Array.from(state.context.expandedValue);\n  const selectedValue = Array.from(state.context.selectedValue);\n  const isTypingAhead = state.context.isTypingAhead;\n  const focusedValue = state.context.focusedValue;\n  function getNodeState(props2) {\n    const {\n      node,\n      indexPath\n    } = props2;\n    const value = collection2.getNodeValue(node);\n    return {\n      value,\n      valuePath: collection2.getValuePath(indexPath),\n      disabled: Boolean(node.disabled),\n      focused: focusedValue == null ? isEqual(indexPath, [0]) : focusedValue === value,\n      selected: selectedValue.includes(value),\n      expanded: expandedValue.includes(value),\n      depth: indexPath.length,\n      isBranch: collection2.isBranchNode(node)\n    };\n  }\n  return {\n    collection: collection2,\n    expandedValue,\n    selectedValue,\n    expand(value) {\n      if (!value) return send({\n        type: \"EXPANDED.ALL\"\n      });\n      const _expandedValue = uniq(expandedValue.concat(...value));\n      send({\n        type: \"EXPANDED.SET\",\n        value: _expandedValue,\n        src: \"expand\"\n      });\n    },\n    collapse(value) {\n      if (!value) return send({\n        type: \"EXPANDED.SET\",\n        value: [],\n        src: \"collapseAll\"\n      });\n      const _expandedValue = uniq(remove(expandedValue, ...value));\n      send({\n        type: \"EXPANDED.SET\",\n        value: _expandedValue,\n        src: \"collapse\"\n      });\n    },\n    deselect(value) {\n      if (!value) return send({\n        type: \"SELECTED.SET\",\n        value: [],\n        src: \"deselectAll\"\n      });\n      const _selectedValue = uniq(remove(selectedValue, ...value));\n      send({\n        type: \"SELECTED.SET\",\n        value: _selectedValue,\n        src: \"deselect\"\n      });\n    },\n    select(value) {\n      if (!value) return send({\n        type: \"SELECTED.ALL\"\n      });\n      const nextValue = [];\n      if (state.context.selectionMode === \"single\") {\n        if (value.length > 0) nextValue.push(value[value.length - 1]);\n      } else {\n        nextValue.push(...selectedValue, ...value);\n      }\n      send({\n        type: \"SELECTED.SET\",\n        value: nextValue,\n        src: \"select\"\n      });\n    },\n    getVisibleNodes() {\n      return getVisibleNodes(state.context);\n    },\n    focus(value) {\n      dom.focusNode(state.context, value);\n    },\n    selectParent(value) {\n      const parentNode = collection2.getParentNode(value);\n      if (!parentNode) return;\n      const _selectedValue = add(selectedValue, collection2.getNodeValue(parentNode));\n      send({\n        type: \"SELECTED.SET\",\n        value: _selectedValue,\n        src: \"select.parent\"\n      });\n    },\n    expandParent(value) {\n      const parentNode = collection2.getParentNode(value);\n      if (!parentNode) return;\n      const _expandedValue = add(expandedValue, collection2.getNodeValue(parentNode));\n      send({\n        type: \"EXPANDED.SET\",\n        value: _expandedValue,\n        src: \"expand.parent\"\n      });\n    },\n    setExpandedValue(value) {\n      const _expandedValue = uniq(value);\n      send({\n        type: \"EXPANDED.SET\",\n        value: _expandedValue\n      });\n    },\n    setSelectedValue(value) {\n      const _selectedValue = uniq(value);\n      send({\n        type: \"SELECTED.SET\",\n        value: _selectedValue\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: dom.getRootId(state.context),\n        dir: state.context.dir\n      });\n    },\n    getLabelProps() {\n      return normalize.element({\n        ...parts.label.attrs,\n        id: dom.getLabelId(state.context),\n        dir: state.context.dir\n      });\n    },\n    getTreeProps() {\n      return normalize.element({\n        ...parts.tree.attrs,\n        id: dom.getTreeId(state.context),\n        dir: state.context.dir,\n        role: \"tree\",\n        \"aria-label\": \"Tree View\",\n        \"aria-labelledby\": dom.getLabelId(state.context),\n        \"aria-multiselectable\": state.context.selectionMode === \"multiple\" || void 0,\n        tabIndex: -1,\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (isComposingEvent(event)) return;\n          const target = getEventTarget(event);\n          if (isEditableElement(target)) return;\n          const node = target?.closest(\"[data-part=branch-control], [data-part=item]\");\n          if (!node) return;\n          const nodeId = node.dataset.value;\n          if (nodeId == null) {\n            console.warn(`[zag-js/tree-view] Node id not found for node`, node);\n            return;\n          }\n          const isBranchNode = node.matches(\"[data-part=branch-control]\");\n          const keyMap = {\n            ArrowDown(event2) {\n              if (isModifierKey(event2)) return;\n              event2.preventDefault();\n              send({\n                type: \"NODE.ARROW_DOWN\",\n                id: nodeId,\n                shiftKey: event2.shiftKey\n              });\n            },\n            ArrowUp(event2) {\n              if (isModifierKey(event2)) return;\n              event2.preventDefault();\n              send({\n                type: \"NODE.ARROW_UP\",\n                id: nodeId,\n                shiftKey: event2.shiftKey\n              });\n            },\n            ArrowLeft(event2) {\n              if (isModifierKey(event2) || node.dataset.disabled) return;\n              event2.preventDefault();\n              send({\n                type: isBranchNode ? \"BRANCH_NODE.ARROW_LEFT\" : \"NODE.ARROW_LEFT\",\n                id: nodeId\n              });\n            },\n            ArrowRight(event2) {\n              if (!isBranchNode || node.dataset.disabled) return;\n              event2.preventDefault();\n              send({\n                type: \"BRANCH_NODE.ARROW_RIGHT\",\n                id: nodeId\n              });\n            },\n            Home(event2) {\n              if (isModifierKey(event2)) return;\n              event2.preventDefault();\n              send({\n                type: \"NODE.HOME\",\n                id: nodeId,\n                shiftKey: event2.shiftKey\n              });\n            },\n            End(event2) {\n              if (isModifierKey(event2)) return;\n              event2.preventDefault();\n              send({\n                type: \"NODE.END\",\n                id: nodeId,\n                shiftKey: event2.shiftKey\n              });\n            },\n            Space(event2) {\n              if (node.dataset.disabled) return;\n              if (isTypingAhead) {\n                send({\n                  type: \"TREE.TYPEAHEAD\",\n                  key: event2.key\n                });\n              } else {\n                keyMap.Enter?.(event2);\n              }\n            },\n            Enter(event2) {\n              if (node.dataset.disabled) return;\n              const isLink = target?.closest(\"a[href]\");\n              if (!isLink) event2.preventDefault();\n              send({\n                type: isBranchNode ? \"BRANCH_NODE.CLICK\" : \"NODE.CLICK\",\n                id: nodeId,\n                src: \"keyboard\"\n              });\n            },\n            \"*\"(event2) {\n              if (node.dataset.disabled) return;\n              event2.preventDefault();\n              send({\n                type: \"SIBLINGS.EXPAND\",\n                id: nodeId\n              });\n            },\n            a(event2) {\n              if (!event2.metaKey || node.dataset.disabled) return;\n              event2.preventDefault();\n              send({\n                type: \"SELECTED.ALL\",\n                moveFocus: true\n              });\n            }\n          };\n          const key = getEventKey(event, state.context);\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            return;\n          }\n          if (!state.context.typeahead) return;\n          const isValidTypeahead = event.key.length === 1 && !isModifierKey(event);\n          if (!isValidTypeahead) return;\n          send({\n            type: \"TREE.TYPEAHEAD\",\n            key: event.key,\n            id: nodeId\n          });\n          event.preventDefault();\n        }\n      });\n    },\n    getNodeState,\n    getItemProps(props2) {\n      const itemState = getNodeState(props2);\n      return normalize.element({\n        ...parts.item.attrs,\n        id: dom.getNodeId(state.context, itemState.value),\n        dir: state.context.dir,\n        \"data-ownedby\": dom.getTreeId(state.context),\n        \"data-path\": props2.indexPath.join(\"/\"),\n        \"data-value\": itemState.value,\n        tabIndex: itemState.focused ? 0 : -1,\n        \"data-focus\": dataAttr(itemState.focused),\n        role: \"treeitem\",\n        \"aria-current\": itemState.selected ? \"true\" : void 0,\n        \"aria-selected\": itemState.disabled ? void 0 : itemState.selected,\n        \"data-selected\": dataAttr(itemState.selected),\n        \"aria-disabled\": itemState.disabled,\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"aria-level\": itemState.depth,\n        \"data-depth\": itemState.depth,\n        style: {\n          \"--depth\": itemState.depth\n        },\n        onFocus(event) {\n          event.stopPropagation();\n          send({\n            type: \"NODE.FOCUS\",\n            id: itemState.value\n          });\n        },\n        onClick(event) {\n          if (itemState.disabled) return;\n          const isMetaKey = event.metaKey || event.ctrlKey;\n          send({\n            type: \"NODE.CLICK\",\n            id: itemState.value,\n            shiftKey: event.shiftKey,\n            ctrlKey: isMetaKey\n          });\n          event.stopPropagation();\n          const isLink = event.currentTarget.matches(\"a[href]\");\n          if (!isLink) event.preventDefault();\n        }\n      });\n    },\n    getItemTextProps(props2) {\n      const itemState = getNodeState(props2);\n      return normalize.element({\n        ...parts.itemText.attrs,\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-selected\": dataAttr(itemState.selected),\n        \"data-focus\": dataAttr(itemState.focused)\n      });\n    },\n    getItemIndicatorProps(props2) {\n      const itemState = getNodeState(props2);\n      return normalize.element({\n        ...parts.itemIndicator.attrs,\n        \"aria-hidden\": true,\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-selected\": dataAttr(itemState.selected),\n        \"data-focus\": dataAttr(itemState.focused),\n        hidden: !itemState.selected\n      });\n    },\n    getBranchProps(props2) {\n      const nodeState = getNodeState(props2);\n      return normalize.element({\n        ...parts.branch.attrs,\n        \"data-depth\": nodeState.depth,\n        dir: state.context.dir,\n        \"data-branch\": nodeState.value,\n        role: \"treeitem\",\n        \"data-ownedby\": dom.getTreeId(state.context),\n        \"data-value\": nodeState.value,\n        \"aria-level\": nodeState.depth,\n        \"aria-selected\": nodeState.disabled ? void 0 : nodeState.selected,\n        \"data-path\": props2.indexPath.join(\"/\"),\n        \"data-selected\": dataAttr(nodeState.selected),\n        \"aria-expanded\": nodeState.expanded,\n        \"data-state\": nodeState.expanded ? \"open\" : \"closed\",\n        \"aria-disabled\": nodeState.disabled,\n        \"data-disabled\": dataAttr(nodeState.disabled),\n        style: {\n          \"--depth\": nodeState.depth\n        }\n      });\n    },\n    getBranchIndicatorProps(props2) {\n      const nodeState = getNodeState(props2);\n      return normalize.element({\n        ...parts.branchIndicator.attrs,\n        \"aria-hidden\": true,\n        \"data-state\": nodeState.expanded ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(nodeState.disabled),\n        \"data-selected\": dataAttr(nodeState.selected),\n        \"data-focus\": dataAttr(nodeState.focused)\n      });\n    },\n    getBranchTriggerProps(props2) {\n      const nodeState = getNodeState(props2);\n      return normalize.element({\n        ...parts.branchTrigger.attrs,\n        role: \"button\",\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(nodeState.disabled),\n        \"data-state\": nodeState.expanded ? \"open\" : \"closed\",\n        \"data-value\": nodeState.value,\n        onClick(event) {\n          if (nodeState.disabled) return;\n          send({\n            type: \"BRANCH_TOGGLE.CLICK\",\n            id: nodeState.value\n          });\n          event.stopPropagation();\n        }\n      });\n    },\n    getBranchControlProps(props2) {\n      const nodeState = getNodeState(props2);\n      return normalize.element({\n        ...parts.branchControl.attrs,\n        role: \"button\",\n        id: dom.getNodeId(state.context, nodeState.value),\n        dir: state.context.dir,\n        tabIndex: nodeState.focused ? 0 : -1,\n        \"data-path\": props2.indexPath.join(\"/\"),\n        \"data-state\": nodeState.expanded ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(nodeState.disabled),\n        \"data-selected\": dataAttr(nodeState.selected),\n        \"data-focus\": dataAttr(nodeState.focused),\n        \"data-value\": nodeState.value,\n        \"data-depth\": nodeState.depth,\n        onFocus(event) {\n          send({\n            type: \"NODE.FOCUS\",\n            id: nodeState.value\n          });\n          event.stopPropagation();\n        },\n        onClick(event) {\n          if (nodeState.disabled) return;\n          const isMetaKey = event.metaKey || event.ctrlKey;\n          send({\n            type: \"BRANCH_NODE.CLICK\",\n            id: nodeState.value,\n            shiftKey: event.shiftKey,\n            ctrlKey: isMetaKey\n          });\n          event.stopPropagation();\n        }\n      });\n    },\n    getBranchTextProps(props2) {\n      const nodeState = getNodeState(props2);\n      return normalize.element({\n        ...parts.branchText.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(nodeState.disabled),\n        \"data-state\": nodeState.expanded ? \"open\" : \"closed\"\n      });\n    },\n    getBranchContentProps(props2) {\n      const nodeState = getNodeState(props2);\n      return normalize.element({\n        ...parts.branchContent.attrs,\n        role: \"group\",\n        dir: state.context.dir,\n        \"data-state\": nodeState.expanded ? \"open\" : \"closed\",\n        \"data-depth\": nodeState.depth,\n        \"data-path\": props2.indexPath.join(\"/\"),\n        \"data-value\": nodeState.value,\n        hidden: !nodeState.expanded\n      });\n    },\n    getBranchIndentGuideProps(props2) {\n      const nodeState = getNodeState(props2);\n      return normalize.element({\n        ...parts.branchIndentGuide.attrs,\n        \"data-depth\": nodeState.depth\n      });\n    }\n  };\n}\nvar {\n  and\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"tree-view\",\n    initial: \"idle\",\n    context: {\n      expandedValue: [],\n      selectedValue: [],\n      focusedValue: null,\n      expandOnClick: true,\n      selectionMode: \"single\",\n      typeahead: true,\n      ...ctx,\n      collection: ctx.collection ?? collection.empty(),\n      typeaheadState: getByTypeahead.defaultOptions\n    },\n    computed: {\n      isMultipleSelection: ctx2 => ctx2.selectionMode === \"multiple\"\n    },\n    on: {\n      \"EXPANDED.SET\": {\n        actions: [\"setExpanded\"]\n      },\n      \"SELECTED.SET\": {\n        actions: [\"setSelected\"]\n      },\n      \"SELECTED.ALL\": [{\n        guard: and(\"isMultipleSelection\", \"moveFocus\"),\n        actions: [\"selectAllNodes\", \"focusTreeLastNode\"]\n      }, {\n        guard: \"isMultipleSelection\",\n        actions: [\"selectAllNodes\"]\n      }],\n      \"EXPANDED.ALL\": {\n        actions: [\"expandAllBranches\"]\n      }\n    },\n    states: {\n      idle: {\n        on: {\n          \"NODE.FOCUS\": {\n            actions: [\"setFocusedNode\"]\n          },\n          \"NODE.ARROW_DOWN\": [{\n            guard: and(\"isShiftKey\", \"isMultipleSelection\"),\n            actions: [\"focusTreeNextNode\", \"extendSelectionToNextNode\"]\n          }, {\n            actions: [\"focusTreeNextNode\"]\n          }],\n          \"NODE.ARROW_UP\": [{\n            guard: and(\"isShiftKey\", \"isMultipleSelection\"),\n            actions: [\"focusTreePrevNode\", \"extendSelectionToPrevNode\"]\n          }, {\n            actions: [\"focusTreePrevNode\"]\n          }],\n          \"NODE.ARROW_LEFT\": {\n            actions: [\"focusBranchNode\"]\n          },\n          \"BRANCH_NODE.ARROW_LEFT\": [{\n            guard: \"isBranchExpanded\",\n            actions: [\"collapseBranch\"]\n          }, {\n            actions: [\"focusBranchNode\"]\n          }],\n          \"BRANCH_NODE.ARROW_RIGHT\": [{\n            guard: and(\"isBranchFocused\", \"isBranchExpanded\"),\n            actions: [\"focusBranchFirstNode\"]\n          }, {\n            actions: [\"expandBranch\"]\n          }],\n          \"SIBLINGS.EXPAND\": {\n            actions: [\"expandSiblingBranches\"]\n          },\n          \"NODE.HOME\": [{\n            guard: and(\"isShiftKey\", \"isMultipleSelection\"),\n            actions: [\"extendSelectionToFirstNode\", \"focusTreeFirstNode\"]\n          }, {\n            actions: [\"focusTreeFirstNode\"]\n          }],\n          \"NODE.END\": [{\n            guard: and(\"isShiftKey\", \"isMultipleSelection\"),\n            actions: [\"extendSelectionToLastNode\", \"focusTreeLastNode\"]\n          }, {\n            actions: [\"focusTreeLastNode\"]\n          }],\n          \"NODE.CLICK\": [{\n            guard: and(\"isCtrlKey\", \"isMultipleSelection\"),\n            actions: [\"toggleNodeSelection\"]\n          }, {\n            guard: and(\"isShiftKey\", \"isMultipleSelection\"),\n            actions: [\"extendSelectionToNode\"]\n          }, {\n            actions: [\"selectNode\"]\n          }],\n          \"BRANCH_NODE.CLICK\": [{\n            guard: and(\"isCtrlKey\", \"isMultipleSelection\"),\n            actions: [\"toggleNodeSelection\"]\n          }, {\n            guard: and(\"isShiftKey\", \"isMultipleSelection\"),\n            actions: [\"extendSelectionToNode\"]\n          }, {\n            guard: \"openOnClick\",\n            actions: [\"selectNode\", \"toggleBranchNode\"]\n          }, {\n            actions: [\"selectNode\"]\n          }],\n          \"BRANCH_TOGGLE.CLICK\": {\n            actions: [\"toggleBranchNode\"]\n          },\n          \"TREE.TYPEAHEAD\": {\n            actions: [\"focusMatchedNode\"]\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      isBranchFocused: (ctx2, evt) => ctx2.focusedValue === evt.id,\n      isBranchExpanded: (ctx2, evt) => ctx2.expandedValue.includes(evt.id),\n      isShiftKey: (_ctx, evt) => evt.shiftKey,\n      isCtrlKey: (_ctx, evt) => evt.ctrlKey,\n      hasSelectedItems: ctx2 => ctx2.selectedValue.length > 0,\n      isMultipleSelection: ctx2 => ctx2.isMultipleSelection,\n      moveFocus: (_ctx, evt) => !!evt.moveFocus,\n      openOnClick: ctx2 => !!ctx2.expandOnClick\n    },\n    actions: {\n      selectNode(ctx2, evt) {\n        set.selected(ctx2, [evt.id]);\n      },\n      setFocusedNode(ctx2, evt) {\n        set.focused(ctx2, evt.id);\n      },\n      clearFocusedNode(ctx2) {\n        set.focused(ctx2, null);\n      },\n      clearSelectedItem(ctx2) {\n        set.selected(ctx2, []);\n      },\n      toggleBranchNode(ctx2, evt) {\n        set.expanded(ctx2, addOrRemove(ctx2.expandedValue, evt.id));\n      },\n      expandBranch(ctx2, evt) {\n        set.expanded(ctx2, add(ctx2.expandedValue, evt.id));\n      },\n      collapseBranch(ctx2, evt) {\n        set.expanded(ctx2, remove(ctx2.expandedValue, evt.id));\n      },\n      setExpanded(ctx2, evt) {\n        set.expanded(ctx2, evt.value);\n      },\n      setSelected(ctx2, evt) {\n        set.selected(ctx2, evt.value);\n      },\n      focusTreeFirstNode(ctx2) {\n        const firstNode = ctx2.collection.getFirstNode();\n        const firstValue = ctx2.collection.getNodeValue(firstNode);\n        dom.focusNode(ctx2, firstValue);\n      },\n      focusTreeLastNode(ctx2) {\n        const lastNode = ctx2.collection.getLastNode();\n        const lastValue = ctx2.collection.getNodeValue(lastNode);\n        dom.focusNode(ctx2, lastValue);\n      },\n      focusBranchFirstNode(ctx2, evt) {\n        const branchNode = ctx2.collection.findNode(evt.id);\n        const firstNode = ctx2.collection.getFirstNode(branchNode);\n        const firstValue = ctx2.collection.getNodeValue(firstNode);\n        dom.focusNode(ctx2, firstValue);\n      },\n      focusTreeNextNode(ctx2, evt) {\n        let nextNode = ctx2.collection.getNextNode(evt.id, {\n          skip: skipFn(ctx2)\n        });\n        nextNode = nextNode ?? ctx2.collection.getFirstNode();\n        const nextValue = ctx2.collection.getNodeValue(nextNode);\n        dom.focusNode(ctx2, nextValue);\n      },\n      focusTreePrevNode(ctx2, evt) {\n        let prevNode = ctx2.collection.getPreviousNode(evt.id, {\n          skip: skipFn(ctx2)\n        });\n        prevNode = prevNode ?? ctx2.collection.getLastNode();\n        const prevValue = ctx2.collection.getNodeValue(prevNode);\n        dom.focusNode(ctx2, prevValue);\n      },\n      focusBranchNode(ctx2, evt) {\n        const parentNode = ctx2.collection.getParentNode(evt.id);\n        const parentValue = parentNode ? ctx2.collection.getNodeValue(parentNode) : void 0;\n        dom.focusNode(ctx2, parentValue);\n      },\n      selectAllNodes(ctx2) {\n        set.selected(ctx2, ctx2.collection.getValues());\n      },\n      focusMatchedNode(ctx2, evt) {\n        const node = dom.getMatchingNode(ctx2, evt.key);\n        dom.focusNode(ctx2, node?.id);\n      },\n      toggleNodeSelection(ctx2, evt) {\n        const selectedValue = addOrRemove(ctx2.selectedValue, evt.id);\n        set.selected(ctx2, selectedValue);\n      },\n      expandAllBranches(ctx2) {\n        const nextValue = ctx2.collection.getBranchValues();\n        set.expanded(ctx2, nextValue);\n      },\n      expandSiblingBranches(ctx2, evt) {\n        const indexPath = ctx2.collection.getIndexPath(evt.id);\n        if (!indexPath) return;\n        const nodes = ctx2.collection.getSiblingNodes(indexPath);\n        const values = nodes.map(node => ctx2.collection.getNodeValue(node));\n        set.expanded(ctx2, uniq(values));\n      },\n      extendSelectionToNode(ctx2, evt) {\n        const anchorValue = first(ctx2.selectedValue) || ctx2.collection.getNodeValue(ctx2.collection.getFirstNode());\n        const targetValue = evt.id;\n        let values = [anchorValue, targetValue];\n        let hits = 0;\n        const visibleNodes = getVisibleNodes(ctx2);\n        visibleNodes.forEach(({\n          node\n        }) => {\n          const nodeValue = ctx2.collection.getNodeValue(node);\n          if (hits === 1) values.push(nodeValue);\n          if (nodeValue === anchorValue || nodeValue === targetValue) hits++;\n        });\n        set.selected(ctx2, uniq(values));\n      },\n      extendSelectionToNextNode(ctx2, evt) {\n        const nextNode = ctx2.collection.getNextNode(evt.id, {\n          skip: skipFn(ctx2)\n        });\n        if (!nextNode) return;\n        const values = new Set(ctx2.selectedValue);\n        const nextValue = ctx2.collection.getNodeValue(nextNode);\n        if (nextValue == null) return;\n        if (values.has(evt.id) && values.has(nextValue)) {\n          values.delete(evt.id);\n        } else if (!values.has(nextValue)) {\n          values.add(nextValue);\n        }\n        set.selected(ctx2, Array.from(values));\n      },\n      extendSelectionToPrevNode(ctx2, evt) {\n        const prevNode = ctx2.collection.getPreviousNode(evt.id, {\n          skip: skipFn(ctx2)\n        });\n        if (!prevNode) return;\n        const values = new Set(ctx2.selectedValue);\n        const prevValue = ctx2.collection.getNodeValue(prevNode);\n        if (prevValue == null) return;\n        if (values.has(evt.id) && values.has(prevValue)) {\n          values.delete(evt.id);\n        } else if (!values.has(prevValue)) {\n          values.add(prevValue);\n        }\n        set.selected(ctx2, Array.from(values));\n      },\n      extendSelectionToFirstNode(ctx2) {\n        const currentSelection = first(ctx2.selectedValue);\n        const values = [];\n        ctx2.collection.visit({\n          skip: skipFn(ctx2),\n          onEnter: node => {\n            const nodeValue = ctx2.collection.getNodeValue(node);\n            values.push(nodeValue);\n            if (nodeValue === currentSelection) {\n              return \"stop\";\n            }\n          }\n        });\n        set.selected(ctx2, values);\n      },\n      extendSelectionToLastNode(ctx2) {\n        const currentSelection = first(ctx2.selectedValue);\n        const values = [];\n        let current = false;\n        ctx2.collection.visit({\n          skip: skipFn(ctx2),\n          onEnter: node => {\n            const nodeValue = ctx2.collection.getNodeValue(node);\n            if (nodeValue === currentSelection) current = true;\n            if (current) values.push(nodeValue);\n          }\n        });\n        set.selected(ctx2, values);\n      }\n    }\n  });\n}\nvar invoke = {\n  focusChange(ctx) {\n    ctx.onFocusChange?.({\n      focusedValue: ctx.focusedValue\n    });\n  },\n  expandedChange(ctx) {\n    ctx.onExpandedChange?.({\n      expandedValue: Array.from(ctx.expandedValue),\n      focusedValue: ctx.focusedValue\n    });\n  },\n  selectionChange(ctx) {\n    ctx.onSelectionChange?.({\n      selectedValue: Array.from(ctx.selectedValue),\n      focusedValue: ctx.focusedValue\n    });\n  }\n};\nvar set = {\n  selected(ctx, value) {\n    if (isEqual(ctx.selectedValue, value)) return;\n    ctx.selectedValue = value;\n    invoke.selectionChange(ctx);\n  },\n  focused(ctx, value) {\n    if (isEqual(ctx.focusedValue, value)) return;\n    ctx.focusedValue = value;\n    invoke.focusChange(ctx);\n  },\n  expanded(ctx, value) {\n    if (isEqual(ctx.expandedValue, value)) return;\n    ctx.expandedValue = value;\n    invoke.expandedChange(ctx);\n  }\n};\nvar props = createProps()([\"ids\", \"collection\", \"dir\", \"expandedValue\", \"expandOnClick\", \"focusedValue\", \"getRootNode\", \"id\", \"onExpandedChange\", \"onFocusChange\", \"onSelectionChange\", \"selectedValue\", \"selectionMode\", \"typeahead\"]);\nvar splitProps = createSplitProps(props);\nvar itemProps = createProps()([\"node\", \"indexPath\"]);\nvar splitItemProps = createSplitProps(itemProps);\nexport { anatomy, collection, connect, filePathCollection, itemProps, machine, props, splitItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}